/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

import fs from 'fs';
//const fs = require('fs');
//const os = require('os');
import path from 'path';
//const path = require('path');
//const minimist = require('minimist');
//const semver = require('semver');
import ts from 'typescript';
import peg from 'pegjs';
import tspegjs from 'ts-pegjs';
//const ts = require('typescript');
//const peg = require('pegjs');
//const tspegjs = require('ts-pegjs');

//import {ChildProcess} from 'child_process';

const projectRoot = './'; //path.resolve(__dirname, '.');

const pegsrc = {
  grammar: 'src/peg-parser.pegjs',
  astNodes: 'src/manifest-ast-nodes.ts',
  output: 'src/gen/peg-parser.ts',
  railroad: 'manifest-railroad.html',
  tspegjs: {
    noTsLint: false,
    tslintIgnores: 'no-any, only-arrow-functions, max-line-length, trailing-comma, interface-name, switch-default, object-literal-shorthand',
    customHeader: `
// DO NOT EDIT, AUTOGENERATED from src/runtime/manifest-parser.pegjs
import * as AstNode from '../manifest-ast-nodes.js';
import {Flags} from '../../../runtime/dist/flags.js';
//import {CheckType} from '../../runtime/check.js';
//import {ClaimType} from '../../runtime/claim.js';

export enum ClaimType {
  IsTag = 'is-tag',
  DerivesFrom = 'derives-from',
}

export enum CheckType {
  HasTag = 'has-tag',
  IsFromHandle = 'is-from-handle',
  IsFromOutput = 'is-from-output',
  IsFromStore = 'is-from-store',
  Implication = 'implication',
}
`
  }
};

function readProjectFile(relativePath) {
  return fs.readFileSync(path.resolve(projectRoot, relativePath), 'utf-8');
}

function pegit() {
  // const ts = require('typescript');
  // const peg = require('pegjs');
  // const tspegjs = require('ts-pegjs');

  const options = {
    format: 'bare',
    output: 'source',
    trace: false,
    plugins: [tspegjs], // Used by manifest-parser
    tspegjs: pegsrc.tspegjs,
    returnTypes: {}
  };

  // If an ast-nodes file has been specified, use the TypeScript compiler to build an AST tree
  // of that file and extract the list of exported interfaces and types. The ts-pegjs plugin
  // uses these to correctly type the node objects generated by the pegjs parser.
  if (pegsrc.astNodes) {
    const program = ts.createProgram([pegsrc.astNodes], {});
    program.getTypeChecker(); // Required, not sure why
    program.getSourceFiles().filter(f => f.fileName === pegsrc.astNodes).forEach(f => {
      ts.forEachChild(f, node => {
        if ([ts.SyntaxKind.InterfaceDeclaration, ts.SyntaxKind.TypeAliasDeclaration].includes(node.kind) &&
            (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) !== 0) {
          const name = node.name.getText();
          options.returnTypes[name] = `AstNode.${name}`;
        }
      });
    });
  }

  const source = peg.generate(readProjectFile(pegsrc.grammar), options);
  const outputFile = path.resolve(projectRoot, pegsrc.output);
  const dir = path.dirname(outputFile);
  if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, {recursive: true});
  }
  fs.writeFileSync(outputFile, source);

  return true;
}

pegit();
