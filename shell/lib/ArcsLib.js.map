{"version":3,"sources":["webpack:///webpack/bootstrap 7841e3c274292331f8d4","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/platform/assert-web.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/recipe.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/strategizer/strategizer.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/walker.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/type.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/util.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/tracelib/trace.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/recipe-util.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/schema.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/particle-spec.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/description.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/manifest.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/entity.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/symbols.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/scheduler.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/dom-particle.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/loader.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/particle.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/relation.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/shape.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/view-mapper-base.js","webpack:///../~/process/browser.js","webpack:///../~/webpack/buildin/global.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/platform/fs-web.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/api-channel.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/browser/lib/xen-state.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/browser/lib/xen-template.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/dom-context.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/handle.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/search.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/runtime.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/slot.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/storage/key-base.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/storage/storage-provider-base.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/storage/storage-provider-factory.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/transformation-dom-particle.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/type-variable.js","webpack:///./source/browser-cdn-loader.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/arc.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/planner.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/slot-composer.js","webpack:///./source/ArcsLib.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/converters/jsonldToManifest.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/devtools/shared/arc-registry.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/platform/btoa-web.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/platform/devtools-channel-web.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/platform/firebase-web.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/platform/vm-web.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/browser/lib/model-select.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/browser/lib/x-list.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/browser/lib/xen-element.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/build/manifest-parser.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/debug/abstract-devtools-channel.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/debug/devtools-channel-provider.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/debug/outer-port-attachment.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/description-dom-formatter.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/dom-slot.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/fake-pec-factory.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/fetch-web.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/identifier.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/inner-PEC.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/manifest-meta.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/message-channel.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/outer-PEC.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/particle-execution-context.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/connection-constraint.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/digest-web.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/handle-connection.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/handle.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/particle.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/slot-connection.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/slot.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/type-checker.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/walker-base.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/relevance.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/speculator.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/storage/firebase-storage.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/storage/in-memory-storage.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/add-use-views.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/assign-remote-views.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/assign-views-by-tag-and-type.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/combined-strategy.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/convert-constraints-to-connections.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/copy-remote-views.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/create-description-handle.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/fallback-fate.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/group-handle-connections.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/init-population.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/init-search.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/map-consumed-slots.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/map-remote-slots.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/match-particle-by-verb.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/name-unnamed-connections.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/search-tokens-to-particles.js","webpack:////Users/sjmiles/Sites/projects/arcs/arcs/runtime/tuple-fields.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACZA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C,uBAAuB,wBAAwB;AAC/C,mBAAmB,wBAAwB,EAAE;AAC7C,4BAA4B,6BAA6B;AACzD,eAAe,sBAAsB,EAAE;AACvC,sBAAsB,yBAAyB;AAC/C,eAAe,oBAAoB,EAAE;AACrC,oBAAoB,qBAAqB;AACzC,+BAA+B,oCAAoC;AACnE,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;;AAE/D;AACA;AACA;AACA,qCAAqC,KAAK,GAAG,gBAAgB;AAC7D;AACA,4DAA4D,kBAAkB;AAC9E;AACA;AACA,0FAA0F,+BAA+B,IAAI,sBAAsB;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI;AACrC,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,IAAI;AACjC,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,IAAI;AACjC,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC9ZA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uCAAuC,2CAA2C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;;AAEA,gCAAgC,QAAQ;AACxC;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,2DAA2D;AAC9E;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAA2D;AAC/E;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;ACrRA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAwC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAgD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8CAA8C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACnEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA,MAAM;AACN;AACA,2CAA2C,UAAU,EAAE,SAAS;AAChE;AACA,gHAAuB,KAAK,MAAM,EAAE,SAAS,IAAI,WAAW,kBAAkB,KAAK;AACnF;AACA,MAAM;AACN,6CAA6C,KAAK;AAClD;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,mCAAmC,MAAM,KAAK,OAAO;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gCAAgC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA,O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;ACxQA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;+CCzDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;;;;;;;;;;AClPA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,wBAAwB;AACrC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,iDAAiD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,eAAe;AACxC;AACA;AACA,cAAc;AACd,KAAK;AACL;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AC/PA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uHAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,GAAG,SAAS,KAAK,iBAAiB,UAAU;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,KAAK,SAAS,UAAU,cAAc,MAAM,SAAS,cAAc;AAC/F;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,qCAAqC,KAAK,SAAS,UAAU,aAAa,MAAM,SAAS,cAAc;AACvG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,iBAAiB;AAC3D,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,UAAU,mCAAmC,iBAAiB;;AAEzF;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA,gGAAgG,8BAA8B;AAC9H,8BAA8B,WAAW,GAAG,KAAK;AACjD,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;AC5NA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,uEAAuE;AAChF;AACA,WAAW,kCAAkC;AAC7C;AACA,cAAc;AACd,KAAK;AACL,YAAY;AACZ;;AAEA;AACA,SAAS,uEAAuE;AAChF,sBAAsB,kCAAkC,OAAO,+GAA0D;AACzH,6BAA6B,uEAAuE;AACpG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8MAAqH,EAAE;AACvH,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,UAAU,OAAO,cAAc;AAC5D,gDAAgD,aAAa,GAAG,mBAAmB,EAAE,yBAAyB,GAAG,QAAQ;AACzH,sBAAsB,iBAAiB,GAAG,mBAAmB;AAC7D,uFAAuF,EAAE;AACzF;AACA;AACA,sBAAsB,4BAA4B,UAAU,yBAAyB,EAAE,OAAO;AAC9F;AACA,oCAAoC,0BAA0B,EAAE,QAAQ;AACxE;AACA,2DAA2D,IAAI;AAC/D,OAAO;AACP,KAAK;AACL;AACA;AACA,sCAAsC,aAAa;AACnD;AACA;AACA,8BAA8B,QAAQ,KAAK,WAAW;AACtD;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AC1LA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,mBAAmB,wBAAwB;AAC3C,4BAA4B,6BAA6B;;AAEzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,UAAU;AACV,QAAQ;;AAER;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,QAAQ;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA;AACA,qCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+IAAsD,sBAAsB;AAC5E,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4IAAmD,YAAY;;AAE/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,YAAY,IAAI,UAAU;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iJAAwD,YAAY;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,oJAA2D,qBAAqB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,yBAAyB,QAAQ,kBAAkB;AACrE;AACA;AACA,KAAK;AACL,gBAAgB,gBAAgB;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,gCAAgC,EAAE;AACrF,mDAAmD,gCAAgC,EAAE;AACrF;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;ACzcA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,QAAQ;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ,GAAG,oBAAoB;AAC7C;AACA;AACA;AACA,SAAS,aAAa;AACtB;AACA;AACA;AACA;AACA,8HAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,yCAAyC;AAClD;AACA,4BAA4B;AAC5B,qBAAqB,SAAS;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,qBAAqB,iCAAiC;AACtD;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA,uCAAuC,SAAS,SAAS,sBAAsB;AAC/E,EAAE;AACF,IAAI;AACJ,IAAI,UAAU;AACd;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iCAAiC,GAAG;AACpC;;AAEA;AACA;AACA;AACA,kEAAkE,SAAS;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0DAA0D,yBAAyB;AACnF;AACA;AACA;AACA;AACA,0DAA0D,uBAAuB;AACjF;AACA;AACA;AACA;AACA,wCAAwC,sBAAsB,sBAAsB,yBAAyB;AAC7G;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB,sBAAsB,uBAAuB;AACzG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,OAAO;AACP;AACA;AACA,2IAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mKAA0E,UAAU;AACpF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yIAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+BAA+B;AACpE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sCAAsC;AAC/D;AACA;AACA,sCAAsC,mBAAmB,yBAAyB,qBAAqB,cAAc,cAAc;AACnI;AACA;AACA;AACA,SAAS;AACT;AACA,4CAA4C,qBAAqB,uBAAuB,cAAc;AACtG;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4DAA4D,2BAA2B;AACvF;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX,qIAA4C,gBAAgB;AAC5D;AACA;;AAEA;AACA;AACA;AACA;AACA,qEAAqE,+BAA+B;AACpG;AACA;AACA;AACA;AACA,0DAA0D,oBAAoB,0BAA0B,gBAAgB;AACxH;AACA;AACA;AACA;AACA,sBAAsB,aAAa,WAAW,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,yBAAyB,uBAAuB,cAAc;AAChH;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS,uBAAuB,cAAc;AAClG;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB,sCAAsC,yBAAyB;AACpH,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa,MAAM,uBAAuB;AACxD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA,wBAAwB,oBAAoB;AAC5C,OAAO;AACP,gCAAgC,WAAW;AAC3C;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;;;AC9sBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB,OAAO,sBAAsB;AAC3D;AACA,cAAc,gBAAgB,GAAG,uBAAuB;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0DAAgB;;;;;;;;;ACThB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,mCAAmC;;AAErE;AACA,0FAA8B,0CAA0C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,2FAA+B,yDAAyD,sEAAsE;;AAE9J;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACrGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAIC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uDAAuD;AACvD,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB;AACpB;AACA;AACA,uBAAuB,cAAc;AACrC;AACA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACxIA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,KAAK;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,+QAA+H,sBAAsB;AACrJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uGAAqC,wCAAwC;AAC7E;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oFAAoF,EAAE;AACtF;AACA,kCAAkC,wCAAwC;AAC1E,mNAA0H,SAAS;AACnI;AACA;;AAEA;AACA,4BAA4B,uVAA8E;AAC1G;;AAEA;;AAEA;;;;;;;;;;;;AC5FA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA+B,+DAA+D,0BAA0B;AACxH,6HAAiE,qDAAqD,yBAAyB;AAC/I;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uIAA8C,SAAS;AACvD;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,oCAAoC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,EAAE,0BAA0B;AAC5B;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yCAAyC,KAAK,EAAE;;AAEhF;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA,0DAAgB;;;;;;;;;;;ACvOhB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AC7BA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,cAAc;AACd,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;;AAEnD;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,sGAAsG;AAC/I,yCAAyC,mJAAmJ;AAC5L;AACA;;AAEA;AACA,yCAAyC,gGAAgG;AACzI,yCAAyC,2IAA2I;AACpL,YAAY;AACZ;;AAEA;AACA,iCAAiC,sBAAsB,OAAO,sBAAsB;AACpF,iCAAiC,mCAAmC,OAAO,mCAAmC;AAC9G;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,8GAA8G;AACxI;AACA,4BAA4B,4FAA4F;AACxH,OAAO;AACP,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC1KA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX,6BAA6B;AAC7B;AACA;AACA,KAAK;;AAEL,YAAY;AACZ;AACA;AAAA;AAAA;;;;;;;ACnFA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;ACvLtC;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACPA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oJAA2D,MAAM;AACjE;AACA;;AAEA;AACA,wIAA+C,GAAG;AAClD;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,yDAAyD,mBAAmB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,oBAAoB;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA,OAAO,kEAAkE;AACzE,uDAAuD,mGAA8C;AACrG;AACA,OAAO,uJAAiG;;AAExG,kCAAkC,iEAAiE;AACnG,yCAAyC,yCAAyC;AAClF,oCAAoC,qBAAqB;AACzD,sCAAsC,mFAAmF;AACzH,qCAAqC,6CAA6C;;AAElF,oCAAoC,mEAAmE;AACvG,yCAAyC;AACzC;AACA,wFAAwF;AACxF,uCAAuC,oEAAoE;AAC3G,0CAA0C,oEAAoE;AAC9G,uCAAuC,gEAAgE;AACvG,yCAAyC,gEAAgE;AACzG,0CAA0C,uCAAuC;AACjF,yCAAyC,oBAAoB;AAC7D,kCAAkC,oEAAoE;;AAEtG,+CAA+C,6CAA6C;AAC5F,+CAA+C,6CAA6C;;AAE5F,6CAA6C,iJAA4F;AACzI,sDAAsD,2IAAsF;;AAE5I,0CAA0C,kEAAkE;AAC5G,mDAAmD,uCAAuC;;AAE1F;AACA,OAAO,qLAAqL;AAC5L,oDAAoD,iDAAiD;AACrG,yCAAyC,0HAA0H;;AAEnK,2CAA2C,kEAAkE;AAC7G;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA,OAAO,+DAA+D;AACtE,qDAAqD,mGAA8C;AACnG;AACA,OAAO,uJAAiG;;AAExG,qCAAqC,iEAAiE;AACtG,4CAA4C,8CAA8C;AAC1F,uCAAuC,qBAAqB;AAC5D,yCAAyC,wEAAwE;AACjH,wCAAwC,6CAA6C;;AAErF,iCAAiC,mEAAmE;AACpG,sCAAsC;AACtC;AACA,0FAA0F;AAC1F,oCAAoC,yEAAyE;AAC7G,uCAAuC,yEAAyE;AAChH,oCAAoC,gEAAgE;AACpG,sCAAsC,gEAAgE;AACtG,uCAAuC,uCAAuC;AAC9E,sCAAsC,oBAAoB;AAC1D,+BAA+B,oEAAoE;;AAEnG,4CAA4C,kDAAkD;AAC9F,kDAAkD,6CAA6C;;AAE/F,0CAA0C,iJAA4F;AACtI,6DAA6D,gJAA2F;AACxJ,uCAAuC,kEAAkE;AACzG,0DAA0D,4CAA4C;AACtG;AACA,OAAO,qLAAqL;AAC5L,2DAA2D,sDAAsD;AACjH,4CAA4C,0HAA0H;;AAEtK,wCAAwC,kEAAkE;AAC1G;AACA;;AAEQ;AACR,2EAAgB;;;;;;;;ACtVhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,OAAO;AACzE;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD,uBAAuB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,mCAAmC,KAAK,0EAA0E,MAAM;AACxH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B,4BAA4B,IAAI;AAChC;;AAEA;;AAEA;AACA;AACA,qDAAqD,QAAQ,GAAG;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;;;;;;ACvVD;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,oBAAoB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+BAA+B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,gCAAgC,cAAc,UAAU,MAAM,2BAA2B,uBAAuB;AAChH;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc,2BAA2B,OAAO,GAAG,MAAM;AAClF;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,6BAA6B,cAAc,6BAA6B,OAAO;AAC/E;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qJAA4D,OAAO;AACnE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEQ;;;;;;;;;;;;;AC/MR;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO,YAAY;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0DAAgB;;;;;;;;;ACtNhB;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,gBAAgB,qBAAqB;AACrC,0BAA0B,+BAA+B;AACzD,wBAAwB,6BAA6B;AACrD;AACA;AACA,qJAA4D,MAAM;AAClE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,YAAY;;AAExC;AACA;AACA;AACA,wDAAwD,EAAE;AAC1D;AACA;AACA,0BAA0B,kCAAkC,EAAE,eAAe;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACpGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,KAAK;AACL;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;ACzCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C,aAAa,kBAAkB;AAC/B,gBAAgB,sBAAsB;AACtC,uBAAuB,yBAAyB;AAChD,0BAA0B,iCAAiC;;AAE3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mFAAmF;;AAEnH;AACA;AACA;AACA,oCAAoC,2EAA2E;AAC/G;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,qEAAqE;;AAEpG;AACA,iCAAiC,6DAA6D;AAC9F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,4JAAmE,aAAa;AAChF,4CAA4C,iFAAiF;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+HAAsC,aAAa;AACnD;AACA,uCAAuC,oBAAoB,YAAY,cAAc,aAAa,wBAAwB;AAC1H;AACA;AACA,gCAAgC,0GAA0G;AAC1I;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;ACbA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2FAA+B,8DAA8D,4BAA4B;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ,GAAG,oBAAoB;AAC7C;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sCAAsC;AACnE;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+FAAmC,wDAAwD;AAC3F,sDAAsD;;AAEtD;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD,gCAAgC;AACrF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA,uBAAuB,qBAAqB;AAC5C;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AAAA;AAAA;;;;;;;;;ACzGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AAAA;AAAA;;;;;;;;;ACtCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,8BAA8B,EAAE,sBAAsB;AACrE,QAAQ,yCAAyC,gBAAgB;AACjE;AACA;AACA;AACA,2CAA2C,YAAY,qBAAqB,YAAY,UAAU;AAClG;AACA;;AAEA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wFAAwF,SAAS,kBAAkB,OAAO,cAAc,0BAA0B,oBAAoB;AACtL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK,MAAM,IAAI;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gaAAmG;AAC/H;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AC3EA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoB;;AAEpB;AACA,eAAe,0DAA0D;AACzE;AACA,kGAA6C,GAAG;AAChD;AACA;AACA;AACA;AACA;AACA,8CAA8C,0BAA0B;AACxE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uHAAiE,MAAM;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,0BAA0B;;AAE/C,yBAAyB,8BAA8B;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;;AAEnB;AACA,EAAE,6BAA6B;AAC/B;;AAEA,4BAA4B,gDAAgD;AAC5E,6GAAwD,OAAO;AAC/D,uBAAuB,yDAAyD;AAChF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,2BAA2B;AACjD,iBAAiB,sBAAsB;;AAEvC;AACA,uDAAuD,KAAK;AAC5D;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,UAAU;AACtE;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ,GAAG,oBAAoB;AAC7C;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,iGAAiG;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL,QAAQ,wBAAwB;AAChC;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;;AAEN;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA,2CAA2C,oGAAwC;AACnF;AACA;AACA;AACA,SAAS,wBAAwB;AACjC,6BAA6B,8CAA8C;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yJAAgE,WAAW;AAC3E;AACA,qHAA4B,cAAc;AAC1C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+MAAiE,KAAK;;AAEtE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,8HAAqC,GAAG;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,IAAI;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,uCAAuC;AAC5D,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrZA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAE8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA,KAAK;;AAEL,YAAY;AACZ;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4FAA+B,+CAA+C,SAAS;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4FAA+B,kDAAkD,SAAS;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAyC;;AAEtE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;;;;;;;;;;;;;AC3MA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACmB;AACnB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,+EAA+E,KAAK;AACpF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sDAAsD,4BAA4B,GAAG,uBAAuB,oBAAoB,mBAAmB,cAAc,eAAe;AAChL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wJAA+D,OAAO,kBAAkB,QAAQ;;AAEhG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,OAAO;AACd;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA,+IAAsD,SAAS,gBAAgB,cAAc;AAC7F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4JAAmE,kBAAkB;;AAErF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB,OAAO,2CAA2C,cAAc;AACrH,KAAK;AACL;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;AChQA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yCAAyC,UAAU;;AAEnD,mBAAmB,UAAU;AAC7B;AACA,uBAAuB,sBAAsB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK,GAAG,cAAc;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;AC3GA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEQ;;;;;;;;;ACzCR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACTA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA,0DAA0D,iBAAiB;AAC3E;AACA;AAAA;AAAA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;;;;;;;;;AC1CA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,eAAe;AAC3D;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;ACpFA,yDAKA;AACA;;AAEA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,yBAAyB,EAAE;AACnF,wDAAwD,yBAAyB,EAAE;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,yBAAyB,EAAE;AACnF,wDAAwD,yBAAyB,EAAE;AACnF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;;AAEA;;AAEA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB;;AAEvB,kCAAkC,8BAA8B;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA,uCAAuC,mBAAmB,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B,sBAAsB,EAAE;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA,8BAA8B,eAAe,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,oCAAoC,SAAS,yBAAyB,EAAE;AACxE,oCAAoC,SAAS,6BAA6B,EAAE;AAC5E;AACA;AACA,oCAAoC,SAAS,4BAA4B,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,kBAAkB;AAClB,SAAS;AACT;AACA;AACA;AACA;AACA,kCAAkC,SAAS,+DAA+D,EAAE;AAC5G;AACA;AACA,iCAAiC,SAAS,+BAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,+CAA+C,iCAAiC,EAAE;AAClF,eAAe;AACf;AACA,eAAe;AACf,kCAAkC,KAAK,gCAAgC,UAAU;AACjF;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C,yCAAyC,2CAA2C,EAAE;AACtF,mCAAmC,aAAa,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,qBAAqB;AACrB,4CAA4C;AAC5C,qBAAqB;AACrB,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sDAAsD,MAAM;AAC5D,WAAW;AACX;AACA;AACA;AACA;AACA,sCAAsC,yBAAyB,EAAE;AACjE;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;;AAEA;AACA,cAAc;AACd;;AAEA;AACA,cAAc;AACd;;AAEA;AACA,cAAc;AACd;;AAEA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,QAAQ;;AAEjD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,oDAAoD,mBAAmB;AACvE;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA,0CAA0C,uBAAuB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,G;;;;;;;AC7+MD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;ACnCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,kBAAkB;AACnD;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA,wCAAwC;AACxC;AACA;;AAEA,iBAAiB,0DAA0D;AAC3E;AACA,OAAO,iBAAiB,KAAK,sBAAsB;AACnD;AACA,OAAO,4CAA4C;AACnD;;AAEA,eAAe,6BAA6B;AAC5C;AACA,OAAO,qCAAqC;AAC5C;;AAEA,kBAAkB,6BAA6B;AAC/C;AACA,OAAO,wCAAwC;AAC/C;;AAEA,eAAe,yBAAyB;AACxC,yBAAyB,2CAA2C;AACpE;;AAEA,iBAAiB,yBAAyB;AAC1C,yBAAyB,6CAA6C;AACtE;;AAEA,iBAAiB,mBAAmB;AACpC,yBAAyB,uCAAuC;AAChE;;AAEA,kBAAkB,yBAAyB;AAC3C,yBAAyB,8CAA8C;AACvE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+FAAwC,qCAAqC;AAC7E;;AAEA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe,GAAG,0CAA0C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;ACpHA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAC6B;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,gBAAgB;;AAE3B;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,yCAAyC,EAAE,WAAW;AACtD;AACA;AACA,SAAS,OAAO;AAChB;AACA,+BAA+B,SAAS,EAAE,eAAe;AACzD,yCAAyC,EAAE,WAAW,MAAM,EAAE,cAAc;AAC5E;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,oDAAoD,gBAAgB;AACpE;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,sFAAsF;AAC5H,OAAO,OAAO;AACd,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA,yCAAyC,4BAA4B;AACrE,2BAA2B;AAC3B;AACA;AACA;AACA,2CAA2C,UAAU,GAAG,EAAE,oBAAoB;AAC9E;AACA;AACA,KAAK;;AAEL,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,MAAM,iBAAiB;AACpD,kBAAkB,QAAQ,aAAa;AACvC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,0GAA0G;AAC1G;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,qBAAqB,IAAI,mBAAmB;AACjE;AACA;AACA;AACA,qBAAqB,eAAe,aAAa,eAAe;AAChE;AACA,yBAAyB,EAAE,UAAU,WAAW,mBAAmB;AACnE,4BAA4B,uBAAuB;AACnD;AACA;;AAEA;AACA,iBAAiB,SAAS,EAAE,oBAAoB,OAAO,eAAe;AACtE;AACA,sBAAsB,EAAE,MAAM;AAC9B,cAAc,IAAI,IAAI;AACtB;AACA;;AAEA;AACA,qBAAqB,SAAS,EAAE,eAAe;AAC/C;AACA;AACA;AACA,0BAA0B,EAAE,QAAQ,WAAW,eAAe,EAAE,QAAQ,YAAY;AACpF,kBAAkB,IAAI,QAAQ,2CAA2C,QAAQ;AACjF;AACA;AACA;AACA,+CAA+C,EAAE,QAAQ,EAAE,IAAI;AAC/D,yDAAyD,IAAI,QAAQ,EAAE,EAAE,mBAAmB;AAC5F;AACA;AACA;AACA,sBAAsB,EAAE,QAAQ,QAAQ;AACxC,cAAc,IAAI,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,wBAAwB,EAAE,SAAS,KAAK;AACxC,gBAAgB,IAAI,SAAS;AAC7B;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;AC3NA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACkC;;AAElC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AC1IA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uFAAiC,GAAG;AACpC;AACA;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACPA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC5BA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,gEAAgE;AAC5F;;AAEA;AACA;AACA,4BAA4B,oDAAoD;AAChF;;AAEA;AACA;AACA,+BAA+B,oDAAoD;AACnF;;AAEA;AACA,0BAA0B,uCAAuC;AACjE;;AAEA;AACA,4BAA4B,uCAAuC;AACnE;;AAEA;AACA,6BAA6B,yCAAyC;AACtE;;AAEA;AACA,4BAA4B,yBAAyB;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gCAAgC;AACrE;AACA;;AAEA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA;;AAEA,0CAA0C,aAAa;AACvD;AACA;AACA;;AAEA,2CAA2C,uBAAuB;AAClE;AACA;AACA;;AAEA,uCAAuC,sEAAsE;AAC7G;AACA;;AAEA,uCAAuC,qCAAqC;AAC5E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,kBAAkB;;AAE1B,uCAAuC,eAAe;;AAEtD,6CAA6C,cAAc;;AAE3D,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA,0BAA0B,qBAAqB,mCAAmC,EAAE,EAAE;AACtF,OAAO;;AAEP,gCAAgC,0BAA0B;;AAE1D,oCAAoC,iCAAiC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C,wBAAwB,uBAAuB;AAC/C,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA,qCAAqC,4BAA4B;;AAEjE,+CAA+C,yCAAyC,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,mBAAmB;AACtD;AACA,2CAA2C,cAAc,QAAQ,SAAS;AAC1E;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,cAAc,aAAa,GAAG,oBAAoB;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,YAAY;AACZ,OAAO;AACP;AACA;AACA,qCAAqC;AACrC;AACA,YAAY;AACZ,OAAO;AACP;AACA;AACA,sCAAsC;AACtC;AACA,YAAY;AACZ,OAAO;AACP;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,oBAAoB,kDAAkD,WAAW;AAC5H;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACrUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B,EAAE;AAC1D;AACA,C;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC3DA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;;AAEA,0CAA0C,8CAA8C;AACxF;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,oCAAoC,qCAAqC;AACzE,4DAA4D,eAAe;AAC3E;;AAEA,wCAAwC,iBAAiB;AACzD,oCAAoC,mCAAmC;AACvE;;AAEA,2CAA2C,iBAAiB;AAC5D,oCAAoC,sCAAsC;AAC1E;;AAEA,kCAAkC,aAAa,MAAM;AACrD,oCAAoC,aAAa;AACjD,oCAAoC,OAAO;AAC3C,qCAAqC,aAAa;;AAElD,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,mBAAmB;AAC7D,iBAAiB;AACjB,0CAA0C,cAAc;AACxD;;AAEA,8CAA8C,0BAA0B;AACxE;AACA,kDAAkD,oCAAoC;AACtF;;AAEA,2CAA2C,sBAAsB;AACjE,4KAAmF,UAAU;AAC7F;AACA,wCAAwC,GAAG,wBAAwB;AACnE;;AAEA,sCAAsC,kGAAkG;AACxI;AACA;AACA;AACA;AACA,yCAAyC,GAAG,uBAAuB;AACnE;;AAEA,4CAA4C,sBAAsB;AAClE,wGAAmD,wCAAwC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,gDAAgD,kBAAkB,qBAAqB,EAAE;AACzF;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,6BAA6B,gCAAgC;AAC7D;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,0BAA0B;AACrD;;AAEA;AACA;AACA;AACA,0CAA0C;AAC1C,+CAA+C;AAC/C,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,qDAAqD,kBAAkB;AACvE;AACA;AACA,eAAe,iCAAiC;AAChD,+BAA+B,iCAAiC;AAChE;AACA,cAAc,mBAAmB;AACjC,8BAA8B,mBAAmB;AACjD;AACA;AACA,kCAAkC,sEAAsE;AACxG;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACxCA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,uBAAuB,GAAG,oBAAoB,MAAM,qBAAqB,GAAG,kBAAkB;AAC5G;AACA;;AAEA;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;ACXA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,qBAAqB;AACrC,cAAc,mBAAmB,EAAE;AACnC,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAmB,EAAE;AACnC,kBAAkB,uBAAuB,EAAE;;AAE3C,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,sCAAsC;AACvD;AACA,qBAAqB,2DAA2D;AAChF;AACA;;AAEA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;ACrLA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uJAA8D,gBAAgB;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD,oBAAoB,yBAAyB;AAC7C,gBAAgB,qBAAqB;AACrC,cAAc,mBAAmB,EAAE;AACnC,kBAAkB,mBAAmB;AACrC,cAAc,mBAAmB,EAAE;AACnC,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C,uBAAuB,wBAAwB;AAC/C,qBAAqB,0BAA0B,EAAE;AACjD,oBAAoB,yBAAyB;AAC7C,uBAAuB,wBAAwB;;AAE/C;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAmE;AACzF;AACA;AACA,SAAS,YAAY;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA,mIAA0C,UAAU;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA,sBAAsB,iDAAiD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AC9LA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,qBAAqB;AACrC,mBAAmB,wBAAwB;AAC3C,uBAAuB,wBAAwB;AAC/C,YAAY,iBAAiB,EAAE;AAC/B,cAAc,mBAAmB;AACjC,kBAAkB,mBAAmB;AACrC,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,kBAAkB,mBAAmB;AACrC,qBAAqB,0BAA0B,EAAE,KAAK;AACtD,4BAA4B,iCAAiC,EAAE;AAC/D,iCAAiC,sCAAsC;AACvE,qBAAqB,mDAAmD;AACxE,oBAAoB,qBAAqB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kJAAyD,KAAK;;AAE9D;AACA,8HAAqC,KAAK;AAC1C;;AAEA;AACA;AACA;AACA,2DAA2D,qBAAqB,MAAM,KAAK,eAAe,kCAAkC;AAC5I;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,iDAAiD;AACzE;AACA,+BAA+B,iBAAiB;AAChD;AACA,KAAK,OAAO;AACZ,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACpPA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B,iCAAiC;AACjC,6BAA6B;AAC7B;;AAEA,gBAAgB,qBAAqB;AACrC,kBAAkB,uBAAuB;AACzC,cAAc,mBAAmB;AACjC,kBAAkB,uBAAuB;AACzC,oBAAoB,yBAAyB;AAC7C,uBAAuB,4BAA4B;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA,4BAA4B,uEAAuE;;AAEnG;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4JAAmE,OAAO;AAC1E,yBAAyB,OAAO,MAAM,uDAAuD;AAC7F;AACA,KAAK;AACL;AACA;AACA;;AAEA;;;;;;;;;AC/JA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,gCAAgC;AAChC;;AAEA;AACA,iCAAiC;AACjC,uCAAuC;AACvC,mCAAmC;AACnC;;AAEA,gBAAgB,qBAAqB;AACrC,YAAY,iBAAiB;AAC7B,cAAc,eAAe;AAC7B,mBAAmB,wBAAwB;AAC3C,4BAA4B,6BAA6B;AACzD,cAAc,mBAAmB;AACjC,kBAAkB,mBAAmB;AACrC,oBAAoB,yBAAyB;AAC7C,8BAA8B,+BAA+B;AAC7D,2BAA2B,gCAAgC;AAC3D,0BAA0B,+BAA+B;AACzD,0CAA0C,2CAA2C;AACrF,4BAA4B,kCAAkC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,QAAQ,OAAO,iDAAiD;AAC3F;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA,6BAA6B,iDAAiD,uBAAuB,gBAAgB;AACrH;AACA;AACA;AACA;;AAEA;;;;;;;;;ACpHA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa,4BAA4B;AACzC;AACA;AACA,cAAc,OAAO,gBAAgB;AACrC;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA,cAAc;AACd;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AC9HA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA,eAAe;AACf,aAAa;AACb;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW;AAC7C;AACA,aAAa;;AAEb,6BAA6B,yBAAyB;AACtD;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD,aAAa;AACb,WAAW;AACX;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AClFA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,2FAA+B,iDAAiD;AAChF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B,8BAA8B,cAAc,KAAK,iBAAiB,GAAG,YAAY,GAAG,SAAS;AAC7F;;AAEA;AACA;AACA,gBAAgB,cAAc,KAAK,iBAAiB,GAAG,YAAY,GAAG,cAAc;AACpF,cAAc,cAAc;AAC5B;AACA;;AAEA;AACA;AACA,yCAAyC,sBAAsB,EAAE;AACjE;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,QAAQ,qBAAqB;AACpC;;AAEA;;AAEA;AACA;AACA,eAAe;AACf;AACA,gBAAgB;AAChB;AACA;AACA,KAAK;;;AAGL;AACA;;AAEA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE,KAAK;AACL;;AAEA;AACA,SAAS,cAAc;AACvB,oDAAoD,cAAc;AAClE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,qDAAqD,uCAAuC;AAC5F;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAwD;AACpF,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,SAAS,cAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,iBAAiB,wDAAwD;AAChF;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/QA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,cAAc,KAAK,WAAW,IAAI,cAAc;AAChE;AACA,gBAAgB,cAAc,KAAK,WAAW;AAC9C,cAAc,cAAc;AAC5B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,aAAa;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,cAAc;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,2FAA+B,uDAAuD,iBAAiB;AACvG;;AAEA;AACA;AACA;AACA,4BAA4B,sCAAsC;AAClE,eAAe,OAAO,QAAQ;AAC9B;;AAEA;AACA,2FAA+B,wDAAwD,iBAAiB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAyC;AACnE,eAAe,OAAO,QAAQ;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,cAAc;AACvB;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA,0BAA0B,2CAA2C;AACrE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;ACxPA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,GAAG;AACpD;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,KAAK;;AAEL,YAAY;AACZ;AACA;AAAA;AAAA;;;;;;;;;;;;;;AC1CA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD,oBAAoB;AAC1E;AACA;AAAA;AAAA;;;;;;;;;;;;;AC1BA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D,KAAK;AACL;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;AChCA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,YAAY;AACZ;AACA;AAAA;AAAA;;;;;;;;;;;ACtDA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL,YAAY;AACZ;AACA;AAAA;AAAA;;;;;;;;;;;;;;ACtFA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD,oBAAoB;AAC1E;AACA;AAAA;AAAA;;;;;;;;;;;AC1BA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,YAAY;AACZ;AACA;AAAA;AAAA;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,YAAY;AACZ;AACA;AAAA;AAAA;;;;;;;;;;;AC7CA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,sDAAsD,KAAK;AAC3D;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;ACjHA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;AC9CA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA,OAAO;AACP;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;ACxCA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mDAAmD,KAAK;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL,YAAY;AACZ;AACA;AAAA;AAAA;;;;;;;;;;;ACxDA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,YAAY;AACZ;AACA;AAAA;AAAA;;;;;;;;;;AC7EA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL,YAAY;AACZ;AACA;AAAA;AAAA;;;;;;;;;;AC5CA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL,YAAY;AACZ;AACA;AAAA;AAAA;;;;;;;;;;;ACvCA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;AC1FA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA,C","file":"././lib/ArcsLib.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 41);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7841e3c274292331f8d4","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nexport default function assert(test, message) {\n  if (!test) {\n    debugger;\n    throw new Error(message);\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/platform/assert-web.js\n// module id = 0\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport assert from '../../platform/assert-web.js';\nimport {Strategizer} from '../../strategizer/strategizer.js';\nimport ConnectionConstraint from './connection-constraint.js';\nimport Particle from './particle.js';\nimport Search from './search.js';\nimport Slot from './slot.js';\nimport Handle from './handle.js';\nimport util from './util.js';\nimport digest from './digest-web.js';\n\nclass Recipe {\n  constructor() {\n    this._particles = [];\n    this._handles = [];\n    this._slots = [];\n\n    // TODO: Recipes should be collections of records that are tagged\n    // with a type. Strategies should register the record types they\n    // can handle. ConnectionConstraints should be a different record\n    // type to particles/handles.\n    this._connectionConstraints = [];\n\n    // TODO: Change to array, if needed for search strings of merged recipes.\n    this._search = null;\n  }\n\n  newConnectionConstraint(from, fromConnection, to, toConnection) {\n    this._connectionConstraints.push(new ConnectionConstraint(from, fromConnection, to, toConnection));\n  }\n\n  removeConstraint(constraint) {\n    let idx = this._connectionConstraints.indexOf(constraint);\n    assert(idx >= 0);\n    this._connectionConstraints.splice(idx, 1);\n  }\n\n  clearConnectionConstraints() {\n    this._connectionConstraints = [];\n  }\n\n  newParticle(name) {\n    let particle = new Particle(this, name);\n    this._particles.push(particle);\n    return particle;\n  }\n\n  newView() {\n    let handle = new Handle(this);\n    this._handles.push(handle);\n    return handle;\n  }\n\n  newSlot(name) {\n    let slot = new Slot(this, name);\n    this._slots.push(slot);\n    return slot;\n  }\n\n  isResolved() {\n    assert(Object.isFrozen(this), 'Recipe must be normalized to be resolved.');\n    return this._connectionConstraints.length == 0\n        && (this._search === null || this._search.isResolved())\n        && this._handles.every(handle => handle.isResolved())\n        && this._particles.every(particle => particle.isResolved())\n        && this._slots.every(slot => slot.isResolved())\n        && this.handleConnections.every(connection => connection.isResolved())\n        && this.slotConnections.every(connection => connection.isResolved());\n  }\n\n  _findDuplicateHandle() {\n    let seenHandles = new Set();\n    return this._handles.find(handle => {\n      if (handle.id) {\n        if (seenHandles.has(handle.id)) {\n          return handle;\n        }\n        seenHandles.add(handle.id);\n      }\n    });\n  }\n\n  _isValid() {\n    return !this._findDuplicateHandle() && this._handles.every(handle => handle._isValid())\n        && this._particles.every(particle => particle._isValid())\n        && this._slots.every(slot => slot._isValid())\n        && this.handleConnections.every(connection => connection._isValid())\n        && this.slotConnections.every(connection => connection._isValid())\n        && (!this.search || this.search.isValid());\n  }\n\n  get localName() { return this._localName; }\n  set localName(name) { this._localName = name; }\n  get particles() { return this._particles; } // Particle*\n  set particles(particles) { this._particles = particles; }\n  get views() { return this._handles; } // Handle*\n  set views(handles) { this._handles = handles; }\n  get slots() { return this._slots; } // Slot*\n  set slots(slots) { this._slots = slots; }\n  get connectionConstraints() { return this._connectionConstraints; }\n  get search() { return this._search; }\n  set search(search) {\n    this._search = search;\n  }\n  setSearchPhrase(phrase) {\n    assert(!this._search, 'Cannot override search phrase');\n    if (phrase) {\n      this._search = new Search(phrase);\n    }\n  }\n\n  get slotConnections() { // SlotConnection*\n    let slotConnections = [];\n    this._particles.forEach(particle => {\n      slotConnections.push(...Object.values(particle.consumedSlotConnections));\n    });\n    return slotConnections;\n  }\n\n  get handleConnections() {\n    let handleConnections = [];\n    this._particles.forEach(particle => {\n      handleConnections.push(...Object.values(particle.connections));\n      handleConnections.push(...particle._unnamedConnections);\n    });\n    return handleConnections;\n  }\n\n  isEmpty() {\n    return this.particles.length == 0 &&\n           this.views.length == 0 &&\n           this.slots.length == 0 &&\n           this._connectionConstraints.length == 0;\n  }\n\n  findView(id) {\n    for (let view of this.views) {\n      if (view.id == id)\n        return view;\n    }\n  }\n\n  findSlot(id) {\n    for (let slot of this.slots) {\n      if (slot.id == id)\n        return slot;\n    }\n  }\n\n  async digest() {\n    return digest(this.toString());\n  }\n\n  normalize() {\n    if (Object.isFrozen(this)) {\n      return;\n    }\n    if (!this._isValid()) {\n      let duplicateHandle = this._findDuplicateHandle();\n      if (duplicateHandle)\n        console.log(`Has Duplicate Handle ${duplicateHandle.id}`);\n\n      let checkForInvalid = (name, list, f) => {\n        let invalids = list.filter(item => !item._isValid());\n        if (invalids.length > 0)\n          console.log(`Has Invalid ${name} ${invalids.map(f)}`);\n      };\n      checkForInvalid('Views', this._handles, handle => `'${handle.toString()}'`);\n      checkForInvalid('Particles', this._particles, particle => particle.name);\n      checkForInvalid('Slots', this._slots, slot => slot.name);\n      checkForInvalid('HandleConnections', this.handleConnections, handleConnection => `${handleConnection.particle.name}::${handleConnection.name}`);\n      checkForInvalid('SlotConnections', this.slotConnections, slotConnection => slotConnection.name);\n      return false;\n    }\n    // Get handles and particles ready to sort connections.\n    for (let particle of this._particles) {\n      particle._startNormalize();\n    }\n    for (let handle of this._handles) {\n      handle._startNormalize();\n    }\n    for (let slot of this._slots) {\n      slot._startNormalize();\n    }\n\n    // Sort and normalize handle connections.\n    let connections = this.handleConnections;\n    for (let connection of connections) {\n      connection._normalize();\n    }\n    connections.sort(util.compareComparables);\n\n    // Sort and normalize slot connections.\n    let slotConnections = this.slotConnections;\n    for (let slotConnection of slotConnections) {\n      slotConnection._normalize();\n    }\n    slotConnections.sort(util.compareComparables);\n\n    if (this.search) {\n      this.search._normalize();\n    }\n\n    // Finish normalizing particles and handles with sorted connections.\n    for (let particle of this._particles) {\n      particle._finishNormalize();\n    }\n    for (let handle of this._handles) {\n      handle._finishNormalize();\n    }\n    for (let slot of this._slots) {\n      slot._finishNormalize();\n    }\n\n    let seenHandles = new Set();\n    let seenParticles = new Set();\n    let particles = [];\n    let handles = [];\n    // Reorder connections so that interfaces come last.\n    // TODO: update handle-connection comparison method instead?\n    for (let connection of connections.filter(c => !c.type || !c.type.isInterface).concat(connections.filter(c => !!c.type && !!c.type.isInterface))) {\n      if (!seenParticles.has(connection.particle)) {\n        particles.push(connection.particle);\n        seenParticles.add(connection.particle);\n      }\n      if (connection.view && !seenHandles.has(connection.view)) {\n        handles.push(connection.view);\n        seenHandles.add(connection.view);\n      }\n    }\n\n    let orphanedHandles = this._handles.filter(handle => !seenHandles.has(handle));\n    orphanedHandles.sort(util.compareComparables);\n    handles.push(...orphanedHandles);\n\n    let orphanedParticles = this._particles.filter(particle => !seenParticles.has(particle));\n    orphanedParticles.sort(util.compareComparables);\n    particles.push(...orphanedParticles);\n\n    // TODO: redo slots as above.\n    let seenSlots = new Set();\n    let slots = [];\n    for (let slotConnection of slotConnections) {\n      if (slotConnection.targetSlot && !seenSlots.has(slotConnection.targetSlot)) {\n        slots.push(slotConnection.targetSlot);\n        seenSlots.add(slotConnection.targetSlot);\n      }\n      Object.values(slotConnection.providedSlots).forEach(ps => {\n        if (!seenSlots.has(ps)) {\n          slots.push(ps);\n          seenSlots.add(ps);\n        }\n      });\n    }\n\n    // Put particles and handles in their final ordering.\n    this._particles = particles;\n    this._handles = handles;\n    this._slots = slots;\n    this._connectionConstraints.sort(util.compareComparables);\n\n    Object.freeze(this._particles);\n    Object.freeze(this._handles);\n    Object.freeze(this._slots);\n    Object.freeze(this._connectionConstraints);\n    Object.freeze(this);\n\n    return true;\n  }\n\n  clone(cloneMap) {\n    // for now, just copy everything\n\n    let recipe = new Recipe();\n\n    if (cloneMap == undefined)\n      cloneMap = new Map();\n\n    this._copyInto(recipe, cloneMap);\n\n    // TODO: figure out a better approach than stashing the cloneMap permanently\n    // on the recipe\n    recipe._cloneMap = cloneMap;\n\n    return recipe;\n  }\n\n  mergeInto(recipe) {\n    let cloneMap = new Map();\n    let numHandles = recipe._handles.length;\n    let numParticles = recipe._particles.length;\n    let numSlots = recipe._slots.length;\n    this._copyInto(recipe, cloneMap);\n    return {\n      views: recipe._handles.slice(numHandles),\n      particles: recipe._particles.slice(numParticles),\n      slots: recipe._slots.slice(numSlots)\n    };\n  }\n\n  _copyInto(recipe, cloneMap) {\n    function cloneTheThing(object) {\n      let clonedObject = object._copyInto(recipe, cloneMap);\n      cloneMap.set(object, clonedObject);\n    }\n\n    this._handles.forEach(cloneTheThing);\n    this._particles.forEach(cloneTheThing);\n    this._slots.forEach(cloneTheThing);\n    this._connectionConstraints.forEach(cloneTheThing);\n    if (this.search) {\n      this.search._copyInto(recipe);\n    }\n  }\n\n  updateToClone(dict) {\n    let result = {};\n    Object.keys(dict).forEach(key => result[key] = this._cloneMap.get(dict[key]));\n    return result;\n  }\n\n  static over(results, walker, strategy) {\n    return Strategizer.over(results, walker, strategy);\n  }\n\n  _makeLocalNameMap() {\n    let names = new Set();\n    for (let particle of this.particles) {\n      names.add(particle.localName);\n    }\n    for (let view of this.views) {\n      names.add(view.localName);\n    }\n    for (let slot of this.slots) {\n      names.add(slot.localName);\n    }\n\n    let nameMap = new Map();\n    let i = 0;\n    for (let particle of this.particles) {\n      let localName = particle.localName;\n      if (!localName) {\n        do {\n          localName = `particle${i++}`;\n        } while (names.has(localName));\n      }\n      nameMap.set(particle, localName);\n    }\n\n    i = 0;\n    for (let view of this.views) {\n      let localName = view.localName;\n      if (!localName) {\n        do {\n          localName = `view${i++}`;\n        } while (names.has(localName));\n      }\n      nameMap.set(view, localName);\n    }\n\n    i = 0;\n    for (let slot of this.slots) {\n      let localName = slot.localName;\n      if (!localName) {\n        do {\n          localName = `slot${i++}`;\n        } while (names.has(localName));\n      }\n      nameMap.set(slot, localName);\n    }\n\n    return nameMap;\n  }\n\n  // TODO: Add a normalize() which strips local names and puts and nested\n  //       lists into a normal ordering.\n\n  toString(options) {\n    let nameMap = this._makeLocalNameMap();\n    let result = [];\n    // TODO: figure out where recipe names come from\n    result.push(`recipe`);\n    if (this.search) {\n      result.push(this.search.toString(options).replace(/^|(\\n)/g, '$1  '));\n    }\n    for (let constraint of this._connectionConstraints) {\n      let constraintStr = constraint.toString().replace(/^|(\\n)/g, '$1  ');\n      if (options && options.showUnresolved) {\n        constraintStr = constraintStr.concat(' // unresolved connection-constraint');\n      }\n      result.push(constraintStr);\n    }\n    for (let view of this.views) {\n      result.push(view.toString(nameMap, options).replace(/^|(\\n)/g, '$1  '));\n    }\n    for (let slot of this.slots) {\n      let slotString = slot.toString(nameMap, options);\n      if (slotString) {\n        result.push(slotString.replace(/^|(\\n)/g, '$1  '));\n      }\n    }\n    for (let particle of this.particles) {\n      result.push(particle.toString(nameMap, options).replace(/^|(\\n)/g, '$1  '));\n    }\n    return result.join('\\n');\n  }\n}\n\nexport default Recipe;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/recipe.js\n// module id = 1\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport assert from '../platform/assert-web.js';\n\nexport class Strategizer {\n  constructor(strategies, evaluators, {maxPopulation, generationSize, discardSize}) {\n    this._strategies = strategies;\n    this._evaluators = evaluators;\n    this._generation = 0;\n    this._internalPopulation = [];\n    this._population = [];\n    this._generated = [];\n    this._terminal = [];\n    this._options = {\n      maxPopulation,\n      generationSize,\n      discardSize,\n    };\n    this.populationHash = new Map();\n  }\n  // Latest generation number.\n  get generation() {\n    return this._generation;\n  }\n  // All individuals in the current population.\n  get population() {\n    return this._population;\n  }\n  // Individuals of the latest generation.\n  get generated() {\n    return this._generated;\n  }\n  // Individuals that were discarded in the latest generation.\n  get discarded() {\n    return this._discarded;\n    // TODO: Do we need this?\n  }\n  // Individuals from the previous generation that were not decended from in the\n  // current generation.\n  get terminal() {\n    assert(this._terminal);\n    return this._terminal;\n  }\n  async generate() {\n    // Generate\n    let generation = this.generation + 1;\n    let individualsPerStrategy = Math.floor(this._options.generationSize / this._strategies.length);\n    let generated = await Promise.all(this._strategies.map(strategy => {\n      return strategy.generate(this, individualsPerStrategy);\n    }));\n\n    let record = {};\n    record.generation = generation;\n    record.sizeOfLastGeneration = this.generated.length;\n    record.outputSizesOfStrategies = {};\n    for (let i = 0; i < this._strategies.length; i++) {\n      record.outputSizesOfStrategies[this._strategies[i].constructor.name] = generated[i].results.length;\n    }\n\n    generated = generated.map(({results}) => results);\n    generated = [].concat(...generated);\n\n    // TODO: get rid of this additional asynchrony\n    generated = await Promise.all(generated.map(async result => {\n      if (result.hash) result.hash = await result.hash;\n      return result;\n    }));\n\n    record.rawGenerated = generated.length;\n    record.nullDerivations = 0;\n    record.invalidDerivations = 0;\n    record.duplicateDerivations = 0;\n    record.nullDerivationsByStrategy = {};\n    record.duplicateDerivationsByStrategy = {};\n    record.invalidDerivationsByStrategy = {};\n\n    generated = generated.filter(result => {\n      let strategy = result.derivation[0].strategy.constructor.name;\n      if (result.hash) {\n        let existingResult = this.populationHash.get(result.hash);\n        if (existingResult) {\n          if (result.derivation[0].parent == existingResult) {\n            record.nullDerivations += 1;\n            if (record.nullDerivationsByStrategy[strategy] == undefined)\n              record.nullDerivationsByStrategy[strategy] = 0;\n            record.nullDerivationsByStrategy[strategy]++;\n          } else if (existingResult.derivation.map(a => a.parent).indexOf(result.derivation[0].parent) != -1) {\n            record.duplicateDerivations += 1;\n            if (record.duplicateDerivationsByStrategy[strategy] == undefined)\n              record.duplicateDerivationsByStrategy[strategy] = 0;\n            record.duplicateDerivationsByStrategy[strategy]++;\n          } else {\n            this.populationHash.get(result.hash).derivation.push(result.derivation[0]);\n          }\n          return false;\n        }\n        this.populationHash.set(result.hash, result);\n      }\n      if (result.valid === false) {\n        record.invalidDerivations++;\n        record.invalidDerivationsByStrategy[strategy] = (record.duplicateDerivationsByStrategy[strategy] || 0) + 1;\n        return false;\n      }\n      return true;\n    });\n\n    let terminal = new Map();\n    for (let candidate of this.generated) {\n      terminal.set(candidate.result, candidate);\n    }\n    for (let result of generated) {\n      for (let {parent} of result.derivation) {\n        if (parent && terminal.has(parent.result)) {\n          terminal.delete(parent.result);\n        }\n      }\n    }\n    terminal = [...terminal.values()];\n\n    record.totalGenerated = generated.length;\n\n    generated.sort((a, b) => {\n      if (a.score > b.score)\n        return -1;\n      if (a.score < b.score)\n        return 1;\n      return 0;\n    });\n\n    // Evalute\n    let evaluations = await Promise.all(this._evaluators.map(strategy => {\n      return strategy.evaluate(this, generated);\n    }));\n    let fitness = Strategizer._mergeEvaluations(evaluations, generated);\n    assert(fitness.length == generated.length);\n\n\n    // Merge + Discard\n    let discarded = [];\n    let newGeneration = [];\n\n    for (let i = 0; i < fitness.length; i++) {\n      newGeneration.push({\n        fitness: fitness[i],\n        individual: generated[i],\n      });\n    }\n\n    while (this._internalPopulation.length > (this._options.maxPopulation - this._options.discardSize)) {\n      discarded.push(this._internalPopulation.pop().individual);\n    }\n\n    newGeneration.sort((x, y) => y.fitness - x.fitness);\n\n    for (let i = 0; i < newGeneration.length && i < this._options.discardSize; i++) {\n      if (i < this._options.discardSize) {\n        this._internalPopulation.push(newGeneration[i]);\n      } else {\n        discarded.push(newGeneration[i].individual);\n      }\n    }\n\n    // TODO: Instead of push+sort, merge `internalPopulation` with `generated`.\n    this._internalPopulation.sort((x, y) => y.fitness - x.fitness);\n\n    for (let strategy of this._strategies) {\n      strategy.discard(discarded);\n    }\n\n    // Publish\n    this._terminal = terminal;\n    this._generation = generation;\n    this._generated = generated;\n    this._population = this._internalPopulation.map(x => x.individual);\n\n    return record;\n  }\n\n  static _mergeEvaluations(evaluations, generated) {\n    let n = generated.length;\n    let mergedEvaluations = [];\n    for (let i = 0; i < n; i++) {\n      let merged = NaN;\n      for (let evaluation of evaluations) {\n        let fitness = evaluation[i];\n        if (isNaN(fitness)) {\n          continue;\n        }\n        if (isNaN(merged)) {\n          merged = fitness;\n        } else {\n          // TODO: how should evaluations be combined?\n          merged = (merged * i + fitness) / (i + 1);\n        }\n      }\n      if (isNaN(merged)) {\n        // TODO: What should happen when there was no evaluation?\n        merged = 0.5;\n      }\n      mergedEvaluations.push(merged);\n    }\n    return mergedEvaluations;\n  }\n\n  static over(results, walker, strategy) {\n    walker.onStrategy(strategy);\n    results.forEach(result => {\n      walker.onResult(result);\n      walker.onResultDone();\n    });\n    walker.onStrategyDone();\n    return walker.descendants;\n  }\n}\n\nclass Walker {\n  constructor() {\n    this.descendants = [];\n  }\n\n  onStrategy(strategy) {\n    this.currentStrategy = strategy;\n  }\n\n  onResult(result) {\n    this.currentResult = result;\n  }\n\n  createDescendant(result, score, hash, valid) {\n    assert(this.currentResult, 'no current result');\n    assert(this.currentStrategy, 'no current strategy');\n    if (this.currentResult.score)\n      score += this.currentResult.score;\n    this.descendants.push({\n      result,\n      score,\n      derivation: [{parent: this.currentResult, strategy: this.currentStrategy}],\n      hash,\n      valid,\n    });\n  }\n\n  onResultDone() {\n    this.currentResult = undefined;\n  }\n\n  onStrategyDone() {\n    this.currentStrategy = undefined;\n  }\n}\n\nStrategizer.Walker = Walker;\n\n// TODO: Doc call convention, incl strategies are stateful.\nexport class Strategy {\n  async activate(strategizer) {\n    // Returns estimated ability to generate/evaluate.\n    // TODO: What do these numbers mean? Some sort of indication of the accuracy of the\n    // generated individuals and evaluations.\n    return {generate: 0, evaluate: 0};\n  }\n  getResults(strategizer) {\n    return strategizer.generated;\n  }\n  async generate(strategizer, n) {\n    return [];\n  }\n  discard(individuals) {\n  }\n  async evaluate(strategizer, individuals) {\n    return individuals.map(() => NaN);\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/strategizer/strategizer.js\n// module id = 2\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport Recipe from './recipe.js';\nimport WalkerBase from './walker-base.js';\n\nclass Walker extends WalkerBase {\n  onResult(result) {\n    super.onResult(result);\n    let recipe = result.result;\n    let updateList = [];\n\n    // update phase - walk through recipe and call onRecipe,\n    // onView, etc.\n\n    if (this.onRecipe) {\n      result = this.onRecipe(recipe, result);\n      if (!this.isEmptyResult(result))\n        updateList.push({continuation: result});\n    }\n    for (let particle of recipe.particles) {\n      if (this.onParticle) {\n        let result = this.onParticle(recipe, particle);\n        if (!this.isEmptyResult(result))\n          updateList.push({continuation: result, context: particle});\n      }\n    }\n    for (let handleConnection of recipe.handleConnections) {\n      if (this.onHandleConnection) {\n        let result = this.onHandleConnection(recipe, handleConnection);\n        if (!this.isEmptyResult(result))\n          updateList.push({continuation: result, context: handleConnection});\n      }\n    }\n    for (let view of recipe.views) {\n      if (this.onView) {\n        let result = this.onView(recipe, view);\n        if (!this.isEmptyResult(result))\n          updateList.push({continuation: result, context: view});\n      }\n    }\n    for (let slotConnection of recipe.slotConnections) {\n      if (this.onSlotConnection) {\n        let result = this.onSlotConnection(recipe, slotConnection);\n        if (!this.isEmptyResult(result))\n          updateList.push({continuation: result, context: slotConnection});\n      }\n    }\n    for (let slot of recipe.slots) {\n      if (this.onSlot) {\n        let result = this.onSlot(recipe, slot);\n        if (!this.isEmptyResult(result))\n          updateList.push({continuation: result, context: slot});\n      }\n    }\n\n    this._runUpdateList(recipe, updateList);\n  }\n}\n\nWalker.Permuted = WalkerBase.Permuted;\nWalker.Independent = WalkerBase.Independent;\n\nexport default Walker;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/walker.js\n// module id = 3\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\n\nimport assert from '../platform/assert-web.js';\n\nlet nextVariableId = 0;\n\nfunction addType(name, arg) {\n  let lowerName = name[0].toLowerCase() + name.substring(1);\n  Object.defineProperty(Type, `new${name}`, {\n    value: function(arg) {\n      return new Type(name, arg);\n    }});\n  let upperArg = arg ? arg[0].toUpperCase() + arg.substring(1) : '';\n  Object.defineProperty(Type.prototype, `${lowerName}${upperArg}`, {\n    get: function() {\n      assert(this[`is${name}`], `{${this.tag}, ${this.data}} is not of type ${name}`);\n      return this.data;\n    }});\n  Object.defineProperty(Type.prototype, `is${name}`, {\n    get: function() {\n      return this.tag == name;\n    }});\n}\n\nclass Type {\n  constructor(tag, data) {\n    assert(typeof tag == 'string');\n    assert(data);\n    if (tag == 'Entity') {\n      assert(data instanceof Schema);\n    }\n    if (tag == 'SetView') {\n      if (!(data instanceof Type) && data.tag && data.data) {\n        data = new Type(data.tag, data.data);\n      }\n    }\n    this.tag = tag;\n    this.data = data;\n  }\n\n  static newView(type) {\n    console.warn('Type.newView is deprecated. Please use Type.newSetView instead');\n    return Type.newSetView(type);\n  }\n\n  get isView() {\n    console.warn('Type.isView is deprecated. Please use Type.isSetView instead');\n    return this.isSetView;\n  }\n\n  get viewType() {\n    console.warn('Type.viewType is deprecated. Please use Type.setViewType isntead');\n    return this.setViewType;\n  }\n\n  viewOf() {\n    console.warn('Type.viewOf is deprecated. Please use Type.setViewOf instead');\n    return this.setViewOf();\n  }\n\n  get manifestReferenceName() {\n    console.warn('Type.manifestReferenceName is deprecated. Please use Type.manifestReference instead');\n    return this.manifestReference;\n  }\n\n  get variableReferenceName() {\n    console.warn('Type.variableReferenceName is deprecated. Please use Type.variableReference instead');\n    return this.variableReference;\n  }\n\n  get variableVariable() {\n    console.warn('Type.variableVariable is deprecated. Please use Type.variable instead');\n    return this.variable;\n  }\n\n  // Replaces variableReference types with variable types .\n  assignVariableIds(variableMap) {\n    if (this.isVariableReference) {\n      let name = this.data;\n      let sharedVariable = variableMap.get(name);\n      if (sharedVariable == undefined) {\n        let id = nextVariableId++;\n        sharedVariable = new TypeVariable(name, id);\n        variableMap.set(name, sharedVariable);\n      }\n      return Type.newVariable(sharedVariable);\n    }\n\n    if (this.isSetView) {\n      return this.primitiveType().assignVariableIds(variableMap).setViewOf();\n    }\n\n    if (this.isInterface) {\n      let shape = this.interfaceShape.clone();\n      shape._typeVars.map(({object, field}) => object[field] = object[field].assignVariableIds(variableMap));\n      return Type.newInterface(shape);\n    }\n\n    return this;\n  }\n\n  // Replaces manifestReference types with resolved schemas.\n  resolveReferences(resolve) {\n    if (this.isManifestReference) {\n      let resolved = resolve(this.data);\n      if (resolved.schema) {\n        return Type.newEntity(resolved.schema);\n      } else if (resolved.shape) {\n        return Type.newInterface(resolved.shape);\n      } else {\n        throw new Error('Expected {shape} or {schema}');\n      }\n    }\n\n    if (this.isSetView) {\n      return this.primitiveType().resolveReferences(resolve).setViewOf();\n    }\n\n    return this;\n  }\n\n  static unwrapPair(type1, type2) {\n    assert(type1 instanceof Type);\n    assert(type2 instanceof Type);\n    if (type1.tag != type2.tag) {\n      return null;\n    }\n    if (type1.isEntity || type1.isInterface || type1.isVariableReference || type1.isManifestReference) {\n      return [type1, type2];\n    }\n    return Type.unwrapPair(type1.data, type2.data);\n  }\n\n  equals(type) {\n    if (this.tag !== type.tag)\n      return false;\n    if (this.tag == 'Entity') {\n      return this.data.equals(type.data);\n    }\n    if (this.isSetView) {\n      return this.data.equals(type.data);\n    }\n    if (this.isInterface) {\n      return this.data.equals(type.data);\n    }\n    if (this.isVariable) {\n      return this.data.equals(type.data);\n    }\n    // TODO: this doesn't always work with the way the parser keeps kind\n    // information around\n    return JSON.stringify(this.data) == JSON.stringify(type.data);\n  }\n\n  get isValid() {\n    return !this.variableReference;\n  }\n\n  primitiveType() {\n    let type = this.setViewType;\n    return new Type(type.tag, type.data);\n  }\n\n  resolvedType() {\n    if (this.isTypeVariable && this.data.isResolved)\n      return this.data.resolution.resolvedType();\n\n    return this;\n  }\n\n  toLiteral() {\n    if (this.data.toLiteral)\n      return {tag: this.tag, data: this.data.toLiteral()};\n    return this;\n  }\n\n  static _deliteralizer(tag) {\n    switch (tag) {\n      case 'Interface':\n        return Shape.fromLiteral;\n      case 'Entity':\n        return Schema.fromLiteral;\n      case 'SetView':\n        return Type.fromLiteral;\n      case 'Tuple':\n        return TupleFields.fromLiteral;\n      default:\n        return a => a;\n    }\n  }\n\n  static fromLiteral(literal) {\n    return new Type(literal.tag, Type._deliteralizer(literal.tag)(literal.data));\n  }\n\n  setViewOf() {\n    return Type.newSetView(this);\n  }\n\n  hasProperty(property) {\n    if (property(this))\n      return true;\n    if (this.isSetView)\n      return this.setViewType.hasProperty(property);\n    return false;\n  }\n\n  toString() {\n    if (this.isSetView)\n      return `[${this.primitiveType().toString()}]`;\n    if (this.isEntity)\n      return this.entitySchema.name;\n    if (this.isInterface)\n      return 'Interface';\n    if (this.isTuple)\n      return this.tupleFields.toString();\n    assert('Add support to serializing type:', this);\n  }\n\n  toPrettyString() {\n    if (this.isRelation)\n      return JSON.stringify(this.data);\n    if (this.isSetView) {\n      return `${this.primitiveType().toPrettyString()} List`;\n    }\n    if (this.isVariable)\n      return `[${this.variableName}]`;\n    if (this.isVariableReference)\n      return `[${this.variableReferenceName}]`;\n    if (this.isEntity) {\n      // Spit MyTypeFOO to My Type FOO\n      if (this.entitySchema.name) {\n        return this.entitySchema.name.replace(/([^A-Z])([A-Z])/g, '$1 $2').replace(/([A-Z][^A-Z])/g, ' $1').trim();\n      } \n      return JSON.stringify(this.entitySchema._model);\n    }\n    if (this.isTuple)\n      return this.tupleFields.toString();\n    if (this.isManifestReference)\n      return this.manifestReferenceName;\n    if (this.isInterface)\n      return this.interfaceShape.toPrettyString();\n  }\n}\n\naddType('ManifestReference');\naddType('Entity', 'schema');\naddType('VariableReference');\naddType('Variable');\naddType('SetView', 'type');\naddType('Relation', 'entities');\naddType('Interface', 'shape');\naddType('Tuple', 'fields');\n\nexport default Type;\n\nimport Shape from './shape.js';\nimport Schema from './schema.js';\nimport TypeVariable from './type-variable.js';\nimport TupleFields from './tuple-fields.js';\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/type.js\n// module id = 4\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\nimport assert from '../../platform/assert-web.js';\n\nfunction compareNulls(o1, o2) {\n  if (o1 == o2) return 0;\n  if (o1 == null) return -1;\n  return 1;\n}\nfunction compareStrings(s1, s2) {\n  if (s1 == null || s2 == null) return compareNulls(s1, s2);\n  return s1.localeCompare(s2);\n}\nfunction compareNumbers(n1, n2) {\n  if (n1 == null || n2 == null) return compareNulls(n1, n2);\n  return n1 - n2;\n}\nfunction compareBools(b1, b2) {\n  if (b1 == null || b2 == null) return compareNulls(b1, b2);\n  return b1 - b2;\n}\nfunction compareArrays(a1, a2, compare) {\n  assert(a1 != null);\n  assert(a2 != null);\n  if (a1.length != a2.length) return compareNumbers(a1.length, a2.length);\n  for (let i = 0; i < a1.length; i++) {\n    let result;\n    if ((result = compare(a1[i], a2[i])) != 0) return result;\n  }\n  return 0;\n}\nfunction compareObjects(o1, o2, compare) {\n  let keys = Object.keys(o1);\n  let result;\n  if ((result = compareNumbers(keys.length, Object.keys(o2).length)) != 0) return result;\n  for (let key of keys) {\n    if ((result = compare(o1[key], o2[key])) != 0) return result;\n  }\n  return 0;\n}\nfunction compareComparables(o1, o2) {\n  if (o1 == null || o2 == null) return compareNulls(o1, o2);\n  return o1._compareTo(o2);\n}\n\nexport default {\n  compareNulls,\n  compareStrings,\n  compareNumbers,\n  compareBools,\n  compareArrays,\n  compareObjects,\n  compareComparables,\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/util.js\n// module id = 5\n// module chunks = 0","/*\n  Copyright 2015 Google Inc. All Rights Reserved.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n      http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport fs from '../platform/fs-web.js';\n\nlet events = [];\nlet pid;\nlet now;\nif (typeof document == 'object') {\n  pid = 42;\n  now = function() {\n    let t = performance.now();\n    return t;\n  };\n} else {\n  pid = process.pid;\n  now = function() {\n    let t = process.hrtime();\n    return t[0] * 1000000 + t[1] / 1000;\n  };\n}\n\nlet flowId = 0;\n\nfunction parseInfo(info) {\n  if (!info)\n    return {};\n  if (typeof info == 'function')\n    return parseInfo(info());\n  if (info.toTraceInfo)\n    return parseInfo(info.toTraceInfo());\n  return info;\n}\n\nlet module = {exports: {}};\nexport default module.exports;\nmodule.exports.enabled = false;\nmodule.exports.enable = function() {\n  module.exports.enabled = true;\n  init();\n};\n\n// TODO: Add back support for options.\n//module.exports.options = options;\n//var enabled = Boolean(options.traceFile);\n\nfunction init() {\n  let result = {\n    wait: function(f) {\n      if (f instanceof Function) {\n        return f();\n      }\n      return f;\n    },\n    resume: function() {\n      return this;\n    },\n    start: function() {\n      return this;\n    },\n    end: function() {\n      return this;\n    },\n    step: function() {\n      return this;\n    },\n    endWrap: function(fn) {\n      return fn;\n    },\n  };\n  module.exports.wrap = function(info, fn) {\n    return fn;\n  };\n  module.exports.start = function(info, fn) {\n    return result;\n  };\n  module.exports.async = function(info, fn) {\n    return result;\n  };\n  module.exports.flow = function(info, fn) {\n    return result;\n  };\n  module.exports.dump = function() {\n  };\n\n  if (!module.exports.enabled) {\n    return;\n  }\n\n  module.exports.wrap = function(info, fn) {\n    return function(...args) {\n      let t = module.exports.start(info);\n      try {\n        return fn(...args);\n      } finally {\n        t.end();\n      }\n    };\n  };\n  module.exports.start = function(info) {\n    info = parseInfo(info);\n    let args = info.args || {};\n    let begin = now();\n    return {\n      end: function(endInfo) {\n        if (endInfo && endInfo.args) {\n          Object.assign(args, endInfo.args);\n        }\n        let end = now();\n        events.push({\n          ph: 'X',\n          ts: begin,\n          dur: end - begin,\n          cat: info.cat,\n          name: info.name,\n          args: args,\n        });\n      },\n    };\n  };\n  // TODO: perhaps this should just be the only API, it acts the same as\n  //       start() when there is no call to wait/resume().\n  module.exports.async = function(info) {\n    let trace = module.exports.start(info);\n    let flow;\n    let baseInfo = {cat: info.cat, name: info.name + ' (async)'};\n    let n = 0;\n    return {\n      async wait(v) {\n        let result;\n        if (v instanceof Promise) {\n          result = f;\n        } else {\n          result = v();\n        }\n        if (!flow) {\n          flow = module.exports.flow(baseInfo).start();\n        }\n        trace.end();\n        trace = null;\n        return result;\n      },\n      resume(info) {\n        if (info) {\n          Object.assign(info, baseInfo);\n        } else {\n          info = baseInfo;\n        }\n        trace = module.exports.start(info);\n        flow.step(baseInfo);\n      },\n      end(endInfo) {\n        if (flow) {\n          flow.end();\n        }\n        trace.end(endInfo);\n      },\n    };\n  };\n  module.exports.flow = function(info) {\n    info = parseInfo(info);\n    let id = flowId++;\n    let started = false;\n    return {\n      start: function() {\n        let begin = now();\n        started = true;\n        events.push({\n          ph: 's',\n          ts: begin,\n          cat: info.cat,\n          name: info.name,\n          args: info.args,\n          id: id,\n        });\n        return this;\n      },\n      end: function(endInfo) {\n        if (!started) return;\n        let end = now();\n        endInfo = parseInfo(endInfo);\n        events.push({\n          ph: 'f',\n          bp: 'e', // binding point is enclosing slice.\n          ts: end,\n          cat: info.cat,\n          name: info.name,\n          args: endInfo && endInfo.args,\n          id: id,\n        });\n        return this;\n      },\n      step: function(stepInfo) {\n        if (!started) return;\n        let step = now();\n        stepInfo = parseInfo(stepInfo);\n        events.push({\n          ph: 't',\n          ts: step,\n          cat: info.cat,\n          name: info.name,\n          args: stepInfo && stepInfo.args,\n          id: id,\n        });\n        return this;\n      },\n    };\n  };\n  module.exports.save = function() {\n    events.forEach(function(event) {\n      event.pid = pid;\n      event.tid = 0;\n      if (!event.args) {\n        delete event.args;\n      }\n      if (!event.cat) {\n        event.cat = '';\n      }\n    });\n    return {traceEvents: events};\n  };\n  module.exports.dump = function() {\n    fs.writeFileSync(options.traceFile, module.exports.save());\n  };\n  module.exports.download = function() {\n    let a = document.createElement('a');\n    a.download = 'trace.json';\n    a.href = 'data:text/plain;base64,' + btoa(JSON.stringify(module.exports.save()));\n    a.click();\n  };\n}\n\ninit();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/tracelib/trace.js\n// module id = 6\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport Recipe from './recipe.js';\nimport assert from '../../platform/assert-web.js';\n\nclass Shape {\n  constructor(recipe, particles, views, hcs) {\n    this.recipe = recipe;\n    this.particles = particles;\n    this.views = views;\n    this.reverse = new Map();\n    for (let p in particles)\n      this.reverse.set(particles[p], p);\n    for (let v in views)\n      this.reverse.set(views[v], v);\n    for (let hc in hcs)\n      this.reverse.set(hcs[hc], hc);\n  }\n}\n\nclass RecipeUtil {\n  static makeShape(particles, views, map, recipe) {\n    recipe = recipe || new Recipe();\n    let pMap = {};\n    let vMap = {};\n    let hcMap = {};\n    particles.forEach(particle => pMap[particle] = recipe.newParticle(particle));\n    views.forEach(view => vMap[view] = recipe.newView());\n    Object.keys(map).forEach(key => {\n      Object.keys(map[key]).forEach(name => {\n        let view = map[key][name];\n        pMap[key].addConnectionName(name).connectToView(vMap[view]);\n        hcMap[key + ':' + name] = pMap[key].connections[name];\n      });\n    });\n    return new Shape(recipe, pMap, vMap, hcMap);\n  }\n\n  static recipeToShape(recipe) {\n    let particles = {};\n    let id = 0;\n    recipe.particles.forEach(particle => particles[particle.name] = particle);\n    let views = {};\n    recipe.views.forEach(view => views['v' + id++] = view);\n    let hcs = {};\n    recipe.handleConnections.forEach(hc => hcs[hc.particle.name + ':' + hc.name] = hc);\n    return new Shape(recipe, particles, views, hcs);\n  }\n\n  static find(recipe, shape) {\n\n    function _buildNewHCMatches(recipe, shapeHC, match, outputList) {\n      let {forward, reverse, score} = match;\n      let matchFound = false;\n      for (let recipeHC of recipe.handleConnections) {\n        // TODO are there situations where multiple handleConnections should\n        // be allowed to point to the same one in the recipe?\n        if (reverse.has(recipeHC))\n          continue;\n\n        // TODO support unnamed shape particles.\n        if (recipeHC.particle.name != shapeHC.particle.name)\n          continue;\n\n        if (shapeHC.name && shapeHC.name != recipeHC.name)\n          continue;\n\n        // recipeHC is a candidate for shapeHC. shapeHC references a\n        // particle, so recipeHC must reference the matching particle,\n        // or a particle that isn't yet mapped from shape.\n        if (reverse.has(recipeHC.particle)) {\n          if (reverse.get(recipeHC.particle) != shapeHC.particle)\n            continue;\n        } else if (forward.has(shapeHC.particle)) {\n          // we've already mapped the particle referenced by shapeHC\n          // and it doesn't match recipeHC's particle as recipeHC's\n          // particle isn't mapped\n          continue;\n        }\n\n        // shapeHC doesn't necessarily reference a handle, but if it does\n        // then recipeHC needs to reference the matching handle, or one\n        // that isn't yet mapped, or no handle yet.\n        if (shapeHC.view && recipeHC.view) {\n          if (reverse.has(recipeHC.view)) {\n            if (reverse.get(recipeHC.view) != shapeHC.view)\n              continue;\n          } else if (forward.has(shapeHC.view) && forward.get(shapeHC.view) !== null) {\n            continue;\n          }\n          // Check whether shapeHC and recipeHC reference the same view.\n          // Note: the id of a view with 'copy' fate changes during recipe instantiation, hence comparing to original id too.\n          // Skip the check if views have 'create' fate (their ids are arbitrary).\n          if ((shapeHC.view.fate != 'create' || (recipeHC.view.fate != 'create' && recipeHC.view.originalFate != 'create')) &&\n              shapeHC.view.id != recipeHC.view.id && shapeHC.view.id != recipeHC.view.originalId) {\n            // this is a different view.\n            continue;\n          }\n        }\n\n        // clone forward and reverse mappings and establish new components.\n        let newMatch = {forward: new Map(forward), reverse: new Map(reverse), score};\n        assert(!newMatch.forward.has(shapeHC.particle) || newMatch.forward.get(shapeHC.particle) == recipeHC.particle);\n        newMatch.forward.set(shapeHC.particle, recipeHC.particle);\n        newMatch.reverse.set(recipeHC.particle, shapeHC.particle);\n        if (shapeHC.view) {\n          if (!recipeHC.view) {\n            if (!newMatch.forward.has(shapeHC.view)) {\n              newMatch.forward.set(shapeHC.view, null);\n              newMatch.score -= 2;\n            }\n          } else {\n            newMatch.forward.set(shapeHC.view, recipeHC.view);\n            newMatch.reverse.set(recipeHC.view, shapeHC.view);\n          }\n        }\n        newMatch.forward.set(shapeHC, recipeHC);\n        newMatch.reverse.set(recipeHC, shapeHC);\n        outputList.push(newMatch);\n        matchFound = true;\n      }\n      if (matchFound == false) {\n        let newMatches = [];\n        _buildNewParticleMatches(recipe, shapeHC.particle, match, newMatches);\n        newMatches.forEach(newMatch => {\n          if (shapeHC.view && !newMatch.forward.has(shapeHC.view)) {\n            newMatch.forward.set(shapeHC.view, null);\n            newMatch.score -= 2;\n          }\n          newMatch.forward.set(shapeHC, null);\n          newMatch.score -= 1;\n          outputList.push(newMatch);\n        });\n      }\n    }\n\n    function _buildNewParticleMatches(recipe, shapeParticle, match, newMatches) {\n      let {forward, reverse, score} = match;\n      let matchFound = false;\n      for (let recipeParticle of recipe.particles) {\n        if (reverse.has(recipeParticle))\n          continue;\n\n        if (recipeParticle.name != shapeParticle.name)\n          continue;\n        let newMatch = {forward: new Map(forward), reverse: new Map(reverse), score};\n        newMatch.forward.set(shapeParticle, recipeParticle);\n        newMatch.reverse.set(recipeParticle, shapeParticle);\n        newMatches.push(newMatch);\n        matchFound = true;\n      }\n      if (matchFound == false) {\n        let newMatch = {forward: new Map(), reverse: new Map(), score: 0};\n        forward.forEach((value, key) => newMatch.forward.set(key, value));\n        reverse.forEach((value, key) => newMatch.reverse.set(key, value));\n        if (!newMatch.forward.has(shapeParticle)) {\n          newMatch.forward.set(shapeParticle, null);\n          newMatch.score = match.score - 1;\n        }\n        newMatches.push(newMatch);\n      }\n    }\n\n    function _assignViewsToEmptyPosition(match, emptyViews, nullViews) {\n      if (emptyViews.length == 1) {\n        let matches = [];\n        let {forward, reverse, score} = match;\n        for (let nullView of nullViews) {\n          let newMatch = {forward: new Map(forward), reverse: new Map(reverse), score: score + 1};\n          newMatch.forward.set(nullView, emptyViews[0]);\n          newMatch.reverse.set(emptyViews[0], nullView);\n          matches.push(newMatch);\n        }\n        return matches;\n      }\n      let thisView = emptyViews.pop();\n      let matches = _assignViewsToEmptyPosition(match, emptyViews, nullViews);\n      let newMatches = [];\n      for (let match of matches) {\n        let nullViews = Object.values(shape.views).filter(view => match.forward.get(view) == null);\n        if (nullViews.length > 0)\n          newMatches = newMatches.concat(_assignViewsToEmptyPosition(match, [thisView], nullViews));\n        else\n          newMatches.concat(match);\n      }\n      return newMatches;\n    }\n\n    // Particles and Views are initially stored by a forward map from\n    // shape component to recipe component.\n    // View connections, particles and views are also stored by a reverse map\n    // from recipe component to shape component.\n\n    // Start with a single, empty match\n    let matches = [{forward: new Map(), reverse: new Map(), score: 0}];\n    for (let shapeHC of shape.recipe.handleConnections) {\n      let newMatches = [];\n      for (let match of matches) {\n        // collect matching view connections into a new matches list\n        _buildNewHCMatches(recipe, shapeHC, match, newMatches);\n      }\n      matches = newMatches;\n    }\n\n    for (let shapeParticle of shape.recipe.particles) {\n      if (Object.keys(shapeParticle.connections).length > 0)\n        continue;\n      if (shapeParticle.unnamedConnections.length > 0)\n        continue;\n      let newMatches = [];\n      for (let match of matches)\n        _buildNewParticleMatches(recipe, shapeParticle, match, newMatches);\n      matches = newMatches;\n    }\n\n    let emptyViews = recipe.views.filter(view => view.connections.length == 0);\n\n    if (emptyViews.length > 0) {\n      let newMatches = [];\n      for (let match of matches) {\n        let nullViews = Object.values(shape.views).filter(view => match.forward.get(view) == null);\n        if (nullViews.length > 0)\n          newMatches = newMatches.concat(_assignViewsToEmptyPosition(match, emptyViews, nullViews));\n        else\n          newMatches.concat(match);\n      }\n      matches = newMatches;\n    }\n\n    return matches.map(({forward, score}) => {\n      let match = {};\n      forward.forEach((value, key) => match[shape.reverse.get(key)] = value);\n      return {match, score};\n    });\n  }\n\n  static directionCounts(view) {\n    let counts = {'in': 0, 'out': 0, 'inout': 0, 'unknown': 0};\n    for (let connection of view.connections) {\n      let direction = connection.direction;\n      if (counts[direction] == undefined)\n        direction = 'unknown';\n      counts[direction]++;\n    }\n    counts.in += counts.inout;\n    counts.out += counts.inout;\n    return counts;\n  }\n}\n\nexport default RecipeUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/recipe-util.js\n// module id = 7\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport assert from '../platform/assert-web.js';\n\nclass Schema {\n  constructor(model) {\n    this._model = model;\n    this.name = model.name;\n    this.parents = (model.parents || []).map(parent => new Schema(parent));\n    this._normative = {};\n    this._optional = {};\n\n    assert(model.sections, `${JSON.stringify(model)} should have sections`);\n    for (let section of model.sections) {\n      let into = section.sectionType == 'normative' ? this._normative : this._optional;\n      for (let field in section.fields) {\n        // TODO normalize field types here?\n        into[field] = section.fields[field];\n      }\n    }\n  }\n\n  toLiteral() {\n    return this._model;\n  }\n\n  static fromLiteral(data) {\n    return new Schema(data);\n  }\n\n  equals(otherSchema) {\n    return this === otherSchema || (this.name == otherSchema.name\n       // TODO: Check equality without calling contains.\n       && this.contains(otherSchema)\n       && otherSchema.contains(this));\n  }\n\n  contains(otherSchema) {\n    if (!this.containsAncestry(otherSchema)) {\n      return false;\n    }\n    for (let section of ['normative', 'optional']) {\n      let thisSection = this[section];\n      let otherSection = otherSchema[section];\n      for (let field in otherSection) {\n        if (thisSection[field] != otherSection[field]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  containsAncestry(otherSchema) {\n    if (this.name == otherSchema.name || otherSchema.name == null) {\n      nextOtherParent: for (let otherParent of otherSchema.parents) {\n        for (let parent of this.parents) {\n          if (parent.containsAncestry(otherParent)) {\n            continue nextOtherParent;\n          }\n        }\n        return false;\n      }\n      return true;\n    } else {\n      for (let parent of this.parents) {\n        if (parent.containsAncestry(otherSchema)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  get type() {\n    return Type.newEntity(this);\n  }\n\n  get normative() {\n    let normative = {};\n    for (let parent of this.parents)\n      Object.assign(normative, parent.normative);\n    Object.assign(normative, this._normative);\n    return normative;\n  }\n\n  get optional() {\n    let optional = {};\n    for (let parent of this.parents)\n      Object.assign(optional, parent.optional);\n    Object.assign(optional, this._optional);\n    return optional;\n  }\n\n  entityClass() {\n    let schema = this;\n    let className = this.name;\n    let normative = this.normative;\n    let optional = this.optional;\n    let classJunk = ['toJSON', 'prototype', 'toString', 'inspect'];\n\n    let checkFieldIsValidAndGetTypes = (name, op) => {\n      let fieldType = normative[name] || optional[name];\n      switch (fieldType) {\n        case undefined:\n          throw new Error(`Can't ${op} field ${name} not in schema ${className}`);\n        case 'Number':\n          return [fieldType, 'number'];\n        case 'Boolean':\n          return [fieldType, 'boolean'];\n        case 'Object':\n          return [fieldType, 'object'];\n        default:\n          // Text, URL\n          return [fieldType, 'string'];\n      }\n    };\n\n    let clazz = class extends Entity {\n      constructor(data, userIDComponent) {\n        super(userIDComponent);\n        this.rawData = new Proxy({}, {\n          get: (target, name) => {\n            if (classJunk.includes(name))\n              return undefined;\n            if (name.constructor == Symbol)\n              return undefined;\n            let [fieldType, jsType] = checkFieldIsValidAndGetTypes(name, 'get');\n            let value = target[name];\n            assert(value == undefined || value === null || typeof(value) == jsType,\n                   `Field ${name} (type ${fieldType}) has value ${value} (type ${typeof(value)})`);\n            return value;\n          },\n          set: (target, name, value) => {\n            let [fieldType, jsType] = checkFieldIsValidAndGetTypes(name, 'set');\n            if (value !== undefined && value !== null && typeof(value) != jsType) {\n              throw new TypeError(\n                  `Can't set field ${name} (type ${fieldType}) to value ${value} (type ${typeof(value)})`);\n            }\n            target[name] = value;\n            return true;\n          }\n        });\n        for (let [name, value] of Object.entries(data)) {\n          this.rawData[name] = value;\n        }\n      }\n\n      dataClone() {\n        let clone = {};\n        for (let propertyList of [normative, optional]) {\n          Object.keys(propertyList).forEach(prop => {\n            if (this.rawData[prop] !== undefined)\n              clone[prop] = this.rawData[prop];\n          });\n        }\n        return clone;\n      }\n\n      static get key() {\n        return {\n          tag: 'entity',\n          schema: schema.toLiteral(),\n        };\n      }\n    };\n\n    Object.defineProperty(clazz, 'type', {value: this.type});\n    Object.defineProperty(clazz, 'name', {value: this.name});\n    // TODO: make a distinction between normative and optional properties.\n    // TODO: add query / getter functions for user properties\n    for (let propertyList of [normative, optional]) {\n      for (let property in propertyList) {\n        Object.defineProperty(clazz.prototype, property, {\n          get: function() {\n            return this.rawData[property];\n          },\n          set: function(v) {\n            this.rawData[property] = v;\n          }\n        });\n      }\n    }\n    return clazz;\n  }\n\n  toString() {\n    let results = [];\n    results.push(`schema ${this.name}`.concat(this.parent ? ` extends ${this.parent.name}` : ''));\n\n    let propertiesToString = (properties, keyword) => {\n      if (Object.keys(properties).length > 0) {\n        results.push(`  ${keyword}`);\n        Object.keys(properties).forEach(name => {\n          let schemaType = Array.isArray(properties[name]) && properties[name].length > 1 ? `(${properties[name].join(' or ')})` : properties[name];\n          results.push(`    ${schemaType} ${name}`);\n        });\n      }\n    };\n\n    propertiesToString(this.normative, 'normative');\n    propertiesToString(this.optional, 'optional');\n    return results.join('\\n');\n  }\n\n  toManifestString() {\n    return this.toString();\n  }\n}\n\nexport default Schema;\n\nimport Type from './type.js';\nimport Entity from './entity.js';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/schema.js\n// module id = 8\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport Type from './type.js';\nimport TypeVariable from './type-variable.js';\nimport Shape from './shape.js';\nimport assert from '../platform/assert-web.js';\n\nclass ConnectionSpec {\n  constructor(rawData, typeVarMap) {\n    this.rawData = rawData;\n    this.direction = rawData.direction;\n    this.name = rawData.name;\n    this.type = rawData.type.assignVariableIds(typeVarMap);\n    this.isOptional = rawData.isOptional;\n  }\n\n  get isInput() {\n    // TODO: we probably don't really want host to be here.\n    return this.direction == 'in' || this.direction == 'inout' || this.direction == 'host';\n  }\n\n  get isOutput() {\n    return this.direction == 'out' || this.direction == 'inout';\n  }\n}\n\nclass SlotSpec {\n  constructor(slotModel) {\n    this.name = slotModel.name;\n    this.isRequired = slotModel.isRequired;\n    this.isSet = slotModel.isSet;\n    this.formFactor = slotModel.formFactor;\n    this.providedSlots = [];\n    slotModel.providedSlots.forEach(ps => {\n      this.providedSlots.push(new ProvidedSlotSpec(ps.name, ps.isSet, ps.formFactor, ps.views));\n    });\n  }\n}\n\nclass ProvidedSlotSpec {\n  constructor(name, isSet, formFactor, views) {\n    this.name = name;\n    this.isSet = isSet;\n    this.formFactor = formFactor;\n    this.views = views;\n  }\n}\n\nclass ParticleSpec {\n  constructor(model) {\n    this._model = model;\n    this.name = model.name;\n    this.verbs = model.verbs;\n    let typeVarMap = new Map();\n    this.connections = model.args.map(a => new ConnectionSpec(a, typeVarMap));\n    this.connectionMap = new Map();\n    this.connections.forEach(a => this.connectionMap.set(a.name, a));\n    this.inputs = this.connections.filter(a => a.isInput);\n    this.outputs = this.connections.filter(a => a.isOutput);\n    this.transient = model.transient;\n\n    // initialize descriptions patterns.\n    model.description = model.description || {};\n    this.validateDescription(model.description);\n    this.pattern = model.description['pattern'];\n    this.connections.forEach(connectionSpec => {\n      connectionSpec.pattern = model.description[connectionSpec.name];\n    });\n\n    this.implFile = model.implFile;\n    this.affordance = model.affordance;\n    this.slots = new Map();\n    if (model.slots)\n      model.slots.forEach(s => this.slots.set(s.name, new SlotSpec(s)));\n    // Verify provided slots use valid view connection names.\n    this.slots.forEach(slot => {\n      slot.providedSlots.forEach(ps => {\n        ps.views.forEach(v => assert(this.connectionMap.has(v), 'Cannot provide slot for nonexistent view constraint ', v));\n      });\n    });\n  }\n\n  isInput(param) {\n    for (let input of this.inputs) if (input.name == param) return true;\n  }\n\n  isOutput(param) {\n    for (let outputs of this.outputs) if (outputs.name == param) return true;\n  }\n\n  getSlotSpec(slotName) {\n    return this.slots.get(slotName);\n  }\n\n  get primaryVerb() {\n    if (this.verbs.length > 0) {\n      return this.verbs[0];\n    }\n  }\n\n  matchAffordance(affordance) {\n    return this.slots.size <= 0 || this.affordance.includes(affordance);\n  }\n\n  toLiteral() {\n    let {args, name, verbs, transient, description, implFile, affordance, slots} = this._model;\n    args = args.map(a => {\n      let {type, direction, name, isOptional} = a;\n      type = type.toLiteral();\n      return {type, direction, name, isOptional};\n    });\n    return {args, name, verbs, transient, description, implFile, affordance, slots};\n  }\n\n  static fromLiteral(literal) {\n    let {args, name, verbs, transient, description, implFile, affordance, slots} = literal;\n    args = args.map(({type, direction, name, isOptional}) => ({type: Type.fromLiteral(type), direction, name, isOptional}));\n    return new ParticleSpec({args, name, verbs, transient, description, implFile, affordance, slots});\n  }\n\n  clone() {\n    return ParticleSpec.fromLiteral(this.toLiteral());\n  }\n\n  equals(other) {\n    return JSON.stringify(this.toLiteral()) === JSON.stringify(other.toLiteral());\n  }\n\n  validateDescription(description) {\n    Object.keys(description || []).forEach(d => {\n      assert(['kind', 'location', 'pattern'].includes(d) || this.connectionMap.has(d), `Unexpected description for ${d}`);\n    });\n  }\n\n  toInterface() {\n    return Type.newInterface(this._toShape());\n  }\n\n  _toShape() {\n    const views = this._model.args;\n    // TODO: wat do?\n    assert(!this.slots.length, 'please implement slots toShape');\n    const slots = [];\n    return new Shape(views, slots);\n  }\n\n  toString() {\n    let results = [];\n    results.push(`particle ${this.name} in '${this.implFile}'`);\n    let connRes = this.connections.map(cs => `${cs.direction} ${cs.type.toString()}${cs.isOptional ? '?' : ''} ${cs.name}`);\n    results.push(`  ${this.primaryVerb}(${connRes.join(', ')})`);\n    this.affordance.filter(a => a != 'mock').forEach(a => results.push(`  affordance ${a}`));\n    // TODO: support form factors\n    this.slots.forEach(s => {\n    results.push(`  ${s.isRequired ? 'must ' : ''}consume ${s.isSet ? 'set of ' : ''}${s.name}`);\n      s.providedSlots.forEach(ps => {\n        results.push(`    provide ${ps.isSet ? 'set of ' : ''}${ps.name}`);\n        // TODO: support form factors\n        ps.views.forEach(psv => results.push(`      view ${psv}`));\n      });\n    });\n    // Description\n    if (!!this.pattern) {\n      results.push(`  description \\`${this.pattern}\\``);\n      this.connections.forEach(cs => {\n        if (!!cs.pattern) {\n          results.push(`    ${cs.name} \\`${cs.pattern}\\``);\n        }\n      });\n    }\n    return results.join('\\n');\n  }\n\n  toManifestString() {\n    return this.toString();\n  }\n}\n\nexport default ParticleSpec;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/particle-spec.js\n// module id = 9\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport assert from '../platform/assert-web.js';\nimport Type from './type.js';\nimport ParticleSpec from './particle-spec.js';\n\nexport default class Description {\n  constructor(arc) {\n    this._arc = arc;\n    this._relevance = null;\n  }\n  get arc() { return this._arc; }\n  get relevance() { return this._relevance; }\n  set relevance(relevance) { this._relevance = relevance; }\n\n  async getArcDescription(formatterClass) {\n    let desc = await new (formatterClass || DescriptionFormatter)(this).getDescription(this._arc.activeRecipe.particles);\n    if (desc) {\n      return desc;\n    }\n  }\n\n  async getRecipeSuggestion(formatterClass) {\n    let desc = await new (formatterClass || DescriptionFormatter)(this).getDescription(this._arc.recipes[this._arc.recipes.length - 1].particles);\n    if (desc) {\n      return desc;\n    }\n\n    return this._arc.activeRecipe.name;\n  }\n\n  async getHandleDescription(recipeView) {\n    assert(recipeView.connections.length > 0, 'view has no connections?');\n\n    let formatter = new DescriptionFormatter(this);\n    formatter.excludeValues = true;\n    return await formatter.getHandleDescription(recipeView);\n  }\n}\n\nexport class DescriptionFormatter {\n  constructor(description) {\n    this._description = description;\n    this._arc = description._arc;\n    this._particleDescriptions = [];\n\n    this.seenViews = new Set();\n    this.seenParticles = new Set();\n    this.excludeValues = false;\n  }\n\n  async getDescription(particles) {\n    await this._updateDescriptionHandles(this._description);\n\n    // Choose particles, sort them by rank and generate suggestions.\n    let particlesSet = new Set(particles);\n    let selectedDescriptions = this._particleDescriptions\n      .filter(desc => (particlesSet.has(desc._particle) && this._isSelectedDescription(desc)));\n    // Prefer particles that render UI, if any.\n    if (selectedDescriptions.find(desc => (desc._particle.spec.slots.size > 0))) {\n      selectedDescriptions = selectedDescriptions.filter(desc => (desc._particle.spec.slots.size > 0));\n    }\n    selectedDescriptions = selectedDescriptions.sort(DescriptionFormatter.sort);\n\n    if (selectedDescriptions.length > 0) {\n      return this._combineSelectedDescriptions(selectedDescriptions);\n    }\n  }\n\n  _isSelectedDescription(desc) {\n    return !!desc.pattern;\n  }\n\n  async getHandleDescription(recipeView) {\n    await this._updateDescriptionHandles(this._description);\n\n    let handleConnection = this._selectHandleConnection(recipeView) || recipeView.connections[0];\n    let view = this._arc.findHandleById(recipeView.id);\n    return this._formatDescription(handleConnection, view);\n  }\n\n  async _updateDescriptionHandles(description) {\n    this._particleDescriptions = [];\n\n    // Combine all particles from direct and inner arcs.\n    let allParticles = description.arc.activeRecipe.particles;\n    // description._arc.recipes.forEach(recipe => {\n    //   let innerArcs = [...recipe.innerArcs.values()];\n    //   innerArcs.forEach(innerArc => {\n    //     innerArc.recipes.forEach(innerRecipe => {\n    //       allParticles = allParticles.concat(innerRecipe.particles);\n    //     });\n    //   });\n    // });\n\n    await Promise.all(allParticles.map(async particle => {\n      this._particleDescriptions.push(await this._createParticleDescription(particle, description.relevance));\n    }));\n  }\n\n  async _createParticleDescription(particle, relevance) {\n    let pDesc = {\n      _particle: particle,\n      _connections: {}\n    };\n    if (relevance) {\n      pDesc._rank = relevance.calcParticleRelevance(particle);\n    }\n\n    let descByName = await this._getPatternByNameFromDescriptionHandle(particle) || {};\n    pDesc = Object.assign(pDesc, this._populateParticleDescription(particle, descByName));\n    Object.values(particle.connections).forEach(viewConn => {\n      let specConn = particle.spec.connectionMap.get(viewConn.name);\n      let pattern = descByName[viewConn.name] || specConn.pattern;\n      if (pattern) {\n        let viewDescription = {pattern: pattern, _viewConn: viewConn, _view: this._arc.findHandleById(viewConn.view.id)};\n        pDesc._connections[viewConn.name] = viewDescription;\n      }\n    });\n    return pDesc;\n  }\n\n  async _getPatternByNameFromDescriptionHandle(particle) {\n    let descriptionConn = particle.connections['descriptions'];\n    if (descriptionConn && descriptionConn.view && descriptionConn.view.id) {\n      let descView = this._arc.findHandleById(descriptionConn.view.id);\n      if (descView) {\n        let descList = await descView.toList();\n        let descByName = {};\n        descList.forEach(d => descByName[d.rawData.key] = d.rawData.value);\n        return descByName;\n      }\n    }\n  }\n\n  _populateParticleDescription(particle, descriptionByName) {\n    let pattern = descriptionByName['_pattern_'] || particle.spec.pattern;\n    return pattern ? {pattern} : {};\n  }\n\n  async _combineSelectedDescriptions(selectedDescriptions) {\n    let suggestions = [];\n    await Promise.all(selectedDescriptions.map(async particle => {\n      if (!this.seenParticles.has(particle._particle)) {\n        suggestions.push(await this.patternToSuggestion(particle.pattern, particle));\n      }\n    }));\n    return this._capitalizeAndPunctuate(this._joinDescriptions(suggestions));\n  }\n\n  _joinDescriptions(strings) {\n    let nonEmptyStrings = strings.filter(str => !!str);\n    let count = nonEmptyStrings.length;\n    // Combine descriptions into a sentence:\n    // \"A.\"\n    // \"A and b.\"\n    // \"A, b, ..., and z.\" (Oxford comma ftw)\n    let delim = ['', '', ' and ', ', and '][Math.min(3, count)];\n    return nonEmptyStrings.slice(0, -1).join(', ') + delim + strings.pop();\n  }\n\n  _joinTokens(tokens) {\n    return tokens.join('');\n  }\n\n  _capitalizeAndPunctuate(sentence) {\n    // \"Capitalize, punctuate.\"\n    return sentence[0].toUpperCase() + sentence.slice(1) + '.';\n  }\n\n  async patternToSuggestion(pattern, particleDescription) {\n    let tokens = this._initTokens(pattern, particleDescription._particle);\n    let tokenPromises = tokens.map(async token => await this.tokenToString(token));\n    let tokenResults = await Promise.all(tokenPromises);\n    if (tokenResults.filter(res => res == undefined).length == 0) {\n      return this._joinTokens(tokenResults);\n    }\n  }\n\n  _initTokens(pattern, particle) {\n    pattern = pattern.replace(/</g, '&lt;');\n    let results = [];\n    while (pattern.length > 0) {\n      let tokens = pattern.match(/\\${[a-zA-Z0-9\\.]+}(?:\\.[_a-zA-Z]+)?/g);\n      let firstToken;\n      let tokenIndex;\n      if (tokens) {\n        firstToken = tokens[0];\n        tokenIndex = pattern.indexOf(firstToken);\n      } else {\n        firstToken = '';\n        tokenIndex = pattern.length;\n      }\n      assert(tokenIndex >= 0);\n      let nextToken = pattern.substring(0, tokenIndex);\n      if (nextToken.length > 0)\n        results.push({text: nextToken});\n      if (firstToken.length > 0) {\n        results.push(this._initHandleToken(firstToken, particle));\n      }\n      pattern = pattern.substring(tokenIndex + firstToken.length);\n    }\n    return results;\n  }\n\n  _initHandleToken(pattern, particle) {\n    let valueTokens = pattern.match(/\\${([a-zA-Z0-9\\.]+)}(?:\\.([_a-zA-Z]+))?/);\n    let handleNames = valueTokens[1].split('.');\n    let extra = valueTokens.length == 3 ? valueTokens[2] : undefined;\n    let valueToken;\n    let viewConn = particle.connections[handleNames[0]];\n    if (viewConn) { // view connection\n      assert(viewConn.view && viewConn.view.id, 'Missing id???');\n      return {\n        fullName: valueTokens[0],\n        viewName: viewConn.name,\n        properties: handleNames.splice(1),\n        extra,\n        _viewConn: viewConn,\n        _view: this._arc.findHandleById(viewConn.view.id)};\n    }\n\n    // slot connection\n    assert(handleNames.length == 2, 'slot connections tokens must have 2 names');\n    let providedSlotConn = particle.consumedSlotConnections[handleNames[0]].providedSlots[handleNames[1]];\n    assert(providedSlotConn, `Could not find handle ${handleNames.join('.')}`);\n    return {fullName: valueTokens[0], consumeSlotName: handleNames[0], provideSlotName: handleNames[1], extra, _providedSlotConn: providedSlotConn};\n  }\n\n  async tokenToString(token) {\n    if (token.text) {\n      return token.text;\n    }\n    if (token.viewName) {\n      return this._viewTokenToString(token);\n    } else if (token.consumeSlotName && token.provideSlotName) {\n      return this._slotTokenToString(token);\n    }\n    assert(false, 'no view or slot name');\n  }\n\n  async _viewTokenToString(token) {\n    switch (token.extra) {\n      case '_type_':\n        return token._viewConn.type.toPrettyString().toLowerCase();\n      case '_values_':\n        return this._formatViewValue(token.viewName, token._view);\n      case '_name_':\n        return this._formatDescription(token._viewConn, token._view);\n      default:\n        assert(!token.extra, `Unrecognized extra ${token.extra}`);\n\n        // Transformation's hosted particle.\n        if (token._viewConn.type.isInterface) {\n          let particleSpec = ParticleSpec.fromLiteral(await token._view.get());\n          // TODO: call this.patternToSuggestion(...) to resolved expressions in the pattern template.\n          return particleSpec.pattern;\n        }\n\n        // singleton view property.\n        if (token.properties && token.properties.length > 0) {\n          return this._propertyTokenToString(token.viewName, token._view, token.properties);\n        }\n\n        // full view description\n        let description = (await this._formatDescriptionPattern(token._viewConn)) ||\n                          this._formatViewDescription(token._viewConn, token._view);\n        let viewValue = await this._formatViewValue(token.viewName, token._view);\n        if (!description) {\n          // For singleton view, if there is no real description (the type was used), use the plain value for description.\n          if (viewValue && !token._view.type.isSetView && !this.excludeValues) {\n            return viewValue;\n          }\n        }\n\n        description = description || this._formatViewType(token._viewConn);\n        if (viewValue && !this.excludeValues && !this.seenViews.has(token._view.id)) {\n          this.seenViews.add(token._view.id);\n          return this._combineDescriptionAndValue(token, description, viewValue);\n        }\n        return description;\n    }\n  }\n\n  _combineDescriptionAndValue(token, description, viewValue) {\n    return `${description} (${viewValue})`;\n  }\n\n  async _slotTokenToString(token) {\n    switch (token.extra) {\n      case '_empty_':\n        // TODO: also return false, if the consuming particles generate an empty description.\n        return token._providedSlotConn.consumeConnections.length == 0;\n      default:\n        assert(!token.extra, `Unrecognized slot extra ${token.extra}`);\n    }\n\n    let results = (await Promise.all(token._providedSlotConn.consumeConnections.map(async consumeConn => {\n      let particle = consumeConn.particle;\n      let particleDescription = this._particleDescriptions.find(desc => desc._particle == particle);\n      this.seenParticles.add(particle);\n      return this.patternToSuggestion(particle.spec.pattern, particleDescription);\n    })));\n\n    return this._joinDescriptions(results);\n  }\n\n  async _propertyTokenToString(viewName, view, properties) {\n    assert(!view.type.isSetView, `Cannot return property ${properties.join(',')} for set-view`);\n    // Use singleton value's property (eg. \"09/15\" for person's birthday)\n    let viewVar = await view.get();\n    if (viewVar) {\n      let value = viewVar.rawData;\n      properties.forEach(p => {\n        if (value) {\n          value = value[p];\n        }\n      });\n      if (value) {\n        return this._formatEntityProperty(viewName, properties, value);\n      }\n    }\n  }\n\n  _formatEntityProperty(viewName, properties, value) {\n    return value;\n  }\n\n  async _formatViewValue(viewName, view) {\n    if (!view) {\n      return;\n    }\n    if (view.type.isSetView) {\n      let viewList = await view.toList();\n      if (viewList && viewList.length > 0) {\n        return this._formatSetView(viewName, viewList);\n      }\n    } else {\n      let viewVar = await view.get();\n      if (viewVar) {\n        return this._formatSingleton(viewName, viewVar);\n      }\n    }\n  }\n\n  _formatSetView(viewName, viewList) {\n    if (viewList[0].rawData.name) {\n      if (viewList.length > 2) {\n        return `${viewList[0].rawData.name} plus ${viewList.length-1} other items`;\n      }\n      return viewList.map(v => v.rawData.name).join(', ');\n    } else {\n      return `${viewList.length} items`;\n    }\n  }\n\n  _formatSingleton(viewName, viewVar) {\n    if (viewVar.rawData.name) {\n      return viewVar.rawData.name;\n    }\n  }\n\n  async _formatDescription(handleConnection, view) {\n    return (await this._formatDescriptionPattern(handleConnection)) ||\n           this._formatViewDescription(handleConnection, view) ||\n           this._formatViewType(handleConnection);\n  }\n\n  async _formatDescriptionPattern(handleConnection) {\n    let chosenConnection = handleConnection;\n\n    // For \"out\" connection, use its own description\n    // For \"in\" connection, use description of the highest ranked out connection with description.\n    if (!chosenConnection.spec.isOutput) {\n      let otherConnection = this._selectHandleConnection(handleConnection.view);\n      if (otherConnection) {\n        chosenConnection = otherConnection;\n      }\n    }\n\n    let chosenParticleDescription = this._particleDescriptions.find(desc => desc._particle == chosenConnection.particle);\n    let viewDescription = chosenParticleDescription ? chosenParticleDescription._connections[chosenConnection.name] : null;\n    // Add description to result array.\n    if (viewDescription) {\n      // Add the connection spec's description pattern.\n      return await this.patternToSuggestion(viewDescription.pattern, chosenParticleDescription);\n    }\n  }\n  _formatViewDescription(viewConn, view) {\n    if (view) {\n      let viewDescription = this._arc.getHandleDescription(view);\n      let viewType = this._formatViewType(viewConn);\n      // Use the view description available in the arc (if it is different than type name).\n      if (!!viewDescription && viewDescription != viewType) {\n        return viewDescription;\n      }\n    }\n  }\n  _formatViewType(handleConnection) {\n    return handleConnection.type.toPrettyString().toLowerCase();\n  }\n\n  _selectHandleConnection(recipeView) {\n    let possibleConnections = recipeView.connections.filter(connection => {\n      // Choose connections with patterns (manifest-based or dynamic).\n      let connectionSpec = connection.spec;\n      let particleDescription = this._particleDescriptions.find(desc => desc._particle == connection.particle);\n      return !!connectionSpec.pattern || !!particleDescription._connections[connection.name];\n    });\n\n    possibleConnections.sort((c1, c2) => {\n      let isOutput1 = c1.spec.isOutput;\n      let isOutput2 = c2.spec.isOutput;\n      if (isOutput1 != isOutput2) {\n        // Prefer output connections\n        return isOutput1 ? -1 : 1;\n      }\n\n      let d1 = this._particleDescriptions.find(desc => desc._particle == c1.particle);\n      let d2 = this._particleDescriptions.find(desc => desc._particle == c2.particle);\n      // Sort by particle's rank in descending order.\n      return d2._rank - d1._rank;\n    });\n\n    if (possibleConnections.length > 0) {\n      return possibleConnections[0];\n    }\n  }\n\n  static sort(p1, p2) {\n    // Root slot comes first.\n    let hasRoot1 = [...p1._particle.spec.slots.keys()].indexOf('root') >= 0;\n    let hasRoot2 = [...p2._particle.spec.slots.keys()].indexOf('root') >= 0;\n    if (hasRoot1 != hasRoot2) {\n      return hasRoot1 ? -1 : 1;\n    }\n\n    // Sort by rank\n    if (p1._rank != p2._rank) {\n      return p2._rank - p1._rank;\n    }\n\n    // Sort by number of singleton slots.\n    let p1Slots = 0, p2Slots = 0;\n    p1._particle.spec.slots.forEach((slotSpec) => { if (!slotSpec.isSet) ++p1Slots; });\n    p2._particle.spec.slots.forEach((slotSpec) => { if (!slotSpec.isSet) ++p2Slots; });\n    return p2Slots - p1Slots;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/description.js\n// module id = 10\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport assert from '../platform/assert-web.js';\nimport parser from './build/manifest-parser.js';\nimport Recipe from './recipe/recipe.js';\nimport ParticleSpec from './particle-spec.js';\nimport Schema from './schema.js';\nimport Search from './recipe/search.js';\nimport Shape from './shape.js';\nimport Type from './type.js';\nimport util from './recipe/util.js';\nimport StorageProviderFactory from './storage/storage-provider-factory.js';\nimport scheduler from './scheduler.js';\nimport ManifestMeta from './manifest-meta.js';\n\nclass Manifest {\n  constructor({id}) {\n    this._recipes = [];\n    this._imports = [];\n    // TODO: These should be lists, possibly with a separate flattened map.\n    this._particles = {};\n    this._schemas = {};\n    this._views = [];\n    this._shapes = [];\n    this._handleTags = new Map();\n    this._fileName = null;\n    this._nextLocalID = 0;\n    this._id = id;\n    this._storageProviderFactory = undefined;\n    this._scheduler = scheduler;\n    this._meta = new ManifestMeta();\n    this._resources = {};\n  }\n  get id() {\n    if (this._meta.name)\n      return this._meta.name;\n    return this._id;\n  }\n  get storageProviderFactory() {\n    if (this._storageProviderFactory == undefined)\n      this._storageProviderFactory = new StorageProviderFactory(this.id);\n    return this._storageProviderFactory;\n  }\n  get recipes() {\n    return [...new Set(this._findAll(manifest => manifest._recipes))];\n  }\n\n  get activeRecipe() {\n    return this._recipes.find(recipe => recipe.annotation == 'active');\n  }\n\n  get particles() {\n    return [...new Set(this._findAll(manifest => Object.values(manifest._particles)))];\n  }\n  get imports() {\n    return this._imports;\n  }\n  get schemas() {\n    return this._schemas;\n  }\n  get fileName() {\n    return this._fileName;\n  }\n  get views() {\n    return this._views;\n  }\n  get scheduler() {\n    return this._scheduler;\n  }\n  get shapes() {\n    return this._shapes;\n  }\n  get meta() {\n    return this._meta;\n  }\n  get resources() {\n    return this._resources;\n  }\n\n  applyMeta(section) {\n    if (this._storageProviderFactory !== undefined)\n      assert(section.name == this._meta.name || section.name == undefined, `can't change manifest ID after storage is constructed`);\n    this._meta.apply(section);\n  }\n  // TODO: newParticle, Schema, etc.\n  // TODO: simplify() / isValid().\n  async newView(type, name, id, tags) {\n    let view = await this.storageProviderFactory.construct(id, type, `in-memory://${this.id}`);\n    view.name = name;\n    this._views.push(view);\n    this._handleTags.set(view, tags ? tags : []);\n    return view;\n  }\n  _find(manifestFinder) {\n    let result = manifestFinder(this);\n    if (!result) {\n      for (let importedManifest of this._imports) {\n        result = importedManifest._find(manifestFinder);\n        if (result) {\n          break;\n        }\n      }\n    }\n    return result;\n  }\n  * _findAll(manifestFinder) {\n    yield* manifestFinder(this);\n    for (let importedManifest of this._imports) {\n      yield* importedManifest._findAll(manifestFinder);\n    }\n  }\n  findSchemaByName(name) {\n    return this._find(manifest => manifest._schemas[name]);\n  }\n  findTypeByName(name) {\n    let schema = this.findSchemaByName(name);\n    if (schema)\n      return Type.newEntity(schema);\n    let shape = this.findShapeByName(name);\n    if (shape)\n      return Type.newInterface(shape);\n    return null;\n  }\n  findParticleByName(name) {\n    return this._find(manifest => manifest._particles[name]);\n  }\n  findParticlesByVerb(verb) {\n    return [...this._findAll(manifest => Object.values(manifest._particles).filter(particle => particle.primaryVerb == verb))];\n  }\n  findViewByName(name) {\n    return this._find(manifest => manifest._views.find(view => view.name == name));\n  }\n  findHandleById(id) {\n    return this._find(manifest => manifest._views.find(view => view.id == id));\n  }\n  findHandlesByType(type, options={}) {\n    let tags = options.tags || [];\n    let subtype = options.subtype || false;\n    function typePredicate(view) {\n      if (subtype) {\n        let types = Type.unwrapPair(view.type, type);\n        if (types && types[0].isEntity) {\n          return types[0].entitySchema.contains(types[1].entitySchema);\n        }\n        return false;\n      }\n\n      return view.type.equals(type);\n    }\n    function tagPredicate(manifest, view) {\n      return tags.filter(tag => !manifest._handleTags.get(view).includes(tag)).length == 0;\n    }\n    return [...this._findAll(manifest => manifest._views.filter(view => typePredicate(view) && tagPredicate(manifest, view)))];\n  }\n  findShapeByName(name) {\n    return this._find(manifest => manifest._shapes.find(shape => shape.name == name));\n  }\n  generateID() {\n    return `${this.id}:${this._nextLocalID++}`;\n  }\n  static async load(fileName, loader, options) {\n    options = options || {};\n    let {registry, id} = options;\n    if (registry && registry[fileName]) {\n      return registry[fileName];\n    }\n    let content = await loader.loadResource(fileName);\n    assert(content !== undefined, `${fileName} unable to be loaded by Manifest parser`);\n    let manifest = await Manifest.parse(content, {\n      id,\n      fileName,\n      loader,\n      registry,\n      position: {line: 1, column: 0}\n    });\n    if (manifest && registry) {\n      registry[fileName] = manifest;\n    }\n    return manifest;\n  }\n  static async parse(content, options) {\n    options = options || {};\n    let {id, fileName, position, loader, registry} = options;\n    registry = registry || {};\n    position = position || {line: 1, column: 0};\n    id = `manifest:${fileName}:`;\n\n    function processError(e) {\n      if (!e.location) {\n        return e;\n      }\n      let lines = content.split('\\n');\n      let line = lines[e.location.start.line - 1];\n      let span = 1;\n      if (e.location.end.line == e.location.start.line) {\n        span = e.location.end.column - e.location.start.column;\n      } else {\n        span = line.length - e.location.start.column;\n      }\n      span = Math.max(1, span);\n      let highlight = '';\n      for (let i = 0; i < e.location.start.column - 1; i++) {\n        highlight += ' ';\n      }\n      for (let i = 0; i < span; i++) {\n        highlight += '^';\n      }\n      let message = `Parse error in '${fileName}' line ${e.location.start.line}.\n${e.message}\n  ${line}\n  ${highlight}`;\n      return new Error(message);\n    }\n\n    let items = [];\n    try {\n      items = parser.parse(content);\n    } catch (e) {\n      throw processError(e);\n    }\n    let manifest = new Manifest({id});\n    manifest._fileName = fileName;\n\n    for (let item of items.filter(item => item.kind == 'import')) {\n      let path = loader.path(manifest.fileName);\n      let target = loader.join(path, item.path);\n      manifest._imports.push(await Manifest.load(target, loader, {registry}));\n    }\n\n    try {\n      // processing meta sections should come first as this contains identifying \n      // information that might need to be used in other sections. For example,\n      // the meta.name, if present, becomes the manifest id which is relevant\n      // when constructing manifest views.\n      for (let meta of items.filter(item => item.kind == 'meta')) {\n        manifest.applyMeta(meta.items);\n      }\n      // similarly, resources may be referenced from other parts of the\n      // manifest.\n      for (let item of items.filter(item => item.kind == 'resource')) {\n        this._processResource(manifest, item);\n      }\n      for (let item of items.filter(item => item.kind == 'schema')) {\n        this._processSchema(manifest, item);\n      }\n      for (let item of items.filter(item => item.kind == 'shape')) {\n        this._processShape(manifest, item);\n      }\n      for (let item of items.filter(item => item.kind == 'particle')) {\n        this._processParticle(manifest, item, loader);\n      }\n      for (let item of items.filter(item => item.kind == 'view')) {\n        await this._processView(manifest, item, loader);\n      }\n      for (let item of items.filter(item => item.kind == 'recipe')) {\n        await this._processRecipe(manifest, item, loader);\n      }\n    } catch (e) {\n      throw processError(e);\n    }\n    return manifest;\n  }\n  static _processSchema(manifest, schemaItem) {\n    manifest._schemas[schemaItem.name] = new Schema({\n      name: schemaItem.name,\n      parents: schemaItem.parents.map(parent => {\n        let result = manifest.findSchemaByName(parent);\n        assert(result);\n        return result.toLiteral();\n      }),\n      sections: schemaItem.sections.map(section => {\n        let fields = {};\n        for (let field of section.fields) {\n          fields[field.name] = field.type;\n        }\n        return {\n          sectionType: section.sectionType,\n          fields,\n        };\n      }),\n    });\n  }\n  static _processResource(manifest, schemaItem) {\n    manifest._resources[schemaItem.name] = schemaItem.data;\n  }\n  static _processParticle(manifest, particleItem, loader) {\n    // TODO: we should require both of these and update failing tests...\n    assert(particleItem.implFile == null || particleItem.args !== null, 'no valid body defined for this particle');\n    if (!particleItem.args) {\n      particleItem.args = [];\n    }\n    // TODO: loader should not be optional.\n    if (particleItem.implFile && loader) {\n      particleItem.implFile = loader.join(manifest.fileName, particleItem.implFile);\n    }\n\n    for (let arg of particleItem.args) {\n      arg.type = Manifest._processType(arg.type);\n      arg.type = arg.type.resolveReferences(name => manifest.resolveReference(name));\n    }\n\n    let particleSpec = new ParticleSpec(particleItem);\n    manifest._particles[particleItem.name] = particleSpec;\n  }\n  // TODO: Move this to a generic pass over the AST and merge with resolveReference.\n  static _processType(typeItem) {\n    switch (typeItem.kind) {\n      case 'schema-inline':\n        let fields = {};\n        for (let {name, type} of typeItem.fields) {\n          fields[name] = type;\n        }\n        return Type.newEntity(new Schema({\n          name: typeItem.name,\n          parents: [],\n          sections: [{\n            sectionType: 'normative',\n            fields,\n          }],\n        }));\n      case 'variable-type':\n        return Type.newVariableReference(typeItem.name);\n      case 'reference-type':\n        return Type.newManifestReference(typeItem.name);\n      case 'list-type':\n        return Type.newSetView(Manifest._processType(typeItem.type));\n      default:\n        throw `Unexpected type item of kind '${typeItem.kind}'`;\n    }\n  }\n  static _processShape(manifest, shapeItem) {\n    for (let arg of shapeItem.interface.args) {\n      if (!!arg.type) {\n        arg.type = Manifest._processType(arg.type);\n        arg.type = arg.type.resolveReferences(name => manifest.resolveReference(name));\n      }\n    }\n    let views = shapeItem.interface.args;\n    let slots = [];\n    for (let slotItem of shapeItem.slots) {\n      slots.push({\n        direction: slotItem.direction,\n        name: slotItem.name,\n        isRequired: slotItem.isRequired,\n        isSet: slotItem.isSet\n      });\n    }\n    // TODO: move shape to recipe/ and add shape builder?\n    let shape = new Shape(views, slots);\n    shape.name = shapeItem.name;\n    manifest._shapes.push(shape);\n  }\n  static async _processRecipe(manifest, recipeItem, loader) {\n    // TODO: annotate other things too\n    let recipe = manifest._newRecipe(recipeItem.name);\n    recipe.annotation = recipeItem.annotation;\n    let items = {\n      views: recipeItem.items.filter(item => item.kind == 'view'),\n      byView: new Map(),\n      particles: recipeItem.items.filter(item => item.kind == 'particle'),\n      byParticle: new Map(),\n      slots: recipeItem.items.filter(item => item.kind == 'slot'),\n      bySlot: new Map(),\n      byName: new Map(),\n      connections: recipeItem.items.filter(item => item.kind == 'connection'),\n      search: recipeItem.items.find(item => item.kind == 'search')\n    };\n\n    for (let connection of items.connections) {\n      let fromParticle = manifest.findParticleByName(connection.from.particle);\n      let toParticle = manifest.findParticleByName(connection.to.particle);\n      if (!fromParticle) {\n        let error = new Error(`could not find particle '${connection.from.particle}'`);\n        error.location = connection.location;\n        throw error;\n      }\n      if (!toParticle) {\n        let error = new Error(`could not find particle '${connection.to.particle}'`);\n        error.location = connection.location;\n        throw error;\n      }\n      if (!fromParticle.connectionMap.has(connection.from.param)) {\n        let error = new Error(`param '${connection.from.param} is not defined by '${connection.from.particle}'`);\n        error.location = connection.location;\n        throw error;\n      }\n      if (!toParticle.connectionMap.has(connection.to.param)) {\n        let error = new Error(`param '${connection.to.param} is not defined by '${connection.to.particle}'`);\n        error.location = connection.location;\n        throw error;\n      }\n      recipe.newConnectionConstraint(fromParticle, connection.from.param,\n                                     toParticle, connection.to.param);\n    }\n\n    if (items.search) {\n      recipe.search = new Search(items.search.phrase, items.search.tokens);\n    }\n\n    for (let item of items.views) {\n      let view = recipe.newView();\n      let ref = item.ref || {tags: []};\n      if (ref.id) {\n        view.id = ref.id;\n      } else if (ref.name) {\n        let targetView = manifest.findViewByName(ref.name);\n        // TODO: Error handling.\n        assert(targetView, `Could not find view ${ref.name}`);\n        view.mapToView(targetView);\n      }\n      view.tags = ref.tags;\n      if (item.name) {\n        assert(!items.byName.has(item.name));\n        view.localName = item.name;\n        items.byName.set(item.name, {item: item, view: view});\n      }\n      view.fate = item.fate;\n      items.byView.set(view, item);\n    }\n\n    for (let item of items.slots) {\n      let slot = recipe.newSlot();\n      if (item.id) {\n        slot.id = item.id;\n      }\n      if (item.name) {\n        assert(!items.byName.has(item.name), `Duplicate slot local name ${item.name}`);\n        slot.localName = item.name;\n        items.byName.set(item.name, slot);\n      }\n      items.bySlot.set(slot, item);\n    }\n\n    // TODO: disambiguate.\n    for (let item of items.particles) {\n      let particle = recipe.newParticle(item.ref.name);\n      particle.tags = item.ref.tags;\n      particle.verbs = item.ref.verbs;\n      if (item.ref.name) {\n        let spec = manifest.findParticleByName(item.ref.name);\n        assert(spec, `could not find particle ${item.ref.name}`);\n        particle.spec = spec.clone();\n      }\n      if (item.name) {\n        // TODO: errors.\n        assert(!items.byName.has(item.name));\n        particle.localName = item.name;\n        items.byName.set(item.name, {item: item, particle: particle});\n      }\n      items.byParticle.set(particle, item);\n\n      for (let slotConnectionItem of item.slotConnections) {\n        let slotConn = particle.consumedSlotConnections[slotConnectionItem.param];\n        if (!slotConn) {\n          slotConn = particle.addSlotConnection(slotConnectionItem.param);\n        }\n        if (slotConnectionItem.name) {\n          slotConnectionItem.providedSlots.forEach(ps => {\n            let providedSlot = slotConn.providedSlots[ps.param];\n            if (providedSlot) {\n              items.byName.set(ps.name, providedSlot);\n              items.bySlot.set(providedSlot, ps);\n            } else\n              providedSlot = items.byName.get(ps.name);\n            if (!providedSlot) {\n              providedSlot = recipe.newSlot(ps.param);\n              providedSlot.localName = ps.name;\n              assert(!items.byName.has(ps.name));\n              items.byName.set(ps.name, providedSlot);\n              items.bySlot.set(providedSlot, ps);\n            }\n            if (!slotConn.providedSlots[ps.param]) {\n              slotConn.providedSlots[ps.param] = providedSlot;\n            }\n          });\n        }\n      }\n    }\n\n    for (let [particle, item] of items.byParticle) {\n      for (let connectionItem of item.connections) {\n        let connection;\n        if (connectionItem.param == '*') {\n          connection = particle.addUnnamedConnection();\n        } else {\n          connection = particle.connections[connectionItem.param];\n          if (!connection) {\n            connection = particle.addConnectionName(connectionItem.param);\n          }\n          // TODO: else, merge tags? merge directions?\n        }\n        connection.tags = connectionItem.target ? connectionItem.target.tags : [];\n        let direction = {'->': 'out', '<-': 'in', '=': 'inout'}[connectionItem.dir];\n        if (connection.direction) {\n          if (connection.direction != direction && direction != 'inout' && !(connection.direction == 'host' && direction == 'in')) {\n            let error = new Error(`'${connectionItem.dir}' not compatible with '${connection.direction}' param of '${particle.name}'`);\n            error.location = connectionItem.location;\n            throw error;\n          }\n        } else {\n          if (connectionItem.param != '*') {\n            let error = new Error(`param '${connectionItem.param}' is not defined by '${particle.name}'`);\n            error.location = connectionItem.location;\n            throw error;\n          }\n          connection.direction = direction;\n        }\n\n        let targetView;\n        let targetParticle;\n\n        if (connectionItem.target && connectionItem.target.name) {\n          let entry = items.byName.get(connectionItem.target.name);\n          if (!entry) {\n            let error = new Error(`Could not find handle '${connectionItem.target.name}'`);\n            error.location = connectionItem.location;\n            throw error;\n          }\n          if (entry.item.kind == 'view') {\n            targetView = entry.view;\n          } else if (entry.item.kind == 'particle') {\n            targetParticle = entry.particle;\n          } else {\n            assert(false, `did not expect ${entry.item.kind}`);\n          }\n        }\n\n        // Handle implicit view connections in the form `param = SomeParticle`\n        if (connectionItem.target && connectionItem.target.particle) {\n          let hostedParticle = manifest.findParticleByName(connectionItem.target.particle);\n          if (!hostedParticle) {\n            let error = new Error(`Could not find hosted particle '${connectionItem.target.particle}'`);\n            error.location = connectionItem.target.location;\n            throw error;\n          }\n          if (!connection.type.data.particleMatches(hostedParticle)) {\n            let errorType = new Error(`Hosted particle '${hostedParticle.name}' does not match shape '${connection.name}'`);\n            errorType.location = connectionItem.target.location;\n            throw errorType;\n          }\n          // TODO: Better ID.\n          let id = `${manifest._id}immediate${hostedParticle.name}`;\n          // TODO: Mark as immediate.\n          targetView = recipe.newView();\n          targetView.fate = 'map';\n          let view = await manifest.newView(connection.type, null, id, []);\n          // TODO: loader should not be optional.\n          if (hostedParticle.implFile && loader) {\n            hostedParticle.implFile = loader.join(manifest.fileName, hostedParticle.implFile);\n          }\n          view.set(hostedParticle.clone().toLiteral());\n          targetView.mapToView(view);\n        }\n\n        if (targetParticle) {\n          let targetConnection;\n          if (connectionItem.target.param) {\n            targetConnection = targetParticle.connections[connectionItem.target.param];\n            if (!targetConnection) {\n              targetConnection = targetParticle.addConnectionName(connectionItem.target.param);\n              // TODO: direction?\n            }\n          } else {\n            targetConnection = targetParticle.addUnnamedConnection();\n            // TODO: direction?\n          }\n\n          targetView = targetConnection.view;\n          if (!targetView) {\n            // TODO: tags?\n            targetView = recipe.newView();\n            targetConnection.connectToView(targetView);\n          }\n        }\n\n        if (targetView) {\n          connection.connectToView(targetView);\n        }\n      }\n\n      for (let slotConnectionItem of item.slotConnections) {\n        // Validate consumed and provided slots names are according to spec.\n        if (!particle.spec.slots.has(slotConnectionItem.param)) {\n          let error = new Error(`Consumed slot '${slotConnectionItem.param}' is not defined by '${particle.name}'`);\n          error.location = slotConnectionItem.location;\n          throw error;\n        }\n        slotConnectionItem.providedSlots.forEach(ps => {\n          if (!particle.spec.slots.get(slotConnectionItem.param).providedSlots.find(specPs => specPs.name == ps.param)) {\n            let error = new Error(`Provided slot '${ps.param}' is not defined by '${particle.name}'`);\n            error.location = ps.location;\n            throw error;\n          }\n        });\n        let targetSlot = items.byName.get(slotConnectionItem.name);\n        if (targetSlot) {\n          assert(items.bySlot.has(targetSlot));\n          if (!targetSlot.name) {\n            targetSlot.name = slotConnectionItem.param;\n          }\n          assert(targetSlot.name == slotConnectionItem.param,\n                 `Target slot name ${targetSlot.name} doesn't match slot connection name ${slotConnectionItem.param}`);\n        } else {\n          targetSlot = recipe.newSlot(slotConnectionItem.param);\n          targetSlot.localName = slotConnectionItem.name;\n          if (slotConnectionItem.name)\n            items.byName.set(slotConnectionItem.name, targetSlot);\n          items.bySlot.set(targetSlot, slotConnectionItem);\n        }\n        particle.consumedSlotConnections[slotConnectionItem.param].connectToSlot(targetSlot);\n      }\n    }\n  }\n  resolveReference(name) {\n    let schema = this.findSchemaByName(name);\n    if (schema) {\n      return {schema};\n    }\n    let shape = this.findShapeByName(name);\n    if (shape) {\n      return {shape};\n    }\n    throw new Error(`Schema or Shape '${name}' was not declared or imported`);\n  }\n  static async _processView(manifest, item, loader) {\n    let name = item.name;\n    let id = item.id;\n    let type = Manifest._processType(item.type);\n    if (id == null) {\n      id = `${manifest._id}view${manifest._views.length}`;\n    }\n    let tags = item.tags;\n    if (tags == null)\n      tags = [];\n\n    type = type.resolveReferences(name => manifest.resolveReference(name));\n\n    let view = await manifest.newView(type, name, id, tags);\n    view.source = item.source;\n    view.description = item.description;\n    // TODO: How to set the version?\n    // view.version = item.version;\n    let json;\n    if (item.origin == 'file') {\n      let source = loader.join(manifest.fileName, item.source);\n      // TODO: json5?\n      json = await loader.loadResource(source);\n    } else if (item.origin == 'resource') {\n      json = manifest.resources[item.source];\n    }\n    let entities = JSON.parse(json);\n    for (let entity of entities) {\n      let id = entity.$id || manifest.generateID();\n      delete entity.$id;\n      if (type.isSetView) {\n        view.store({\n          id,\n          rawData: entity,\n        });\n      } else {\n        view.set({\n          id,\n          rawData: entity,\n        });\n      }\n    }\n  }\n  _newRecipe(name) {\n    // TODO: use name\n    let recipe = new Recipe();\n    this._recipes.push(recipe);\n    return recipe;\n  }\n\n  toString(options) {\n    // TODO: sort?\n    options = options || {};\n    let results = [];\n\n    this._imports.forEach(i => {\n      if (options.recursive) {\n        results.push(`// import '${i.fileName}'`);\n        let importStr = i.toString(options);\n        results.push(`${i.toString(options)}`);\n      } else {\n        results.push(`import '${i.fileName}'`);\n      }\n    });\n\n    Object.values(this._schemas).forEach(s => {\n      results.push(s.toString());\n    });\n\n    Object.values(this._particles).forEach(p => {\n      results.push(p.toString());\n    });\n\n    this._recipes.forEach(r => {\n      results.push(r.toString(options));\n    });\n\n    let views = [...this.views].sort(util.compareComparables);\n    views.forEach(v => {\n      results.push(v.toString(this._handleTags.get(v)));\n    });\n\n    return results.join('\\n');\n  }\n}\n\nexport default Manifest;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/manifest.js\n// module id = 11\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\n\nimport assert from '../platform/assert-web.js';\nimport Symbols from './symbols.js';\nimport Type from './type.js';\n\nclass Entity {\n  constructor(userIDComponent) {\n    assert(!userIDComponent || userIDComponent.indexOf(':') == -1, 'user IDs must not contain the \\':\\' character');\n    this[Symbols.identifier] = undefined;\n    this._userIDComponent = userIDComponent;\n  }\n  get data() {\n    return undefined;\n  }\n\n  getUserID() {\n    return this._userIDComponent;\n  }\n\n  isIdentified() {\n    return this[Symbols.identifier] !== undefined;\n  }\n  // TODO: entity should not be exposing its IDs.\n  get id() {\n    assert(!!this.isIdentified());\n    return this[Symbols.identifier];\n  }\n  identify(identifier) {\n    assert(!this.isIdentified());\n    this[Symbols.identifier] = identifier;\n    let components = identifier.split(':');\n    if (components[components.length - 2] == 'uid')\n      this._userIDComponent = components[components.length - 1];\n  }\n  createIdentity(components) {\n    assert(!this.isIdentified());\n    let id;\n    if (this._userIDComponent)\n      id = `${components.base}:uid:${this._userIDComponent}`;\n    else\n      id = `${components.base}:${components.component()}`;\n    this[Symbols.identifier] = id;\n  }\n  toLiteral() {\n    return this.rawData;\n  }\n\n  static get type() {\n    // TODO: should the entity's key just be its type?\n    // Should it just be called type in that case?\n    return Type.newEntity(this.key.schema);\n  }\n}\n\nexport default Entity;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/entity.js\n// module id = 12\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\n\nexport default {identifier: Symbol('id')};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/symbols.js\n// module id = 13\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\n\nimport tracing from '../tracelib/trace.js';\nimport assert from '../platform/assert-web.js';\n\nclass Scheduler {\n  constructor() {\n    this.frameQueue = [];\n    this.targetMap = new Map();\n    this._finishNotifiers = [];\n    this._idle = Promise.resolve();\n    this._idleResolver = null;\n    this._idleCallback = null;\n  }\n\n  clone() {\n    return new Scheduler();\n  }\n\n  set idleCallback(idleCallback) { this._idleCallback = idleCallback; }\n\n  enqueue(view, eventRecords) {\n    let trace = tracing.flow({cat: 'view', name: 'ViewBase::_fire flow'}).start();\n    if (this.frameQueue.length == 0 && eventRecords.length > 0)\n      this._asyncProcess();\n    if (!this._idleResolver) {\n      this._idle = new Promise((resolve, reject) => this._idleResolver = resolve);\n    }\n    for (let record of eventRecords) {\n      let frame = this.targetMap.get(record.target);\n      if (frame == undefined) {\n        frame = {target: record.target, views: new Map(), traces: []};\n        this.frameQueue.push(frame);\n        this.targetMap.set(record.target, frame);\n      }\n      frame.traces.push(trace);\n      let viewEvents = frame.views.get(view);\n      if (viewEvents == undefined) {\n        viewEvents = new Map();\n        frame.views.set(view, viewEvents);\n      }\n      let kindEvents = viewEvents.get(record.kind);\n      if (kindEvents == undefined) {\n        kindEvents = [];\n        viewEvents.set(record.kind, kindEvents);\n      }\n      kindEvents.push(record);\n    }\n  }\n\n  get busy() {\n    return this.frameQueue.length > 0;\n  }\n\n  get idle() {\n    return this._idle;\n  }\n\n  _asyncProcess() {\n    Promise.resolve().then(() => {\n      assert(this.frameQueue.length > 0, '_asyncProcess should not be invoked with 0 length queue');\n      let frame = this.frameQueue.shift();\n      this.targetMap.delete(frame.target);\n      if (this.frameQueue.length > 0)\n        this._asyncProcess();\n      this._applyFrame(frame);\n      if (this.frameQueue.length == 0) {\n        this._idleResolver();\n        this._idleResolver = null;\n        if (this._idleCallback) {\n          this._idleCallback();\n        }\n      }\n    });\n  }\n\n  _applyFrame(frame) {\n    let trace = tracing.start({cat: 'scheduler', name: 'Scheduler::_applyFrame', args: {target: frame.target ? frame.target.constructor.name : 'NULL TARGET'}});\n\n    let totalRecords = 0;\n    for (let [view, kinds] of frame.views.entries()) {\n      for (let [kind, records] of kinds.entries()) {\n        let record = records[records.length - 1];\n        record.callback(record.details);\n      }\n    }\n\n    frame.traces.forEach(trace => trace.end());\n\n    trace.end();\n  }\n}\n\n// TODO: Scheduler needs to be per arc, once multi-arc support is implemented.\nexport default new Scheduler();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/scheduler.js\n// module id = 14\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport assert from '../platform/assert-web.js';\nimport {\n  Particle,\n  ViewChanges\n} from './particle.js';\n\nimport XenStateMixin from './browser/lib/xen-state.js';\n\n/** @class DomParticle\n * Particle that does stuff with DOM.\n */\nclass DomParticle extends XenStateMixin(Particle) {\n  /** @method get template()\n   * Override to return a String defining primary markup.\n   */\n  get template() {\n    return '';\n  }\n  /** @method getTemplate(slotName)\n   * Override to return a String defining primary markup for the given slot name.\n   */\n  getTemplate(slotName) {\n    // TODO: only supports a single template for now. add multiple templates support.\n    return this.template;\n  }\n  /** @method _shouldRender(props, state)\n   * Override to return false if the Particle won't use\n   * it's slot.\n   */\n  _shouldRender(props, state) {\n    return true;\n  }\n  /** @method _render(props, state)\n   * Override to return a dictionary to map into the template.\n   */\n  _render(props, state) {\n    return {};\n  }\n  /** @method _willReceiveProps(props)\n   * Override if necessary, to do things when props change.\n   */\n  _willReceiveProps(props) {\n  }\n  /** @method get config()\n   * Override if necessary, to modify superclass config.\n   */\n  get config() {\n    // TODO(sjmiles): getter that does work is a bad idea, this is temporary\n    return {\n      views: this.spec.inputs.map(i => i.name),\n      // TODO(mmandlis): this.spec needs to be replace with a particle-spec loaded from\n      // .manifest files, instead of .ptcl ones.\n      slotNames: [...this.spec.slots.values()].map(s => s.name)\n    };\n  }\n  _info() {\n    return `---------- DomParticle::[${this.spec.name}]`;\n  }\n  async setViews(views) {\n    this._views = views;\n    let config = this.config;\n    //let readableViews = config.views.filter(name => views.get(name).canRead);\n    //this.when([new ViewChanges(views, readableViews, 'change')], async () => {\n    this.when([new ViewChanges(views, config.views, 'change')], async () => {\n      await this._updateAllViews(views, config);\n    });\n    // make sure we invalidate once, even if there are no incoming views\n    this._setState({});\n  }\n  async _updateAllViews(views, config) {\n    // acquire (async) list data from views\n    let data = await Promise.all(\n      config.views\n      .map(name => views.get(name))\n      .map(view => view.toList ? view.toList() : view.get())\n    );\n    // convert view data (array) into props (dictionary)\n    let props = Object.create(null);\n    config.views.forEach((name, i) => {\n      props[name] = data[i];\n    });\n    this._setProps(props);\n  }\n  _update(props, state) {\n    if (this._shouldRender(this._props, this._state)) { // TODO: should _shouldRender be slot specific?\n      this.relevance = 1; // TODO: improve relevance signal.\n    }\n    this.config.slotNames.forEach(s => this.render(s, ['model']));\n  }\n\n  render(slotName, contentTypes) {\n    let slot = this.getSlot(slotName);\n    if (!slot) {\n      return; // didn't receive StartRender.\n    }\n    contentTypes.forEach(ct => slot._requestedContentTypes.add(ct));\n    if (this._shouldRender(this._props, this._state)) {\n      let content = {};\n      if (slot._requestedContentTypes.has('template')) {\n        content['template'] = this.getTemplate(slot.slotName);\n      }\n      if (slot._requestedContentTypes.has('model')) {\n        content['model'] = this._render(this._props, this._state);\n      }\n      slot.render(content);\n    } else if (slot.isRendered) {\n      // Send empty object, to clear rendered slot contents.\n      slot.render({});\n    }\n  }\n  fireEvent(slotName, {handler, data}) {\n    if (this[handler]) {\n      this[handler]({data}, this._state);\n    }\n  }\n  setParticleDescription(pattern) {\n    if (typeof pattern === 'string') {\n      return super.setParticleDescription(pattern);\n    }\n    assert(!!pattern.template && !!pattern.model, 'Description pattern must either be string or have template and model');\n    super.setDescriptionPattern('_template_', pattern.template);\n    super.setDescriptionPattern('_model_', JSON.stringify(pattern.model));\n  }\n}\n\nexport default DomParticle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/dom-particle.js\n// module id = 15\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport fs from '../platform/fs-web.js';\nimport vm from '../platform/vm-web.js';\nimport fetch from './fetch-web.js';\n\nimport assert from '../platform/assert-web.js';\nimport particle from './particle.js';\nimport DomParticle from './dom-particle.js';\nimport TransformationDomParticle from './transformation-dom-particle.js';\nimport JsonldToManifest from '../converters/jsonldToManifest.js';\n\nfunction schemaLocationFor(name) {\n  return `../entities/${name}.schema`;\n}\n\nclass Loader {\n  path(fileName) {\n    let path = fileName.replace(/[\\/][^\\/]+$/, '/');\n    return path;\n  }\n\n  join(prefix, path) {\n    if (/^https?:\\/\\//.test(path))\n      return path;\n    prefix = this.path(prefix);\n    return prefix + path;\n  }\n\n  loadResource(file) {\n    if (/^https?:\\/\\//.test(file))\n      return this._loadURL(file);\n    return this._loadFile(file);\n  }\n\n  _loadFile(file) {\n    return new Promise((resolve, reject) => {\n      fs.readFile(file, (err, data) => {\n        if (err)\n          reject(err);\n        else\n          resolve(data.toString('utf-8'));\n      });\n    });\n  }\n\n  _loadURL(url) {\n    if (/\\/\\/schema.org\\//.test(url)) {\n      if (url.endsWith('/Thing')) {\n        return fetch('https://schema.org/Product.jsonld').then(res => res.text()).then(data => JsonldToManifest.convert(data, {'@id': 'schema:Thing'}));\n      }\n      return fetch(url + '.jsonld').then(res => res.text()).then(data => JsonldToManifest.convert(data));\n    }\n    return fetch(url).then(res => res.text());\n  }\n\n  async loadParticleClass(spec) {\n    let clazz = await this.requireParticle(spec.implFile);\n    clazz.spec = spec;\n    return clazz;\n  }\n\n  async requireParticle(fileName) {\n    let src = await this.loadResource(fileName);\n    // Note. This is not real isolation.\n    let script = new vm.Script(src, {filename: fileName, displayErrors: true});\n    let result = [];\n    let self = {\n      defineParticle(particleWrapper) {\n        result.push(particleWrapper);\n      },\n      console,\n      importScripts: s => null //console.log(`(skipping browser-space import for [${s}])`)\n    };\n    script.runInNewContext(self, {filename: fileName, displayErrors: true});\n    assert(result.length > 0 && typeof result[0] == 'function', `Error while instantiating particle implementation from ${fileName}`);\n    return this.unwrapParticle(result[0]);\n  }\n\n  unwrapParticle(particleWrapper) {\n    return particleWrapper({particle, Particle: particle.Particle, DomParticle, TransformationDomParticle});\n  }\n\n}\n\nexport default Loader;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/loader.js\n// module id = 16\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport runtime from './runtime.js';\nimport ParticleSpec from './particle-spec.js';\nimport tracing from '../tracelib/trace.js';\nimport assert from '../platform/assert-web.js';\nimport Schema from './schema.js';\n\n/** @class Particle\n * A basic particle. For particles that provide UI, you may like to\n * instead use DOMParticle.\n */\nexport class Particle {\n  constructor(capabilities) {\n    this.spec = this.constructor.spec;\n    if (this.spec.inputs.length == 0)\n      this.extraData = true;\n    this.relevances = [];\n    this._idle = Promise.resolve();\n    this._idleResolver = null;\n    this._busy = 0;\n    this.slotHandlers = [];\n    this.stateHandlers = new Map();\n    this.states = new Map();\n    this._slotByName = new Map();\n    this.capabilities = capabilities || {};\n  }\n\n  /** @method setViews(views)\n   * This method is invoked with a handle for each view this particle\n   * is registered to interact with, once those views are ready for\n   * interaction. Override the method to register for events from\n   * the views.\n   *\n   * Views is a map from view names to view handles.\n   */\n  setViews(views) {\n\n  }\n\n  constructInnerArc() {\n    if (!this.capabilities.constructInnerArc)\n      throw new Error('This particle is not allowed to construct inner arcs');\n    return this.capabilities.constructInnerArc(this);\n  }\n\n  get busy() {\n    return this._busy > 0;\n  }\n\n  get idle() {\n    return this._idle;\n  }\n\n  /** @method setBusy()\n   * Prevents this particle from indicating that it's idle until a matching\n   * call to setIdle is made.\n   */\n  setBusy() {\n    if (this._busy == 0)\n    this._idle = new Promise((resolve, reject) => {\n      this._idleResolver = resolve;\n    });\n    this._busy++;\n  }\n\n  /** @method setIdle()\n   * Indicates that a busy period (initiated by a call to setBusy) has completed.\n   */\n  setIdle() {\n    assert(this._busy > 0);\n    this._busy--;\n    if (this._busy == 0)\n      this._idleResolver();\n  }\n\n  set relevance(r) {\n    this.relevances.push(r);\n  }\n\n  inputs() {\n    return this.spec.inputs;\n  }\n\n  outputs() {\n    return this.spec.outputs;\n  }\n\n  /** @method getSlot(name)\n   * Returns the slot with provided name.\n   */\n  getSlot(name) {\n    return this._slotByName.get(name);\n  }\n\n  addSlotHandler(f) {\n    this.slotHandlers.push(f);\n  }\n\n  addStateHandler(states, f) {\n    states.forEach(state => {\n      if (!this.stateHandlers.has(state)) {\n        this.stateHandlers.set(state, []);\n      }\n      this.stateHandlers.get(state).push(f);\n    });\n  }\n\n  emit(state, value) {\n    this.states.set(state, value);\n    this.stateHandlers.get(state).forEach(f => f(value));\n  }\n\n  /** @method on(views, names, kind, f)\n   * Convenience method for registering a callback on multiple views at once.\n   *\n   * views is a map from names to view handles\n   * names indicates the views which should have a callback installed on them\n   * kind is the kind of event that should be registered for\n   * f is the callback function\n   */\n  on(views, names, kind, f) {\n    if (typeof names == 'string')\n      names = [names];\n    let trace = tracing.start({cat: 'particle', names: this.constructor.name + '::on', args: {view: names, event: kind}});\n    names.forEach(name => views.get(name).on(kind, tracing.wrap({cat: 'particle', name: this.constructor.name, args: {view: name, event: kind}}, f), this));\n    trace.end();\n  }\n\n  when(changes, f) {\n    changes.forEach(change => change.register(this, f));\n  }\n\n  fireEvent(slotName, event) {\n    // TODO(sjmiles): tests can get here without a `this.slot`, maybe this needs to be fixed in MockSlotManager?\n    let slot = this.getSlot(slotName);\n    assert(slot, `Particle::fireEvent: slot ${slotName} is falsey`);\n    slot.fireEvent(event);\n  }\n\n  static buildManifest(strings, ...bits) {\n    let output = [];\n    for (let i = 0; i < bits.length; i++) {\n        let str = strings[i];\n        let indent = / *$/.exec(str)[0];\n        let bitStr;\n        if (typeof bits[i] == 'string')\n          bitStr = bits[i];\n        else\n          bitStr = bits[i].toManifestString();\n        bitStr = bitStr.replace(/(\\n)/g, '$1' + indent);\n        output.push(str);\n        output.push(bitStr);\n    }\n    if (strings.length > bits.length)\n      output.push(strings[strings.length - 1]);\n    return output.join('');\n  }\n\n  setParticleDescription(pattern) {\n    return this.setDescriptionPattern('_pattern_', pattern);\n  }\n  setDescriptionPattern(connectionName, pattern) {\n    let descriptions = this._views.get('descriptions');\n    if (descriptions) {\n      descriptions.store(new descriptions.entityClass({key: connectionName, value: pattern}, connectionName));\n      return true;\n    }\n    return false;\n  }\n  // TODO: Move to transformation-particle class.\n  // TODO: Don't serialize schemas, once partial schemas are in use.\n  serializeSchema(hostedParticle) {\n    let hostedConnSchemas = new Set();\n    hostedParticle.connections.forEach(conn => {\n      hostedConnSchemas.add((conn.type.isSetView ? conn.type.primitiveType() : conn.type).entitySchema.toString());\n    });\n    let schemaString =\n`${[...hostedConnSchemas].map(schema => schema.toString()).join('\\n\\r')}\n${hostedParticle.toString()}`;\n    return schemaString;\n  }\n}\n\nexport class ViewChanges {\n  constructor(views, names, type) {\n    if (typeof names == 'string')\n      names = [names];\n    this.names = names;\n    this.views = views;\n    this.type = type;\n  }\n  register(particle, f) {\n    let modelCount = 0;\n    let afterAllModels = () => { if (++modelCount == this.names.length) { f(); } };\n\n    for (let name of this.names) {\n      let view = this.views.get(name);\n      view.synchronize(this.type, afterAllModels, f, particle);\n    }\n  }\n}\n\nexport class SlotChanges {\n  constructor() {\n  }\n  register(particle, f) {\n    particle.addSlotHandler(f);\n  }\n}\n\nexport class StateChanges {\n  constructor(states) {\n    if (typeof states == 'string')\n      states = [states];\n    this.states = states;\n  }\n  register(particle, f) {\n    particle.addStateHandler(this.states, f);\n  }\n}\n\nexport default {Particle, ViewChanges, SlotChanges, StateChanges};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/particle.js\n// module id = 17\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\n\nimport assert from '../platform/assert-web.js';\nimport Entity from './entity.js';\nimport Type from './type.js';\nimport Symbols from './symbols.js';\n\n// TODO: Should relations normalized by another layer, or here?\nclass Relation extends Entity {\n  constructor(...entities) {\n    super();\n    this.entities = entities;\n  }\n  get data() {\n    return this.entities.map(entity => entity[Symbols.identifier].toLiteral());\n  }\n  static typeFor(relation) {\n    let result = new Type(relation.entities.map(entity => entity.constructor.type), relation.constructor);\n    return result;\n  }\n}\n\nexport default Relation;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/relation.js\n// module id = 18\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport assert from '../platform/assert-web.js';\n\n// ShapeView {name, direction, type}\n// Slot {name, direction, isRequired, isSet}\n\nfunction _fromLiteral(member) {\n  if (!!member && typeof member == 'object')\n    return Type.fromLiteral(member);\n  return member;\n}\n\nfunction _toLiteral(member) {\n  if (!!member && member.toLiteral)\n    return member.toLiteral();\n  return member;\n}\n\nclass Shape {\n  constructor(views, slots) {\n    this.views = views;\n    this.slots = slots;\n    this._typeVars = [];\n    for (let view of views)\n      for (let field of ['type', 'name', 'direction'])\n        if (Shape.isTypeVar(view[field]))\n          this._typeVars.push({object: view, field});\n\n    for (let slot of slots)\n      for (let field of ['name', 'direction', 'isRequired', 'isSet'])\n        if (Shape.isTypeVar(slot[field]))\n          this._typeVars.push({object: slot, field});\n  }\n\n  toPrettyString() {\n    return 'SHAAAAPE';\n  }\n\n  static fromLiteral(data) {\n    let views = data.views.map(view => ({type: _fromLiteral(view.type), name: _fromLiteral(view.name), direction: _fromLiteral(view.direction)}));\n    let slots = data.slots.map(slot => ({name: _fromLiteral(slot.name), direction: _fromLiteral(slot.direction), isRequired: _fromLiteral(slot.isRequired), isSet: _fromLiteral(slot.isSet)}));\n    return new Shape(views, slots);\n  }\n\n  toLiteral() {\n    let views = this.views.map(view => ({type: _toLiteral(view.type), name: _toLiteral(view.name), direction: _toLiteral(view.direction)}));\n    let slots = this.slots.map(slot => ({name: _toLiteral(slot.name), direction: _toLiteral(slot.direction), isRequired: _toLiteral(slot.isRequired), isSet: _toLiteral(slot.isSet)}));\n    return {views, slots};\n  }\n\n  clone() {\n    let views = this.views.map(({name, direction, type}) => ({name, direction, type}));\n    let slots = this.slots.map(({name, direction, isRequired, isSet}) => ({name, direction, isRequired, isSet}));\n    return new Shape(views, slots);\n  }\n\n  equals(other) {\n    if (this.views.length !== other.views.length)\n      return false;\n\n    // TODO: this isn't quite right as it doesn't deal with duplicates properly\n    if (!this._equalItems(other.views, this.views, this._equalView)) {\n      return false;\n    }\n\n    if (!this._equalItems(other.slots, this.slots, this._equalSlot)) {\n      return false;\n    }\n    return true;\n  }\n\n  _equalView(view, otherView) {\n    return view.name == otherView.name && view.direction == otherView.direction && view.type.equals(otherView.type);\n  }\n\n  _equalSlot(slot, otherSlot) {\n    return slot.name == otherSlot.name && slot.direction == otherSlot.direction && slot.isRequired == otherSlot.isRequired && slot.isSet == otherSlot.isSet;\n  }\n\n  _equalItems(otherItems, items, compareItem) {\n    for (let otherItem of otherItems) {\n      let exists = false;\n      for (let item of items) {\n        if (compareItem(item, otherItem)) {\n          exists = true;\n          break;\n        }\n      }\n      if (!exists)\n        return false;\n    }\n\n    return true;\n  }\n\n  static isTypeVar(reference) {\n    return (reference instanceof Type) && reference.hasProperty(r => r.isVariable || r.isVariableReference);\n  }\n\n  static mustMatch(reference) {\n    return !(reference == undefined || Shape.isTypeVar(reference));\n  }\n\n  static viewsMatch(shapeView, particleView) {\n    if (Shape.mustMatch(shapeView.name) && shapeView.name !== particleView.name)\n      return false;\n    // TODO: direction subsetting?\n    if (Shape.mustMatch(shapeView.direction) && shapeView.direction !== particleView.direction)\n      return false;\n    // TODO: polymorphism?\n    if (Shape.mustMatch(shapeView.type) && !shapeView.type.equals(particleView.type))\n      return false;\n    return true;\n  }\n\n  static slotsMatch(shapeSlot, particleSlot) {\n    if (Shape.mustMatch(shapeSlot.name) && shapeSlot.name !== particleSlot.name)\n      return false;\n    if (Shape.mustMatch(shapeSlot.direction) && shapeSlot.direction !== particleSlot.direction)\n      return false;\n    if (Shape.mustMatch(shapeSlot.isRequired) && shapeSlot.isRequired !== particleSlot.isRequired)\n      return false;\n    if (Shape.mustMatch(shapeSlot.isSet) && shapeSlot.isSet !== particleSlot.isSet)\n      return false;\n    return true;\n  }\n\n  particleMatches(particleSpec) {\n    let viewMatches = this.views.map(view => particleSpec.connections.filter(connection => Shape.viewsMatch(view, connection)));\n    let particleSlots = [];\n    particleSpec.slots.forEach(consumedSlot => {\n      particleSlots.push({name: consumedSlot.name, direction: 'consume', isRequired: consumedSlot.isRequired, isSet: consumedSlot.isSet});\n      consumedSlot.providedSlots.forEach(providedSlot => {\n        particleSlots.push({name: providedSlot.name, direction: 'provide', isRequired: false, isSet: providedSlot.isSet});\n      });\n    });\n    let slotMatches = this.slots.map(slot => particleSlots.filter(particleSlot => Shape.slotsMatch(slot, particleSlot)));\n\n    let exclusions = [];\n\n    function choose(list, exclusions) {\n      if (list.length == 0)\n        return true;\n      let thisLevel = list.pop();\n      for (let connection of thisLevel) {\n        if (exclusions.includes(connection))\n          continue;\n        let newExclusions = exclusions.slice();\n        newExclusions.push(connection);\n        if (choose(list, newExclusions))\n          return true;\n      }\n\n      return false;\n    }\n    return choose(viewMatches, []) && choose(slotMatches, []);\n  }\n}\n\nexport default Shape;\n\nimport Type from './type.js';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/shape.js\n// module id = 19\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport RecipeWalker from '../recipe/walker.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeUtil from '../recipe/recipe-util.js';\nimport assert from '../../platform/assert-web.js';\n\nexport default class ViewMapperBase extends Strategy {\n  async generate(strategizer) {\n    let self = this;\n\n    let results = Recipe.over(this.getResults(strategizer), new class extends RecipeWalker {\n      onView(recipe, view) {\n        if (view.fate !== self.fate)\n          return;\n\n        if (view.connections.length == 0)\n          return;\n\n        if (view.id)\n          return;\n\n        if (!view.type)\n          return;\n\n        // TODO: using the connection to retrieve type information is wrong.\n        // Once validation of recipes generates type information on the view\n        // we should switch to using that instead.\n        let counts = RecipeUtil.directionCounts(view);\n        return this.mapView(view, view.tags, view.type, counts);\n      }\n\n      mapView(view, tags, type, counts) {\n        let score = -1;\n        if (counts.in == 0 || counts.out == 0) {\n          if (counts.unknown > 0)\n            return;\n          if (counts.out == 0)\n            score = 1;\n          else\n            score = 0;\n        }\n\n        if (tags.length > 0)\n          score += 4;\n\n        let fate = self.fate;\n        if (counts.out > 0 && fate == 'map') {\n          return;\n        }\n        let views = self.getMappableViews(type, tags, counts);\n        if (views.length == 0)\n          return;\n\n        let responses = views.map(newView =>\n          ((recipe, clonedView) => {\n            for (let existingView of recipe.views)\n              // TODO: Why don't we link the view connections to the existingView?\n              if (existingView.id == newView.id)\n                return 0;\n            let tscore = 0;\n\n            assert(newView.id);\n            clonedView.mapToView(newView);\n            if (clonedView.fate != 'copy') {\n              clonedView.fate = fate;\n            }\n            return score + tscore;\n          }));\n\n        responses.push(null); // \"do nothing\" for this view.\n        return responses;\n      }\n    }(RecipeWalker.Permuted), this);\n\n    return {results, generate: null};\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/view-mapper-base.js\n// module id = 20\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/process/browser.js\n// module id = 21\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/webpack/buildin/global.js\n// module id = 22\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nexport default {};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/platform/fs-web.js\n// module id = 23\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport assert from '../platform/assert-web.js';\nimport ParticleSpec from './particle-spec.js';\nimport Type from './type.js';\nimport OuterPortAttachment from './debug/outer-port-attachment.js';\n\nclass ThingMapper {\n  constructor(prefix) {\n    this._prefix = prefix;\n    this._nextIdentifier = 0;\n    this._idMap = new Map();\n    this._reverseIdMap = new Map();\n  }\n\n  _newIdentifier() {\n    return this._prefix + (this._nextIdentifier++);\n  }\n\n  createMappingForThing(thing) {\n    assert(!this._reverseIdMap.has(thing));\n    let id = this._newIdentifier();\n    this.establishThingMapping(id, thing);\n    return id;\n  }\n\n  maybeCreateMappingForThing(thing) {\n    if (this.hasMappingForThing(thing)) {\n      return this.identifierForThing(thing);\n    }\n    return this.createMappingForThing(thing);\n  }\n\n  async establishThingMapping(id, thing) {\n    let continuation;\n    if (Array.isArray(thing)) {\n      [thing, continuation] = thing;\n    }\n    this._idMap.set(id, thing);\n    if (thing instanceof Promise) {\n      assert(continuation == null);\n      await this.establishThingMapping(id, await thing);\n    } else {\n      this._reverseIdMap.set(thing, id);\n      if (continuation) {\n        await continuation();\n      }\n    }\n  }\n\n  hasMappingForThing(thing) {\n    return this._reverseIdMap.has(thing);\n  }\n\n  identifierForThing(thing) {\n    assert(this._reverseIdMap.has(thing), `Missing thing ${thing}`);\n    return this._reverseIdMap.get(thing);\n  }\n\n  thingForIdentifier(id) {\n    assert(this._idMap.has(id), `Missing id: ${id}`);\n    return this._idMap.get(id);\n  }\n}\n\n\nclass APIPort {\n  constructor(messagePort, prefix) {\n    this._port = messagePort;\n    this._mapper = new ThingMapper(prefix);\n    this._messageMap = new Map();\n    this._port.onmessage = async e => this._handle(e);\n    this._debugAttachment = null;\n    this.messageCount = 0;\n\n    this.Direct = {\n      convert: a => a,\n      unconvert: a => a\n    };\n\n    this.Stringify = {\n      convert: a => a.toString(),\n      unconvert: a => eval(a)\n    };\n\n    this.LocalMapped = {\n      convert: a => this._mapper.maybeCreateMappingForThing(a),\n      unconvert: a => this._mapper.thingForIdentifier(a)\n    };\n\n    this.Mapped = {\n      convert: a => this._mapper.identifierForThing(a),\n      unconvert: a => this._mapper.thingForIdentifier(a)\n    };\n\n    this.Dictionary = function(primitive) {\n      return {\n        convert: a => {\n          let r = {};\n          for (let key in a) {\n            r[key] = primitive.convert(a[key]);\n          }\n          return r;\n        }\n      };\n    };\n\n    this.Map = function(keyprimitive, valueprimitive) {\n      return {\n        convert: a => {\n          let r = {};\n          a.forEach((value, key) => r[keyprimitive.convert(key)] = valueprimitive.convert(value));\n          return r;\n        },\n        unconvert: a => {\n          let r = new Map();\n          for (let key in a)\n            r.set(keyprimitive.unconvert(key), valueprimitive.unconvert(a[key]));\n          return r;\n        }\n      };\n    };\n\n    this.List = function(primitive) {\n      return {\n        convert: a => a.map(v => primitive.convert(v)),\n        unconvert: a => a.map(v => primitive.unconvert(v))\n      };\n    };\n\n    this.ByLiteral = function(clazz) {\n      return {\n        convert: a => a.toLiteral(),\n        unconvert: a => clazz.fromLiteral(a)\n      };\n    };\n  }\n\n  close() {\n    this._port.close();\n  }\n\n  async _handle(e) {\n    assert(this._messageMap.has(e.data.messageType));\n\n    this.messageCount++;\n\n    let handler = this._messageMap.get(e.data.messageType);\n    let args;\n    try {\n      args = this._unprocessArguments(handler.args, e.data.messageBody);\n    } catch (exc) {\n      console.error(`Exception during unmarshaling for ${e.data.messageType}`);\n      throw exc;\n    }\n    // If any of the converted arguments are still pending promises\n    // wait for them to complete before processing the message.\n    for (let arg of Object.values(args)) {\n      if (arg instanceof Promise) {\n        arg.then(() => this._handle(e));\n        return;\n      }\n    }\n    let handlerName = 'on' + e.data.messageType;\n    let result = this[handlerName](args);\n    if (this._debugAttachment && this._debugAttachment[handlerName]) {\n      this._debugAttachment[handlerName](args);\n    }\n    if (handler.isInitializer) {\n      assert(args.identifier);\n      await this._mapper.establishThingMapping(args.identifier, result);\n    }\n  }\n\n  _processArguments(argumentTypes, args) {\n    let messageBody = {};\n    for (let argument in argumentTypes)\n      messageBody[argument] = argumentTypes[argument].convert(args[argument]);\n    return messageBody;\n  }\n\n  _unprocessArguments(argumentTypes, args) {\n    let messageBody = {};\n    for (let argument in argumentTypes)\n      messageBody[argument] = argumentTypes[argument].unconvert(args[argument]);\n    return messageBody;\n  }\n\n  registerCall(name, argumentTypes) {\n    this[name] = args => {\n      let call = {messageType: name, messageBody: this._processArguments(argumentTypes, args)};\n      this._port.postMessage(call);\n      if (this._debugAttachment && this._debugAttachment[name]) {\n        this._debugAttachment[name](args);\n      }\n    };\n  }\n\n  registerHandler(name, argumentTypes) {\n    this._messageMap.set(name, {args: argumentTypes});\n  }\n\n  registerInitializerHandler(name, argumentTypes) {\n    argumentTypes.identifier = this.Direct;\n    this._messageMap.set(name, {\n      isInitializer: true,\n      args: argumentTypes,\n    });\n  }\n\n  registerInitializer(name, argumentTypes) {\n    this[name] = (thing, args) => {\n      let call = {messageType: name, messageBody: this._processArguments(argumentTypes, args)};\n      call.messageBody.identifier = this._mapper.createMappingForThing(thing);\n      this._port.postMessage(call);\n      if (this._debugAttachment && this._debugAttachment[name]) {\n        this._debugAttachment[name](thing, args);\n      }\n    };\n  }\n\n  registerRedundantInitializer(name, argumentTypes) {\n    this[name] = (thing, args) => {\n      if (this._mapper.hasMappingForThing(thing))\n        return;\n      let call = {messageType: name, messageBody: this._processArguments(argumentTypes, args)};\n      call.messageBody.identifier = this._mapper.createMappingForThing(thing);\n      this._port.postMessage(call);\n      if (this._debugAttachment && this._debugAttachment[name]) {\n        this._debugAttachment[name](thing, args);\n      }\n    };\n  }\n\n  initDebug(arcId) {\n    if (!this._debugAttachment) this._debugAttachment = new OuterPortAttachment(arcId);\n  }\n}\n\nclass PECOuterPort extends APIPort {\n  constructor(messagePort) {\n    super(messagePort, 'o');\n\n    this.registerCall('Stop', {});\n    this.registerCall('DefineParticle',\n      {particleDefinition: this.Direct, particleFunction: this.Stringify});\n    this.registerRedundantInitializer('DefineHandle', {type: this.ByLiteral(Type), name: this.Direct});\n    this.registerInitializer('InstantiateParticle',\n      {id: this.Direct, spec: this.ByLiteral(ParticleSpec), handles: this.Map(this.Direct, this.Mapped)});\n\n    this.registerCall('UIEvent', {particle: this.Mapped, slotName: this.Direct, event: this.Direct});\n    this.registerCall('SimpleCallback', {callback: this.Direct, data: this.Direct});\n    this.registerCall('AwaitIdle', {version: this.Direct});\n    this.registerCall('StartRender', {particle: this.Mapped, slotName: this.Direct, contentTypes: this.List(this.Direct)});\n    this.registerCall('StopRender', {particle: this.Mapped, slotName: this.Direct});\n\n    this.registerHandler('Render', {particle: this.Mapped, slotName: this.Direct, content: this.Direct});\n    this.registerHandler('Synchronize', {handle: this.Mapped, target: this.Mapped,\n                                    type: this.Direct, callback: this.Direct,\n                                    modelCallback: this.Direct, particleId: this.Direct});\n    this.registerHandler('HandleGet', {handle: this.Mapped, callback: this.Direct, particleId: this.Direct});\n    this.registerHandler('HandleToList', {handle: this.Mapped, callback: this.Direct, particleId: this.Direct});\n    this.registerHandler('HandleSet', {handle: this.Mapped, data: this.Direct, particleId: this.Direct});\n    this.registerHandler('HandleStore', {handle: this.Mapped, data: this.Direct, particleId: this.Direct});\n    this.registerHandler('HandleRemove', {handle: this.Mapped, data: this.Direct});\n    this.registerHandler('HandleClear', {handle: this.Mapped});\n    this.registerHandler('Idle', {version: this.Direct, relevance: this.Map(this.Mapped, this.Direct)});\n\n    this.registerHandler('ConstructInnerArc', {callback: this.Direct, particle: this.Mapped});\n    this.registerCall('ConstructArcCallback', {callback: this.Direct, arc: this.LocalMapped});\n\n    this.registerHandler('ArcCreateHandle', {callback: this.Direct, arc: this.LocalMapped, type: this.ByLiteral(Type), name: this.Direct});\n    this.registerInitializer('CreateHandleCallback', {callback: this.Direct, type: this.ByLiteral(Type), name: this.Direct, id: this.Direct});\n\n    this.registerHandler('ArcMapHandle', {callback: this.Direct, arc: this.LocalMapped, handle: this.Mapped});\n    this.registerInitializer('MapHandleCallback', {callback: this.Direct, id: this.Direct});\n\n    this.registerHandler('ArcCreateSlot',\n      {callback: this.Direct, arc: this.LocalMapped, transformationParticle: this.Mapped, transformationSlotName: this.Direct, hostedParticleName: this.Direct, hostedSlotName: this.Direct});\n    this.registerInitializer('CreateSlotCallback', {callback: this.Direct, hostedSlotId: this.Direct});\n    this.registerCall('InnerArcRender', {transformationParticle: this.Mapped, transformationSlotName: this.Direct, hostedSlotId: this.Direct, content: this.Direct});\n\n    this.registerHandler('ArcLoadRecipe', {arc: this.LocalMapped, recipe: this.Direct, callback: this.Direct});\n  }\n}\n\nclass PECInnerPort extends APIPort {\n  constructor(messagePort) {\n    super(messagePort, 'i');\n\n    this.registerHandler('Stop', {});\n    // particleFunction needs to be eval'd in context or it won't work.\n    this.registerHandler('DefineParticle',\n      {particleDefinition: this.Direct, particleFunction: this.Direct});\n    this.registerInitializerHandler('DefineHandle', {type: this.ByLiteral(Type), name: this.Direct});\n    this.registerInitializerHandler('InstantiateParticle',\n      {id: this.Direct, spec: this.ByLiteral(ParticleSpec), handles: this.Map(this.Direct, this.Mapped)});\n\n    this.registerHandler('UIEvent', {particle: this.Mapped, slotName: this.Direct, event: this.Direct});\n    this.registerHandler('SimpleCallback', {callback: this.LocalMapped, data: this.Direct});\n    this.registerHandler('AwaitIdle', {version: this.Direct});\n    this.registerHandler('StartRender', {particle: this.Mapped, slotName: this.Direct, contentTypes: this.Direct});\n    this.registerHandler('StopRender', {particle: this.Mapped, slotName: this.Direct});\n\n    this.registerCall('Render', {particle: this.Mapped, slotName: this.Direct, content: this.Direct});\n    this.registerCall('Synchronize', {handle: this.Mapped, target: this.Mapped,\n                                 type: this.Direct, callback: this.LocalMapped,\n                                 modelCallback: this.LocalMapped, particleId: this.Direct});\n    this.registerCall('HandleGet', {handle: this.Mapped, callback: this.LocalMapped, particleId: this.Direct});\n    this.registerCall('HandleToList', {handle: this.Mapped, callback: this.LocalMapped, particleId: this.Direct});\n    this.registerCall('HandleSet', {handle: this.Mapped, data: this.Direct, particleId: this.Direct});\n    this.registerCall('HandleStore', {handle: this.Mapped, data: this.Direct, particleId: this.Direct});\n    this.registerCall('HandleRemove', {handle: this.Mapped, data: this.Direct});\n    this.registerCall('HandleClear', {handle: this.Mapped});\n    this.registerCall('Idle', {version: this.Direct, relevance: this.Map(this.Mapped, this.Direct)});\n\n    this.registerCall('ConstructInnerArc', {callback: this.LocalMapped, particle: this.Mapped});\n    this.registerHandler('ConstructArcCallback', {callback: this.LocalMapped, arc: this.Direct});\n\n    this.registerCall('ArcCreateHandle', {callback: this.LocalMapped, arc: this.Direct, type: this.ByLiteral(Type), name: this.Direct});\n    this.registerInitializerHandler('CreateHandleCallback', {callback: this.LocalMapped, type: this.ByLiteral(Type), name: this.Direct, id: this.Direct});\n    this.registerCall('ArcMapHandle', {callback: this.LocalMapped, arc: this.Direct, handle: this.Mapped});\n    this.registerInitializerHandler('MapHandleCallback', {callback: this.LocalMapped, id: this.Direct});\n    this.registerCall('ArcCreateSlot',\n      {callback: this.LocalMapped, arc: this.Direct, transformationParticle: this.Mapped, transformationSlotName: this.Direct, hostedParticleName: this.Direct, hostedSlotName: this.Direct});\n    this.registerInitializerHandler('CreateSlotCallback', {callback: this.LocalMapped, hostedSlotId: this.Direct});\n    this.registerHandler('InnerArcRender', {transformationParticle: this.Mapped, transformationSlotName: this.Direct, hostedSlotId: this.Direct, content: this.Direct});\n\n    this.registerCall('ArcLoadRecipe', {arc: this.Direct, recipe: this.Direct, callback: this.LocalMapped});\n  }\n}\n\nexport {PECOuterPort as PECOuterPort, PECInnerPort as PECInnerPort};\nexport default {PECOuterPort, PECInnerPort};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/api-channel.js\n// module id = 24\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nlet nob = () => Object.create(null);\n\nexport default Base => class extends Base {\n  constructor() {\n    super();\n    this._pendingProps = nob();\n    this._props = this._getInitialProps() || nob();\n    this._lastProps = nob();\n    this._state = this._getInitialState() || nob();\n    this._lastState = nob();\n  }\n  _getInitialProps() {\n  }\n  _getInitialState() {\n  }\n  _getProperty(name) {\n    return this._pendingProps[name] || this._props[name];\n  }\n  _setProperty(name, value) {\n    // dirty checking opportunity\n    if (this._validator || this._wouldChangeProp(name, value)) {\n      this._pendingProps[name] = value;\n      this._invalidateProps();\n    }\n  }\n  _wouldChangeProp(name, value) {\n    return (typeof value === 'object') || (this._props[name] !== value);\n  }\n  _setProps(props) {\n    // TODO(sjmiles): should this be a replace instead of a merge?\n    Object.assign(this._pendingProps, props);\n    this._invalidateProps();\n  }\n  _invalidateProps() {\n    this._propsInvalid = true;\n    this._invalidate();\n  }\n  _setState(state) {\n    Object.assign(this._state, state);\n    this._invalidate();\n  }\n  _async(fn) {\n    // TODO(sjmiles): SystemJS throws unless `Promise` is `window.Promise`\n    return Promise.resolve().then(fn.bind(this));\n    //return setTimeout(fn.bind(this), 10);\n  }\n  _invalidate() {\n    if (!this._validator) {\n      //this._log('register _async validate');\n      //console.log(this.localName + (this.id ? '#' + this.id : '') + ': invalidated');\n      this._validator = this._async(this._validate);\n    }\n  }\n  _validate() {\n    // try..catch to ensure we nullify `validator` before return\n    try {\n      // TODO(sjmiles): should this be a replace instead of a merge?\n      Object.assign(this._props, this._pendingProps);\n      if (this._propsInvalid) {\n        // TODO(sjmiles): should/can have different timing from rendering?\n        this._willReceiveProps(this._props, this._state, this._lastProps);\n        this._propsInvalid = false;\n      }\n      if (this._shouldUpdate(this._props, this._state, this._lastProps, this._lastState)) {\n        // TODO(sjmiles): consider throttling render to rAF\n        this._ensureMount();\n        this._update(this._props, this._state, this._lastProps);\n      }\n    } catch (x) {\n      console.error(x);\n    }\n    // nullify validator _after_ methods so state changes don't reschedule validation\n    // TODO(sjmiles): can/should there ever be state changes fom inside _update()? In React no, in Xen yes (until I have a good reason not too).\n    this._validator = null;\n    // save the old props and state\n    // TODO(sjmiles): don't need to create these for default _shouldUpdate\n    this._lastProps = Object.assign(nob(), this._props);\n    //this._lastState = Object.assign(nob(), this._state);\n    this._didUpdate(this._props, this._state);\n  }\n  _ensureMount() {\n  }\n  _willReceiveProps(props, state) {\n  }\n  /*\n  _willReceiveState(props, state) {\n  }\n  */\n  _shouldUpdate(props, state, lastProps) {\n    return true;\n  }\n  _update(props, state) {\n  }\n  _didUpdate(props, state) {\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/browser/lib/xen-state.js\n// module id = 25\n// module chunks = 0","/*\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nexport default (scope => {\n\n'use strict';\n\nif (typeof document !== 'undefined' && !('currentImport' in document)) {\n  Object.defineProperty(document, 'currentImport', {\n    get() {\n      return (document._currentScript || document.currentScript || document).ownerDocument;\n    }\n  });\n}\n\n/* Annotator */\n// tree walker that generates arbitrary data using visitor function `cb`\n// `cb` is called as `cb(node, key, notes)`\n// where\n//   `node` is a visited node.\n//   `key` is a handle which identifies the node in a map generated by `Annotator.locateNodes`.\nclass Annotator {\n  constructor(cb) {\n    this.cb = cb;\n  }\n  // For subtree at `node`, produce annotation object `notes`.\n  // the content of `notes` is completely determined by the behavior of the\n  // annotator callback function supplied at the constructor.\n  annotate(node, notes, opts) {\n    this.notes = notes;\n    this.opts = opts || 0;\n    this.key = this.opts.key || 0;\n    notes.locator = this._annotateSubtree(node);\n    //console.log('notes:', notes);\n    return notes;\n  }\n  // walking subtree at `node`\n  _annotateSubtree(node) {\n    let childLocators;\n    for (let i = 0, child = node.firstChild, previous = null, neo; child; i++) {\n      // returns a locator only if a node in the subtree requires one\n      let childLocator = this._annotateNode(child);\n      // only when necessary, maintain a sparse array of locators\n      if (childLocator) {\n        (childLocators = childLocators || {})[i] = childLocator;\n      }\n      // `child` may have been evacipated by visitor\n      neo = previous ? previous.nextSibling : node.firstChild;\n      if (neo === child) {\n        previous = child;\n        child = child.nextSibling;\n      } else {\n        child = neo;\n        i--;\n      }\n    }\n    // is falsey unless there was at least one childLocator\n    return childLocators;\n  }\n  _annotateNode(node) {\n    // visit node\n    let key = this.key++;\n    let shouldLocate = this.cb(node, key, this.notes, this.opts);\n    // recurse\n    //console.group(node.localName||'#text');\n    let locators = this._annotateSubtree(node);\n    //console.groupEnd();\n    if (shouldLocate || locators) {\n      //console.log('capturing', key, '('+(node.localName||'#text')+')');\n      let cl = Object.create(null);\n      cl.key = key;\n      if (locators) {\n        cl.sub = locators;\n      }\n      return cl;\n    }\n  }\n}\n\nlet locateNodes = function(root, locator, map) {\n  map = map || [];\n  for (let n in locator) {\n    let loc = locator[n];\n    if (loc) {\n      let node = root.childNodes[n];\n      if (node.nodeType == Node.TEXT_NODE && node.parentElement) {\n        // TODO(mmandlis): remove this line and the (property === 'textContent') clause\n        // in _set() method, in favor of explicit innerHTML binding.\n        map[loc.key] = node.parentElement;\n      } else {\n        map[loc.key] = node;\n      }\n      if (loc.sub) {\n        // recurse\n        locateNodes(node, loc.sub, map);\n      }\n    }\n  }\n  return map;\n};\n\n/* Annotation Producer */\n// must return `true` for any node whose key we wish to track\nlet annotatorImpl = function(node, key, notes, opts) {\n  // hook\n  if (opts.annotator && opts.annotator(node, key, notes, opts)) {\n    return true;\n  }\n  // default\n  switch (node.nodeType) {\n    case Node.DOCUMENT_FRAGMENT_NODE:\n      return;\n    case Node.ELEMENT_NODE:\n      return annotateElementNode(node, key, notes);\n    case Node.TEXT_NODE:\n      return annotateTextNode(node, key, notes);\n  }\n};\n\nlet annotateTextNode = function(node, key, notes) {\n  if (annotateMustache(node, key, notes, 'textContent', node.textContent)) {\n    node.textContent = '';\n    return true;\n  }\n};\n\nlet annotateElementNode = function(node, key, notes) {\n  if (node.hasAttributes()) {\n    let noted = false;\n    for (let a$ = node.attributes, i = a$.length - 1, a; i >= 0 && (a = a$[i]); i--) {\n      if (\n        annotateEvent(node, key, notes, a.name, a.value) ||\n        annotateMustache(node, key, notes, a.name, a.value)\n      ) {\n        node.removeAttribute(a.name);\n        noted = true;\n      }\n    }\n    return noted;\n  }\n};\n\nlet annotateMustache = function(node, key, notes, property, value) {\n  if (value.slice(0, 2) === '{{') {\n    if (property === 'class') {\n      property = 'className';\n    }\n    let n = value.slice(2, -2);\n    takeNote(notes, key, 'mustaches', property, n);\n    if (n[0] === '$') {\n      takeNote(notes, 'xlate', n, true);\n    }\n    return true;\n  }\n};\n\nlet annotateEvent = function(node, key, notes, name, value) {\n  if (name.slice(0, 3) === 'on-') {\n    if (value.slice(0, 2) === '{{') {\n      value = value.slice(2, -2);\n      console.warn(\n        `Xen: event handler for '${name}' expressed as a mustache, which is not supported. Using literal value '${value}' instead.`\n      );\n    }\n    takeNote(notes, key, 'events', name.slice(3), value);\n    return true;\n  }\n};\n\nlet takeNote = function(notes, key, group, name, note) {\n  let n$ = notes[key] || (notes[key] = Object.create(null));\n  (n$[group] || (n$[group] = {}))[name] = note;\n  //console.log('[%s]::%s.{{%s}}:', key, group, name, note);\n};\n\nlet annotator = new Annotator(annotatorImpl);\n\nlet annotate = function(root, key, opts) {\n  return (root._notes ||\n    (root._notes = annotator.annotate(root.content, {/*ids:{}*/}, key, opts))\n  );\n};\n\n/* Annotation Consumer */\nlet mapEvents = function(notes, map, mapper) {\n  // add event listeners\n  for (let key in notes) {\n    let node = map[key];\n    let events = notes[key] && notes[key].events;\n    if (node && events) {\n      for (let name in events) {\n        mapper(node, name, events[name]);\n      }\n    }\n  }\n};\n\nlet listen = function(controller, node, eventName, handlerName) {\n  node.addEventListener(eventName, function(e) {\n    if (controller[handlerName]) {\n      return controller[handlerName](e, e.detail);\n    }\n  });\n};\n\nlet set = function(notes, map, scope, controller) {\n  if (scope) {\n    for (let key in notes) {\n      let node = map[key];\n      if (node) {\n        // everybody gets a scope\n        node.scope = scope;\n        // now get your regularly scheduled bindings\n        let mustaches = notes[key].mustaches;\n        for (let name in mustaches) {\n          let property = mustaches[name];\n          if (property in scope) {\n            _set(node, name, scope[property], controller);\n          }\n        }\n      }\n    }\n  }\n};\n\nlet _set = function(node, property, value, controller) {\n  let modifier = property.slice(-1);\n  //console.log('_set: %s, %s, '%s'', node.localName || '(text)', property, value);\n  if (property === 'style%' || property === 'style') {\n    if (typeof value === 'string') {\n      node.style.cssText = value;\n    } else {\n      Object.assign(node.style, value);\n    }\n  } else if (modifier == '$') {\n    let n = property.slice(0, -1);\n    if (typeof value === 'boolean') {\n      setBoolAttribute(node, n, value);\n    } else {\n      node.setAttribute(n, value);\n    }\n  } else if (property === 'textContent') {\n    if (value && (value.$template || value.template)) {\n      _setSubTemplate(node, value, controller);\n    } else {\n      node.textContent = (value || '');\n    }\n  } else if (property === 'unsafe-html') {\n    node.innerHTML = value || '';\n  } else {\n    node[property] = value;\n  }\n};\n\nlet _setSubTemplate = function(node, value, controller) {\n  // TODO(sjmiles): sub-template iteration ability\n  // specially implemented to support arcs (serialization boundary)\n  // Aim to re-implement as a plugin.\n  let template = value.template;\n  if (!template) {\n    let container = node.getRootNode(); //node.parentElement\n    template = container.querySelector(`template[${value.$template}]`);\n  }\n  node.textContent = '';\n  if (template && value.models) {\n    for (let m of value.models) {\n      stamp(template).events(controller).set(m).appendTo(node);\n    }\n  }\n};\n\nlet setBoolAttribute = function(node, attr, state) {\n  node[\n    (state === undefined ? !node.hasAttribute(attr) : state)\n      ? 'setAttribute'\n      : 'removeAttribute'\n  ](attr, '');\n};\n\nlet stamp = function(template, opts) {\n  // construct (or use memoized) notes\n  let notes = annotate(template, opts);\n  // CRITICAL TIMING ISSUE #1:\n  // importNode can have side-effects, like CustomElement callbacks (before we\n  // can do any work on the imported subtree, before we can mapEvents, e.g.).\n  // we could clone into an inert document (say a new template) and process the nodes\n  // before importing if necessary.\n  let root = document.importNode(template.content, true);\n  // map DOM to keys\n  let map = locateNodes(root, notes.locator);\n  // return dom manager\n  let dom = {\n    root: root,\n    notes: notes,\n    map: map,\n    $(slctr) {\n      return this.root.querySelector(slctr);\n    },\n    set: function(scope) {\n      set(notes, map, scope, this.controller);\n      return this;\n    },\n    events: function(controller) {\n      // TODO(sjmiles): originally `controller` was expected to be an Object with event handler\n      // methods on it (typically a custom-element stamping a template).\n      // In Arcs, we want to attach a generic handler (Function) for any event on this node.\n      // Subtemplate stamping gets involved because they need to reuse whichever controller.\n      // I suspect this can be simplified, but right now I'm just making it go.\n      if (controller && typeof controller !== 'function') {\n        controller = listen.bind(this, controller);\n      }\n      this.controller = controller;\n      if (controller) {\n        mapEvents(notes, map, controller);\n      }\n      return this;\n    },\n    appendTo: function(node) {\n      if (this.root) {\n        // TODO(sjmiles): assumes this.root is a fragment\n        node.appendChild(this.root);\n      } else {\n        console.warn('Xen: cannot appendTo, template stamped no DOM');\n      }\n      // TODO(sjmiles): this.root is no longer a fragment\n      this.root = node;\n      return this;\n    }\n  };\n  return dom;\n};\n\nreturn {\n  setBoolAttribute,\n  stamp\n};\n\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/browser/lib/xen-template.js\n// module id = 26\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport assert from '../platform/assert-web.js';\nimport Template from './browser/lib/xen-template.js';\n\n// TODO(sjmiles): should be elsewhere\n// TODO(sjmiles): using Node syntax to import custom-elements in strictly-browser context\n// TOOD(dstockwell): why was this only in browser context?\nimport './browser/lib/x-list.js';\nimport './browser/lib/model-select.js';\n\nclass DomContext {\n  constructor(context, containerKind) {\n    this._context = context;\n    this._containerKind = containerKind;\n    // TODO(sjmiles): _liveDom needs new name\n    this._liveDom = null;\n    this._innerContextBySlotName = {};\n  }\n  static createContext(context, content) {\n    let domContext = new DomContext(context);\n    domContext.stampTemplate(DomContext.createTemplateElement(content.template), () => {});\n    domContext.updateModel(content.model);\n    return domContext;\n  }\n  initContext(context) {\n    assert(context);\n    if (!this._context) {\n      this._context = document.createElement(this._containerKind || 'div');\n      context.appendChild(this._context);\n    } else {\n      assert(this._context.parentNode == context,\n             'TODO: add support for moving slot to different context');\n    }\n  }\n  get context() { return this._context; }\n  isEqual(context) {\n    return this._context.parentNode == context;\n  }\n  updateModel(model) {\n    if (this._liveDom) {\n      this._liveDom.set(model);\n    }\n  }\n  clear() {\n    if (this._liveDom) {\n      this._liveDom.root.textContent = '';\n    }\n    this._liveDom = null;\n    this._innerContextBySlotName = {};\n\n  }\n  static createTemplateElement(template) {\n    return Object.assign(document.createElement('template'), {innerHTML: template});\n  }\n  stampTemplate(template, eventHandler) {\n    if (!this._liveDom) {\n      // TODO(sjmiles): hack to allow subtree elements (e.g. x-list) to marshal events\n      this._context._eventMapper = this._eventMapper.bind(this, eventHandler);\n      this._liveDom = Template\n          .stamp(template)\n          .events(this._context._eventMapper)\n          .appendTo(this._context);\n    }\n  }\n  observe(observer) {\n    observer.observe(this._context, {childList: true, subtree: true});\n  }\n  getInnerContext(innerSlotName) {\n    return this._innerContextBySlotName[innerSlotName];\n  }\n  isDirectInnerSlot(slot) {\n    let parentNode = slot.parentNode;\n    while (parentNode) {\n      if (parentNode == this._context) {\n        return true;\n      }\n      if (parentNode.getAttribute('slotid')) {\n        // this is an inner slot of an inner slot.\n        return false;\n      }\n      parentNode = parentNode.parentNode;\n    }\n    assert(false);\n  }\n  initInnerContexts(slotSpec) {\n    this._innerContextBySlotName = {};\n    Array.from(this._context.querySelectorAll('[slotid]')).forEach(s => {\n      if (!this.isDirectInnerSlot(s)) {\n        // Skip inner slots of an inner slot of the given slot.\n        return;\n      }\n      let slotId = s.getAttribute('slotid');\n      let providedSlotSpec = slotSpec.providedSlots.find(ps => ps.name == slotId);\n      if (providedSlotSpec) { // Skip non-declared slots\n        let subId = s.subid;\n        assert(!subId || providedSlotSpec.isSet,\n            `Slot provided in ${slotSpec.name} sub-id ${subId} doesn't match set spec: ${providedSlotSpec.isSet}`);\n        if (providedSlotSpec.isSet) {\n          if (!this._innerContextBySlotName[slotId]) {\n            this._innerContextBySlotName[slotId] = {};\n          }\n          assert(!this._innerContextBySlotName[slotId][subId],\n                 `Slot ${slotSpec.name} cannot provide multiple ${slotId}:${subId} inner slots`);\n          this._innerContextBySlotName[slotId][subId] = s;\n        } else {\n          this._innerContextBySlotName[slotId] = s;\n        }\n      } else {\n        console.warn(`Slot ${slotSpec.name} has unexpected inner slot ${slotId}`);\n      }\n    });\n  }\n  findRootSlots() {\n    let innerSlotById = {};\n    Array.from(this._context.querySelectorAll('[slotid]')).forEach(s => {\n      assert(this.isDirectInnerSlot(s), 'Unexpected inner slot');\n      let slotId = s.getAttribute('slotid');\n      assert(!innerSlotById[slotId], `Duplicate root slot ${slotId}`);\n      innerSlotById[slotId] = s;\n    });\n    return innerSlotById;\n  }\n  _eventMapper(eventHandler, node, eventName, handlerName) {\n    node.addEventListener(eventName, event => {\n      // TODO(sjmiles): we have an extremely minimalist approach to events here, this is useful IMO for\n      // finding the smallest set of features that we are going to need.\n      // First problem: click event firing multiple times as it bubbles up the tree, minimalist solution\n      // is to enforce a 'first listener' rule by executing `stopPropagation`.\n      event.stopPropagation();\n      eventHandler({\n        handler: handlerName,\n        data: {\n          key: node.key,\n          value: node.value\n        }\n      });\n    });\n  }\n}\n\nclass SetDomContext {\n  constructor(containerKind) {\n    this._contextBySubId = {};\n    this._containerKind = containerKind;\n  }\n  initContext(context) {\n    Object.keys(context).forEach(subId => {\n      if (!this._contextBySubId[subId] || !this._contextBySubId[subId].isEqual(context[subId])) {\n        this._contextBySubId[subId] = new DomContext(null, this._containerKind);\n      }\n      this._contextBySubId[subId].initContext(context[subId]);\n    });\n    // Delete sub-contexts that are not found in the new context.\n    Object.keys(this._contextBySubId).forEach(subId => {\n      if (!context[subId]) {\n        delete this._contextBySubId[subId];\n      }\n    });\n  }\n  isEqual(context) {\n    return Object.keys(this._contextBySubId).length == Object.keys(context).length &&\n           !Object.keys(this._contextBySubId).find(c => this._contextBySubId[c] != context[c]);\n  }\n  updateModel(model) {\n    assert(model.items, `Model must contain items`);\n    model.items.forEach(item => {\n      Object.keys(model).forEach(key => {\n        if (key != 'items') {\n          item[key] = model[key];\n        }\n      });\n      if (this._contextBySubId[item.subId]) {\n        this._contextBySubId[item.subId].updateModel(item);\n      }\n    });\n  }\n  clear() {\n    Object.values(this._contextBySubId).forEach(context => context.clear());\n  }\n  stampTemplate(template, eventHandler, eventMapper) {\n    Object.values(this._contextBySubId).forEach(context => context.stampTemplate(template, eventHandler, eventMapper));\n  }\n  observe(observer) {\n    Object.values(this._contextBySubId).forEach(context => context.observe(observer));\n  }\n  getInnerContext(innerSlotName) {\n    let innerContexts = {};\n    Object.keys(this._contextBySubId).forEach(subId => {\n      innerContexts[subId] = this._contextBySubId[subId].getInnerContext(innerSlotName);\n    });\n    return innerContexts;\n  }\n  initInnerContexts(slotSpec) {\n    Object.values(this._contextBySubId).forEach(context => context.initInnerContexts(slotSpec));\n  }\n}\n\nexport {DomContext, SetDomContext};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/dom-context.js\n// module id = 27\n// module chunks = 0","/** @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport Identifier from './identifier.js';\nimport Entity from './entity.js';\nimport Relation from './relation.js';\nimport Symbols from './symbols.js';\nlet identifier = Symbols.identifier;\nimport assert from '../platform/assert-web.js';\nimport ParticleSpec from './particle-spec.js';\n\n// TODO: This won't be needed once runtime is transferred between contexts.\nfunction cloneData(data) {\n  return data;\n  //return JSON.parse(JSON.stringify(data));\n}\n\nfunction restore(entry, entityClass) {\n  let {id, rawData} = entry;\n  let entity = new entityClass(cloneData(rawData));\n  if (entry.id) {\n    entity.identify(entry.id);\n  }\n\n  // TODO some relation magic, somewhere, at some point.\n\n  return entity;\n}\n\n/** @class Handle\n * Base class for Views and Variables.\n */\nclass Handle {\n  constructor(view, particleId, canRead, canWrite) {\n    this._view = view;\n    this.canRead = canRead;\n    this.canWrite = canWrite;\n    this._particleId = particleId;\n  }\n  underlyingView() {\n    return this._view;\n  }\n  /** @method on(kind, callback, target)\n   * Register for callbacks every time the requested kind of event occurs.\n   * Events are grouped into delivery sets by target, which should therefore\n   * be the recieving particle.\n   */\n  on(kind, callback, target) {\n    return this._view.on(kind, callback, target, this._particleId);\n  }\n\n  synchronize(kind, modelCallback, callback, target) {\n    return this._view.synchronize(kind, modelCallback, callback, target, this._particleId);\n  }\n\n  generateID() {\n    assert(this._view.generateID);\n    return this._view.generateID();\n  }\n\n  generateIDComponents() {\n    assert(this._view.generateIDComponents);\n    return this._view.generateIDComponents();\n  }\n\n  _serialize(entity) {\n    if (!entity.isIdentified())\n      entity.createIdentity(this.generateIDComponents());\n    let id = entity[identifier];\n    let rawData = entity.dataClone();\n    return {\n      id,\n      rawData\n    };\n  }\n\n  _restore(entry) {\n    assert(this.entityClass, 'Handles need entity classes for deserialization');\n    return restore(entry, this.entityClass);\n  }\n\n  get type() {\n    return this._view._type;\n  }\n  get name() {\n    return this._view.name;\n  }\n\n  get _id() {\n    return this._view._id;\n  }\n\n  toManifestString() {\n    return `'${this._id}'`;\n  }\n}\n\n/** @class View\n * A handle on a set of Entity data. Note that, as a set, a View can only contain\n * a single version of an Entity for each given ID. Further, no order is implied\n * by the set. A particle's manifest dictates the types of views that need to be\n * connected to that particle, and the current recipe identifies which views are\n * connected.\n */\nclass Collection extends Handle {\n  constructor(view, particleId, canRead, canWrite) {\n    // TODO: this should talk to an API inside the PEC.\n    super(view, particleId, canRead, canWrite);\n  }\n  query() {\n    // TODO: things\n  }\n  /** @method async toList()\n   * Returns a list of the Entities contained by the View.\n   * throws: Error if this view is not configured as a readable view (i.e. 'in' or 'inout')\n     in the particle's manifest.\n   */\n  async toList() {\n    // TODO: remove this and use query instead\n    if (!this.canRead)\n      throw new Error('View not readable');\n    return (await this._view.toList(this._particleId)).map(a => this._restore(a));\n  }\n\n  /** @method store(entity)\n   * Stores a new entity into the View.\n   * throws: Error if this view is not configured as a writeable view (i.e. 'out' or 'inout')\n     in the particle's manifest.\n   */\n  async store(entity) {\n    if (!this.canWrite)\n      throw new Error('View not writeable');\n    let serialization = this._serialize(entity);\n    return this._view.store(serialization, this._particleId);\n  }\n\n  /** @method remove(entity)\n   * Removes an entity from the View.\n   * throws: Error if this view is not configured as a writeable view (i.e. 'out' or 'inout')\n     in the particle's manifest.\n   */\n  async remove(entity) {\n    if (!this.canWrite)\n      throw new Error('View not writeable');\n    let serialization = this._serialize(entity);\n    return this._view.remove(serialization.id, this._particleId);\n  }\n}\n\n/** @class Variable\n * A handle on a single entity. A particle's manifest dictates\n * the types of views that need to be connected to that particle, and\n * the current recipe identifies which views are connected.\n */\nclass Variable extends Handle {\n  constructor(variable, canRead, canWrite, particleId) {\n    super(variable, canRead, canWrite, particleId);\n  }\n\n  /** @method async get()\n  * Returns the Entity contained by the Variable, or undefined if the Variable\n  * is cleared.\n  * throws: Error if this variable is not configured as a readable view (i.e. 'in' or 'inout')\n    in the particle's manifest.\n   */\n  async get() {\n    if (!this.canRead)\n      throw new Error('View not readable');\n    let result = await this._view.get(this._particleId);\n    if (result == null)\n      return undefined;\n    if (this.type.isEntity)\n      return this._restore(result);\n    if (this.type.isInterface)\n      return ParticleSpec.fromLiteral(result);\n    return result;\n  }\n\n  /** @method set(entity)\n   * Stores a new entity into the Variable, replacing any existing entity.\n   * throws: Error if this variable is not configured as a writeable view (i.e. 'out' or 'inout')\n     in the particle's manifest.\n   */\n  async set(entity) {\n    if (!this.canWrite)\n      throw new Error('View not writeable');\n    return this._view.set(this._serialize(entity), this._particleId);\n  }\n\n  /** @method clear()\n   * Clears any entity currently in the Variable.\n   * throws: Error if this variable is not configured as a writeable view (i.e. 'out' or 'inout')\n     in the particle's manifest.\n   */\n  async clear() {\n    if (!this.canWrite)\n      throw new Error('View not writeable');\n    await this._view.clear(this._particleId);\n  }\n}\n\nfunction handleFor(view, isSet, particleId, canRead = true, canWrite = true) {\n  return (isSet || (isSet == undefined && view.type.isSetView))\n      ? new Collection(view, particleId, canRead, canWrite)\n      : new Variable(view, particleId, canRead, canWrite);\n}\n\nexport default {handleFor};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/handle.js\n// module id = 28\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport assert from '../../platform/assert-web.js';\nimport util from './util.js';\n\nclass Search {\n  constructor(phrase, unresolvedTokens) {\n    assert(phrase);\n\n    this._phrase = '';\n    this._unresolvedTokens = [];\n    this._resolvedTokens = [];\n\n    this.appendPhrase(phrase, unresolvedTokens);\n  }\n  appendPhrase(phrase, unresolvedTokens) {\n    // concat phrase\n    if (this._phrase.length > 0) {\n      this._phrase = this.phrase.concat(' ');\n    }\n    this._phrase = this._phrase.concat(phrase);\n\n    // update tokens\n    let newTokens = phrase.toLowerCase().split(/[^a-z0-9]/g);\n    newTokens.forEach(t => {\n      if (!unresolvedTokens || unresolvedTokens.indexOf(t) >= 0) {\n        this._unresolvedTokens.push(t);\n      } else {\n        this._resolvedTokens.push(t);\n      }\n    });\n  }\n  get phrase() { return this._phrase; }\n  get unresolvedTokens() { return this._unresolvedTokens; }\n  get resolvedTokens() { return this._resolvedTokens; }\n  resolveToken(token) {\n    let index = this.unresolvedTokens.indexOf(token.toLowerCase());\n    assert(index >= 0, `Cannot resolved nonexistent token ${token}`);\n    this._unresolvedTokens.splice(index, 1);\n    this._resolvedTokens.push(token.toLowerCase());\n  }\n\n  isValid() {\n    return this._unresolvedTokens.length > 0 || this._resolvedTokens.length > 0;\n  }\n\n  isResolved() {\n    assert(Object.isFrozen(this));\n    // Recipe is considered resolved, if at least one of the search tokens was resolved.\n    // TODO: Unresolved tokens don't prevent the recipe from being resolved. For now...\n    return this._resolvedTokens.length > 0;\n  }\n\n  _normalize() {\n    this._unresolvedTokens.sort();\n    this._resolvedTokens.sort();\n\n    Object.freeze(this);\n  }\n\n  _copyInto(recipe) {\n    if (recipe.search) {\n      recipe.search.appendPhrase(this.phrase, this.unresolvedTokens);\n    } else {\n      recipe.search = new Search(this.phrase, this.unresolvedTokens);\n      assert(recipe.search.resolvedTokens.length == this.resolvedTokens.length);\n    }\n    assert(this.resolvedTokens.every(rt => recipe.search.resolvedTokens.indexOf(rt) >= 0) &&\n           this.unresolvedTokens.every(rt => recipe.search.unresolvedTokens.indexOf(rt) >= 0));\n    return recipe.search;\n  }\n\n  toString(options) {\n    let result = [];\n    result.push(`search \\`${this.phrase}\\``);\n\n    let tokenStr = [];\n    tokenStr.push('  tokens');\n    if (this.unresolvedTokens.length > 0) {\n      tokenStr.push(this.unresolvedTokens.map(t => `\\`${t}\\``).join(' '));\n    }\n    if (this.resolvedTokens.length > 0) {\n      tokenStr.push(`// ${this.resolvedTokens.map(t => `\\`${t}\\``).join(' ')}`);\n    }\n    if (options && options.showUnresolved) {\n      if (this.unresolvedTokens.length > 0) {\n        tokenStr.push('// unresolved search tokens');\n      }\n    }\n    result.push(tokenStr.join(' '));\n\n    return result.join('\\n');\n  }\n}\n\nexport default Search;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/search.js\n// module id = 29\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport assert from '../platform/assert-web.js';\nimport Symbols from './symbols.js';\nimport Entity from './entity.js';\nimport Schema from './schema.js';\nimport Type from './type.js';\nimport Relation from './relation.js';\n\nfunction testEntityClass(type) {\n  return new Schema({\n    name: type,\n    sections: [{\n      sectionType: 'normative',\n      fields: {'id': 'Number', 'value': 'Text'}\n    }],\n    parents: [],\n  }).entityClass();\n}\n\nlet BasicEntity = testEntityClass('BasicEntity');\n\nexport default {\n  Entity,\n  BasicEntity,\n  Relation,\n  testing: {\n    testEntityClass,\n  },\n  internals: {\n    identifier: Symbols.identifier,\n    Type,\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/runtime.js\n// module id = 30\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport assert from '../platform/assert-web.js';\n\nclass Slot {\n  constructor(consumeConn, arc) {\n    assert(consumeConn);\n    assert(arc);\n    this._consumeConn = consumeConn;\n    this._arc = arc;\n    this._context = null;\n    this.startRenderCallback = null;\n    this.stopRenderCallback = null;\n    this._hostedSlotById = new Map();\n  }\n  get consumeConn() { return this._consumeConn; }\n  get arc() { return this._arc; }\n  getContext() { return this._context; }\n  setContext(context) { this._context = context; }\n  isSameContext(context) { return this._context == context; }\n\n  updateContext(context) {\n    // do nothing, if context unchanged.\n    if ((!this.getContext() && !context) ||\n        (this.getContext() && context && this.isSameContext(context))) {\n      return;\n    }\n\n    // update the context;\n    let wasNull = !this.getContext();\n    this.setContext(context);\n    if (this.getContext()) {\n      if (wasNull) {\n        this.startRender();\n      }\n    } else {\n      this.stopRender();\n    }\n  }\n  startRender() {\n    if (this.startRenderCallback) {\n      let contentTypes = this.constructRenderRequest();\n      this.startRenderCallback({particle: this.consumeConn.particle, slotName: this.consumeConn.name, contentTypes});\n\n      for (let hostedSlot of this._hostedSlotById.values()) {\n        if (hostedSlot.particle) {\n          // Note: hosted particle may still not be set, if the hosted slot was already created, but the inner recipe wasn't instantiate yet.\n          this.startRenderCallback({particle: hostedSlot.particle, slotName: hostedSlot.slotName, contentTypes});\n        }\n      }\n    }\n  }\n\n  stopRender() {\n    if (this.stopRenderCallback) {\n      this.stopRenderCallback({particle: this.consumeConn.particle, slotName: this.consumeConn.name});\n\n      for (let hostedSlot of this._hostedSlotById.values()) {\n        this.stopRenderCallback({particle: hostedSlot.particle, slotName: hostedSlot.slotName});\n      }\n    }\n  }\n\n  async populateViewDescriptions() {\n    let descriptions = {};\n    await Promise.all(Object.values(this.consumeConn.particle.connections).map(async viewConn => {\n      if (viewConn.view) {\n        descriptions[`${viewConn.name}.description`] = (await this._arc.description.getHandleDescription(viewConn.view)).toString();\n      }\n    }));\n    return descriptions;\n  }\n\n  addHostedSlot(hostedSlotId, hostedParticleName, hostedSlotName) {\n    assert(hostedSlotId, `Hosted slot ID must be provided`);\n    assert(!this._hostedSlotById.has(hostedSlotId), `Hosted slot ${hostedSlotId} already exists`);\n    this._hostedSlotById.set(hostedSlotId, {slotId: hostedSlotId, particleName: hostedParticleName, slotName: hostedSlotName});\n    return hostedSlotId;\n  }\n  getHostedSlot(hostedSlotId) {\n    return this._hostedSlotById.get(hostedSlotId);\n  }\n  findHostedSlot(hostedParticle, hostedSlotName) {\n    for (let hostedSlot of this._hostedSlotById.values()) {\n      if (hostedSlot.particle == hostedParticle && hostedSlot.slotName == hostedSlotName) {\n        return hostedSlot;\n      }\n    }\n  }\n  initHostedSlot(hostedSlotId, hostedParticle) {\n    let hostedSlot = this.getHostedSlot(hostedSlotId);\n    assert(hostedSlot, `Hosted slot ${hostedSlotId} doesn't exist`);\n    assert(hostedSlot.particleName == hostedParticle.name,\n           `Unexpected particle name ${hostedParticle.name} for slot ${hostedSlotId}; expected: ${hostedSlot.particleName}`);\n    hostedSlot.particle = hostedParticle;\n    if (this.getContext() && this.startRenderCallback) {\n      this.startRenderCallback({particle: hostedSlot.particle, slotName: hostedSlot.slotName, contentTypes: this.constructRenderRequest()});\n    }\n  }\n\n  // absract\n  async setContent(content, handler) {}\n  getInnerContext(slotName) {}\n  constructRenderRequest() {}\n  static findRootSlots(context) { }\n}\n\nexport default Slot;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/slot.js\n// module id = 31\n// module chunks = 0","// @\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\n\nexport default class KeyBase {\n  childKeyForHandle(id) {\n    throw 'NotImplemented';\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/storage/key-base.js\n// module id = 32\n// module chunks = 0","// @\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport assert from '../../platform/assert-web.js';\nimport tracing from '../../tracelib/trace.js';\nimport util from '../recipe/util.js';\n\nexport default class StorageProviderBase {\n  constructor(type, arcId, name, id, key) {\n    assert(id, 'id must be provided when constructing StorageProviders');\n    let trace = tracing.start({cat: 'view', name: 'StorageProviderBase::constructor', args: {type: type.key, name: name}});\n    this._type = type;\n    this._arcId = arcId;\n    this._listeners = new Map();\n    this.name = name;\n    this._version = 0;\n    this.id = id;\n    this.source = null;\n    this._storageKey = key;\n    this._nextLocalID = 0;\n    trace.end();\n  }\n\n  get storageKey() {\n    return this._storageKey;\n  }\n\n  generateID() {\n    return `${this.id}:${this._nextLocalID++}`;\n  }\n\n  generateIDComponents() {\n    return {base: this.id, component: () => this._nextLocalID++};\n  }\n\n  get type() {\n    return this._type;\n  }\n  // TODO: add 'once' which returns a promise.\n  on(kind, callback, target) {\n    assert(target !== undefined, 'must provide a target to register a storage event handler');\n    let scheduler = target._scheduler;\n    assert(scheduler !== undefined, 'must provider a scheduler to register a storage event handler');\n    let listeners = this._listeners.get(kind) || new Map();\n    listeners.set(callback, {version: -Infinity, target, scheduler});\n    this._listeners.set(kind, listeners);\n  }\n\n  _fire(kind, details) {\n    let listenerMap = this._listeners.get(kind);\n    if (!listenerMap || listenerMap.size == 0)\n      return;\n\n    let callTrace = tracing.start({cat: 'view', name: 'StorageProviderBase::_fire', args: {kind, type: this._type.key,\n        name: this.name, listeners: listenerMap.size}});\n\n    // TODO: wire up a target (particle)\n    let eventRecords = new Map();\n\n    for (let [callback, registration] of listenerMap.entries()) {\n      let target = registration.target;\n      if (!eventRecords.has(registration.scheduler))\n        eventRecords.set(registration.scheduler, []);\n      eventRecords.get(registration.scheduler).push({target, callback, kind, details});\n    }\n    eventRecords.forEach((records, scheduler) => scheduler.enqueue(this, records));\n    callTrace.end();\n  }\n\n  _compareTo(other) {\n    let cmp;\n    if ((cmp = util.compareStrings(this.name, other.name)) != 0) return cmp;\n    if ((cmp = util.compareNumbers(this._version, other._version)) != 0) return cmp;\n    if ((cmp = util.compareStrings(this.source, other.source)) != 0) return cmp;\n    if ((cmp = util.compareStrings(this.id, other.id)) != 0) return cmp;\n    return 0;\n  }\n\n  toString(viewTags) {\n    let results = [];\n    let viewStr = [];\n    viewStr.push(`view`);\n    if (this.name) {\n      viewStr.push(`${this.name}`);\n    }\n    viewStr.push(`of ${this.type.toString()}`);\n    if (this.id) {\n      viewStr.push(`'${this.id}'`);\n    }\n    if (viewTags && viewTags.length) {\n      viewStr.push(`${[...viewTags].join(' ')}`);\n    }\n    if (this.source) {\n      viewStr.push(`in '${this.source}'`);\n    }\n    results.push(viewStr.join(' '));\n    if (this.description)\n      results.push(`  description \\`${this.description}\\``);\n    return results.join('\\n');\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/storage/storage-provider-base.js\n// module id = 33\n// module chunks = 0","// @\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\n\nimport InMemoryStorage from './in-memory-storage.js';\nimport FirebaseStorage from './firebase-storage.js';\n\nexport default class StorageProviderFactory {\n  constructor(arcId) {\n    this._arcId = arcId;\n    this._storageInstances = {'in-memory': new InMemoryStorage(arcId), 'firebase': new FirebaseStorage(arcId)};\n  }\n\n  _storageForKey(key) {\n    let protocol = key.split(':')[0];\n    return this._storageInstances[protocol];\n  }\n\n  async construct(id, type, keyFragment) {\n    return this._storageForKey(keyFragment).construct(id, type, keyFragment);\n  }\n\n  async connect(id, type, key) {\n    return this._storageForKey(key).connect(id, type, key);\n  }\n\n  parseStringAsKey(string) {\n    return this._storageForKey(string).parseStringAsKey(string);\n  }\n\n  newKey(id, associatedKeyFragment) {\n\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/storage/storage-provider-factory.js\n// module id = 34\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport assert from '../platform/assert-web.js';\nimport DomParticle from './dom-particle.js';\n\n// Regex to separate style and template.\nlet re = /<style>((?:.|[\\r\\n])*)<\\/style>((?:.|[\\r\\n])*)/;\n\n/** @class TransformationDomParticle\n * Particle that does transformation stuff with DOM.\n */\nclass TransformationDomParticle extends DomParticle {\n  getTemplate(slotName) {\n    return this._state.template;\n  }\n  _render(props, state) {\n    return state.renderModel;\n  }\n  _shouldRender(props, state) {\n    return Boolean(state.template && state.renderModel);\n  }\n\n  renderHostedSlot(slotName, hostedSlotId, content) {\n    this.combineHostedTemplate(slotName, hostedSlotId, content);\n    this.combineHostedModel(slotName, hostedSlotId, content);\n  }\n\n  // abstract\n  combineHostedTemplate(slotName, hostedSlotId, content) {}\n  combineHostedModel(slotName, hostedSlotId, content) {}\n\n  // Helper methods that may be reused in transformation particles to combine hosted content.\n  static combineTemplates(transformationTemplate, hostedTemplate) {\n    let transformationMatch = transformationTemplate.match(re);\n    if (!transformationMatch || transformationMatch.length != 3) {\n      return;\n    }\n    let hostedMatch = hostedTemplate.match(re);\n    if (!hostedMatch || hostedMatch.length != 3) {\n      return;\n    }\n\n    return `\n      <style>${transformationMatch[1].trim()}${hostedMatch[1].trim()}</style>\n      ${transformationMatch[2].trim().replace('{{hostedParticle}}', hostedMatch[2].trim())}\n    `;\n  }\n  static propsToItems(propsValues) {\n    return propsValues ? propsValues.map(({rawData, id}) => Object.assign({}, rawData, {subId: id})) : [];\n  }\n}\n\nexport default TransformationDomParticle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/transformation-dom-particle.js\n// module id = 35\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\n\nclass TypeVariable {\n  constructor(name, id) {\n    this.name = name;\n    this.id = id;\n    this.resolution = null;\n  }\n\n  toLiteral() {\n    return this;\n  }\n\n  static fromLiteral(data) {\n    return new TypeVariable(data.name, data.id);\n  }\n\n  get isResolved() {\n    return !!this.resolution;\n  }\n\n  resolve(type) {\n    this.resolution = type;\n  }\n\n  equals(other) {\n    if (this.isResolved && other.isResolved) {\n      return this.resolution.equals(other.resolution);\n    }\n    return this.name == other.name;\n  }\n}\n\nexport default TypeVariable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/type-variable.js\n// module id = 36\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport Loader from '../../../arcs/runtime/loader.js';\nimport particle from '../../../arcs/runtime/particle.js';\nimport DomParticle from '../../../arcs/runtime/dom-particle.js';\nimport TransformationDomParticle from '../../../arcs/runtime/transformation-dom-particle.js';\n\nconst logFactory = (preamble, color, log='log') => console[log].bind(console, `Ptcl:%c${preamble}`, `background: ${color}; color: white; padding: 1px 6px 2px 7px; border-radius: 4px;`);\nconst html = (strings, ...values) => (strings[0] + values.map((v, i) => v + strings[i + 1]).join('')).trim();\nconst dumbCache = {};\n\nexport default class BrowserLoader extends Loader {\n  constructor(urlMap) {\n    super();\n    this._urlMap = urlMap;\n  }\n  _loadURL(url) {\n    const resource = dumbCache[url];\n    if (resource) {\n      //console.warn('dumbCache hit for', url);\n    }\n    return resource || (dumbCache[url] = super._loadURL(url));\n  }\n  _resolve(path) {\n    //return new URL(path, this._base).href;\n    let url = this._urlMap[path];\n    if (!url && path) {\n      // TODO(sjmiles): inefficient!\n      let macro = Object.keys(this._urlMap).sort((a,b) => b.length - a.length).find(k => path.slice(0, k.length) == k);\n      if (macro) {\n        url = this._urlMap[macro] + path.slice(macro.length);\n      }\n    }\n    url = url || path;\n    //console.log(`browser-cdn-loader: resolve(${path}) = ${url}`);\n    return url;\n  }\n  loadResource(name) {\n    return this._loadURL(this._resolve(name));\n  }\n  requireParticle(fileName) {\n    let path = this._resolve(fileName);\n    // inject path to this particle into the UrlMap,\n    // allows \"foo.js\" particle to invoke `importScripts(resolver('foo/othermodule.js'))`\n    this.mapParticleUrl(path);\n    let result = [];\n    self.defineParticle = function(particleWrapper) {\n      result.push(particleWrapper);\n    };\n    importScripts(path);\n    delete self.defineParticle;\n    return this.unwrapParticle(result[0], logFactory(fileName.split('/').pop(), 'blue'));\n  }\n  mapParticleUrl(path) {\n    let parts = path.split('/');\n    let suffix = parts.pop();\n    let folder = parts.join('/');\n    let name = suffix.split('.').shift();\n    this._urlMap[name] = folder;\n  }\n  unwrapParticle(particleWrapper, log) {\n    // TODO(sjmiles): regarding `resolver`:\n    //  _resolve method allows particles to request remapping of assets paths\n    //  for use in DOM\n    let resolver = this._resolve.bind(this);\n    return particleWrapper({particle, Particle: particle.Particle, DomParticle, TransformationDomParticle, resolver, log, html});\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./source/browser-cdn-loader.js\n// module id = 37\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport runtime from './runtime.js';\nimport assert from '../platform/assert-web.js';\nimport tracing from '../tracelib/trace.js';\nimport Type from './type.js';\nimport Relation from './relation.js';\nimport handle from './handle.js';\nimport OuterPec from './outer-PEC.js';\nimport Recipe from './recipe/recipe.js';\nimport Manifest from './manifest.js';\nimport Description from './description.js';\nimport util from './recipe/util.js';\nimport FakePecFactory from './fake-pec-factory.js';\nimport StorageProviderFactory from './storage/storage-provider-factory.js';\nimport scheduler from './scheduler.js';\nimport {registerArc} from '../devtools/shared/arc-registry.js';\n\nclass Arc {\n  constructor({id, context, pecFactory, slotComposer, loader, storageKey}) {\n    // TODO: context should not be optional.\n    this._context = context || new Manifest({id});\n    // TODO: pecFactory should not be optional. update all callers and fix here.\n    this._pecFactory = pecFactory || FakePecFactory.bind(null);\n    this.id = id;\n    this._nextLocalID = 0;\n    this._activeRecipe = new Recipe();\n    // TODO: rename: this are just tuples of {particles, handles, slots} of instantiated recipes merged into active recipe..\n    this._recipes = [];\n    this._loader = loader;\n    this._scheduler = scheduler;\n\n    // All the handles, mapped by handle ID\n    this._handlesById = new Map();\n    // .. and mapped by Type\n    this._handlesByType = new Map();\n\n    // information about last-seen-versions of handles\n    this._lastSeenVersion = new Map();\n\n    // storage keys for referenced handles\n    this._storageKeys = {};\n    this._storageKey = storageKey;\n\n    this.particleHandleMaps = new Map();\n    let pecId = this.generateID();\n    let innerPecPort = this._pecFactory(pecId);\n    this.pec = new OuterPec(innerPecPort, slotComposer, this, `${pecId}:outer`);\n    if (slotComposer) {\n      slotComposer.arc = this;\n    }\n    this._storageProviderFactory = new StorageProviderFactory(this.id);\n\n    // Dictionary from each tag string to a list of handles\n    this._tags = {};\n    // Map from each handle to a list of tags.\n    this._handleTags = new Map();\n    // Map from each handle to its description (originating in the manifest).\n    this._handleDescriptions = new Map();\n\n    this._search = null;\n    this._description = new Description(this);\n\n    registerArc(this);\n  }\n  get loader() {\n    return this._loader;\n  }\n\n  get scheduler() {\n    return this._scheduler;\n  }\n\n  set search(search) {\n    this._search = search ? search.toLowerCase().trim() : null;\n  }\n\n  get search() {\n    return this._search;\n  }\n\n  get description() { return this._description; }\n\n  get makeSuggestions() { return this._makeSuggestions; }\n  set makeSuggestions(callback) {\n    this._makeSuggestions = callback;\n    this._scheduler.idleCallback = callback;\n  }\n\n  serialize() {\n    return `\nmeta\n  name: '${this.id}'\n\n@active\n${this.activeRecipe.toString()}`;\n  }\n\n  static async deserialize({serialization, pecFactory, slotComposer, loader}) {\n    let manifest = await Manifest.parse(serialization, {loader});\n    let arc = new Arc({id: manifest.meta.name, slotComposer, pecFactory, loader});\n    let recipe = manifest.activeRecipe.clone();\n    recipe.normalize();\n    arc.instantiate(recipe);\n    return arc;\n  }\n\n  get context() {\n    return this._context;\n  }\n\n  get activeRecipe() { return this._activeRecipe; }\n  get recipes() { return this._recipes; }\n\n  loadedParticles() {\n    return [...this.particleHandleMaps.values()].map(({spec}) => spec);\n  }\n\n  _instantiateParticle(recipeParticle) {\n    let id = this.generateID();\n    let handleMap = {spec: recipeParticle.spec, handles: new Map()};\n    this.particleHandleMaps.set(id, handleMap);\n\n    for (let [name, connection] of Object.entries(recipeParticle.connections)) {\n      if (!connection.view) {\n        assert(connection.isOptional);\n        continue;\n      }\n      let handle = this.findHandleById(connection.view.id);\n      assert(handle);\n      this._connectParticleToHandle(id, recipeParticle, name, handle);\n    }\n\n    // At least all non-optional connections must be resolved\n    assert(handleMap.handles.size >= handleMap.spec.connections.filter(c => !c.isOptional).length,\n           `Not all mandatory connections are resolved for {$particle}`);\n    this.pec.instantiate(recipeParticle, id, handleMap.spec, handleMap.handles, this._lastSeenVersion);\n    recipeParticle._scheduler = this.scheduler;\n    return id;\n  }\n\n  generateID() {\n    return `${this.id}:${this._nextLocalID++}`;\n  }\n\n  generateIDComponents() {\n    return {base: this.id, component: () => this._nextLocalID++};\n  }\n\n  get _handles() {\n    return [...this._handlesById.values()];\n  }\n\n  // Makes a copy of the arc used for speculative execution.\n  async cloneForSpeculativeExecution() {\n    let arc = new Arc({id: this.generateID(), pecFactory: this._pecFactory, context: this.context, loader: this._loader});\n    arc._scheduler = this._scheduler.clone();\n    let handleMap = new Map();\n    for (let handle of this._handles) {\n      let clone = await arc._storageProviderFactory.construct(handle.id, handle.type, 'in-memory');\n      await clone.cloneFrom(handle);\n      handleMap.set(handle, clone);\n      if (this._handleDescriptions.has(handle)) {\n        arc._handleDescriptions.set(clone, this._handleDescriptions.get(handle));\n      }\n    };\n    this.particleHandleMaps.forEach((value, key) => {\n      arc.particleHandleMaps.set(key, {\n        spec: value.spec,\n        handles: new Map()\n      });\n      value.handles.forEach(handle => arc.particleHandleMaps.get(key).handles.set(handle.name, handleMap.get(handle)));\n    });\n\n   let {particles, views, slots} = this._activeRecipe.mergeInto(arc._activeRecipe);\n   let particleIndex = 0, viewIndex = 0, slotIndex = 0;\n   this._recipes.forEach(recipe => {\n     let arcRecipe = {particles: [], views: [], slots: [], innerArcs: new Map()};\n     recipe.particles.forEach(p => {\n       arcRecipe.particles.push(particles[particleIndex++]);\n       if (recipe.innerArcs.has(p)) {\n         let thisInnerArc = recipe.innerArcs.get(p);\n         let transformationParticle = arcRecipe.particles[arcRecipe.particles.length - 1];\n         let innerArc = {activeRecipe: new Recipe(), recipes: []};\n         let innerTuples = thisInnerArc.activeRecipe.mergeInto(innerArc.activeRecipe);\n         thisInnerArc.recipes.forEach(thisInnerArcRecipe => {\n           let innerArcRecipe = {particles: [], views: [], slots: [], innerArcs: new Map()};\n           let innerIndex = 0;\n           thisInnerArcRecipe.particles.forEach(thisInnerArcRecipeParticle => {\n             innerArcRecipe.particles.push(innerTuples.particles[innerIndex++]);\n           });\n           innerIndex = 0;\n           thisInnerArcRecipe.views.forEach(thisInnerArcRecipeParticle => {\n             innerArcRecipe.views.push(innerTuples.views[innerIndex++]);\n           });\n           innerIndex = 0;\n           thisInnerArcRecipe.slots.forEach(thisInnerArcRecipeParticle => {\n             innerArcRecipe.slots.push(innerTuples.slots[innerIndex++]);\n           });\n           innerArc.recipes.push(innerArcRecipe);\n         });\n         arcRecipe.innerArcs.set(transformationParticle, innerArc);\n       }\n     });\n     recipe.views.forEach(p => {\n       arcRecipe.views.push(views[viewIndex++]);\n     });\n     recipe.slots.forEach(p => {\n       arcRecipe.slots.push(slots[slotIndex++]);\n     });\n\n     arc._recipes.push(arcRecipe);\n   });\n\n    for (let v of handleMap.values()) {\n      // FIXME: Tags\n      arc._registerHandle(v, []);\n    }\n    return arc;\n  }\n\n  async instantiate(recipe, innerArc) {\n    assert(recipe.isResolved(), 'Cannot instantiate an unresolved recipe');\n\n    let currentArc = {activeRecipe: this._activeRecipe, recipes: this._recipes};\n    if (innerArc) {\n      let innerArcs = this._recipes.find(r => !!r.particles.find(p => p == innerArc.particle)).innerArcs;\n      if (!innerArcs.has(innerArc.particle)) {\n         innerArcs.set(innerArc.particle, {activeRecipe: new Recipe(), recipes: []});\n      }\n      currentArc = innerArcs.get(innerArc.particle);\n    }\n    let {views, particles, slots} = recipe.mergeInto(currentArc.activeRecipe);\n    currentArc.recipes.push({particles, views, slots, innerArcs: new Map()});\n\n    for (let recipeView of views) {\n      if (['copy', 'create'].includes(recipeView.fate)) {\n        let view = await this.createHandle(recipeView.type, /* name= */ null, this.generateID(), recipeView.tags);\n        if (recipeView.fate === 'copy') {\n          let copiedView = this.findHandleById(recipeView.id);\n          await view.cloneFrom(copiedView);\n          let copiedViewDesc = this.getHandleDescription(copiedView);\n          if (copiedViewDesc) {\n            this._handleDescriptions.set(view, copiedViewDesc);\n          }\n        }\n        recipeView.id = view.id;\n        recipeView.fate = 'use';\n        recipeView.storageKey = view.storageKey;\n        // TODO: move the call to OuterPEC's DefineView to here\n      }\n      let storageKey = recipeView.storageKey;\n      if (!storageKey)\n        storageKey = this.keyForId(recipeView.id);\n      assert(storageKey, `couldn't find storage key for view '${recipeView}'`);\n      let view = await this._storageProviderFactory.connect(recipeView.id, recipeView.type, storageKey);\n      assert(view, `view '${recipeView.id}' was not found`);\n    }\n\n    particles.forEach(recipeParticle => this._instantiateParticle(recipeParticle));\n\n    if (this.pec.slotComposer) {\n      // TODO: pass slot-connections instead\n      this.pec.slotComposer.initializeRecipe(particles);\n    }\n  }\n\n  _connectParticleToHandle(particleId, particle, name, targetHandle) {\n    assert(targetHandle, 'no target handle provided');\n    let handleMap = this.particleHandleMaps.get(particleId);\n    assert(handleMap.spec.connectionMap.get(name) !== undefined, 'can\\'t connect handle to a view slot that doesn\\'t exist');\n    handleMap.handles.set(name, targetHandle);\n  }\n\n  async createHandle(type, name, id, tags, storageKey) {\n    assert(type instanceof Type, `can't createHandle with type ${type} that isn't a Type`);\n\n    if (type.isRelation) {\n      type = Type.newSetView(type);\n    }\n\n    if (id == undefined)\n      id = this.generateID();\n\n    if (storageKey == undefined && this._storageKey)\n      storageKey = this._storageProviderFactory.parseStringAsKey(this._storageKey).childKeyForHandle(id).toString();\n\n    if (storageKey == undefined)\n      storageKey = 'in-memory';\n\n    let handle = await this._storageProviderFactory.construct(id, type, storageKey);\n    assert(handle, 'handle with id ${id} already exists');\n    handle.name = name;\n\n    this._registerHandle(handle, tags);\n    return handle;\n  }\n\n  _registerHandle(handle, tags) {\n    tags = tags || [];\n    tags = Array.isArray(tags) ? tags : [tags];\n    tags.forEach(tag => assert(tag.startsWith('#'),\n      `tag ${tag} must start with '#'`));\n\n    this._handlesById.set(handle.id, handle);\n    let byType = this._handlesByType.get(Arc._viewKey(handle.type)) || [];\n    byType.push(handle);\n    this._handlesByType.set(Arc._viewKey(handle.type), byType);\n\n    if (tags.length) {\n      for (let tag of tags) {\n        if (this._tags[tag] == undefined)\n          this._tags[tag] = [];\n        this._tags[tag].push(handle);\n      }\n    }\n    this._handleTags.set(handle, new Set(tags));\n\n    this._storageKeys[handle.id] = handle.storageKey;\n  }\n\n  // TODO: Don't use this, we should be testing the schemas for compatiblity\n  //       instead of using just the name.\n  static _viewKey(type) {\n    if (type.isSetView) {\n      return `list:${type.primitiveType().entitySchema.name}`;\n    } else if (type.isEntity) {\n      return type.entitySchema.name;\n    } else if (type.isShape) {\n      // TODO we need to fix this too, otherwise all views of shape type will\n      // be of the 'same type' when searching by type.\n      return type.shapeShape;\n    }\n  }\n\n  findHandlesByType(type, options) {\n    // TODO: use options (location, labels, etc.) somehow.\n    let views = this._handlesByType.get(Arc._viewKey(type)) || [];\n    if (options && options.tags) {\n      views = views.filter(view => options.tags.filter(tag => !this._handleTags.get(view).has(tag)).length == 0);\n    }\n    return views;\n  }\n\n  findHandleById(id) {\n    let handle = this._handlesById.get(id);\n    if (handle == null) {\n      handle = this._context.findHandleById(id);\n    }\n    return handle;\n  }\n\n  getHandleDescription(handle) {\n    assert(handle, 'Cannot fetch description for nonexistent handle');\n    return this._handleDescriptions.get(handle) || handle.description;\n  }\n\n  keyForId(id) {\n    return this._storageKeys[id];\n  }\n\n  newCommit(entityMap) {\n    for (let [entity, handle] of entityMap.entries()) {\n      entity.identify(this.generateID());\n    }\n    for (let [entity, handle] of entityMap.entries()) {\n      new handle.handleFor(handle).store(entity);\n    }\n  }\n\n  stop() {\n    this.pec.stop();\n  }\n\n  toContextString(options) {\n    let results = [];\n    let handles = [...this._handlesById.values()].sort(util.compareComparables);\n    handles.forEach(v => {\n      results.push(v.toString(this._handleTags.get(v)));\n    });\n\n    // TODO: include handles entities\n    // TODO: include (remote) slots?\n\n    if (!this._activeRecipe.isEmpty()) {\n      results.push(this._activeRecipe.toString());\n    }\n\n    return results.join('\\n');\n  }\n\n  initDebug() {\n    this.pec.initDebug();\n  }\n}\n\nexport default Arc;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/arc.js\n// module id = 38\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {Strategy, Strategizer} from '../strategizer/strategizer.js';\nimport assert from '../platform/assert-web.js';\nimport Recipe from './recipe/recipe.js';\nimport RecipeUtil from './recipe/recipe-util.js';\nimport RecipeWalker from './recipe/walker.js';\nimport ConvertConstraintsToConnections from './strategies/convert-constraints-to-connections.js';\nimport AssignRemoteViews from './strategies/assign-remote-views.js';\nimport CopyRemoteViews from './strategies/copy-remote-views.js';\nimport AssignViewsByTagAndType from './strategies/assign-views-by-tag-and-type.js';\nimport InitPopulation from './strategies/init-population.js';\nimport MapConsumedSlots from './strategies/map-consumed-slots.js';\nimport MapRemoteSlots from './strategies/map-remote-slots.js';\nimport MatchParticleByVerb from './strategies/match-particle-by-verb.js';\nimport NameUnnamedConnections from './strategies/name-unnamed-connections.js';\nimport AddUseViews from './strategies/add-use-views.js';\nimport CreateDescriptionHandle from './strategies/create-description-handle.js';\nimport Manifest from './manifest.js';\nimport InitSearch from './strategies/init-search.js';\nimport SearchTokensToParticles from './strategies/search-tokens-to-particles.js';\nimport FallbackFate from './strategies/fallback-fate.js';\nimport GroupHandleConnections from './strategies/group-handle-connections.js';\nimport CombinedStrategy from './strategies/combined-strategy.js';\n\nimport Speculator from './speculator.js';\nimport Description from './description.js';\nimport Tracing from '../tracelib/trace.js';\n\nclass CreateViews extends Strategy {\n  // TODO: move generation to use an async generator.\n  async generate(strategizer) {\n    let results = Recipe.over(this.getResults(strategizer), new class extends RecipeWalker {\n      onView(recipe, view) {\n        let counts = RecipeUtil.directionCounts(view);\n\n        let score = 1;\n        if (counts.in == 0 || counts.out == 0) {\n          if (counts.unknown > 0)\n            return;\n          if (counts.in == 0)\n            score = -1;\n          else\n            score = 0;\n        }\n\n        if (!view.id && view.fate == '?') {\n          return (recipe, view) => {view.fate = 'create'; return score;};\n        }\n      }\n    }(RecipeWalker.Permuted), this);\n\n    return {results, generate: null};\n  }\n}\n\n\nclass Planner {\n  // TODO: Use context.arc instead of arc\n  init(arc) {\n    this._arc = arc;\n    let strategies = [\n      new InitPopulation(arc),\n      new InitSearch(arc),\n      new CombinedStrategy([\n        new SearchTokensToParticles(arc),\n        new GroupHandleConnections(),\n      ]),\n      new FallbackFate(),\n      new CreateViews(),\n      new AssignViewsByTagAndType(arc),\n      new ConvertConstraintsToConnections(arc),\n      new MapConsumedSlots(),\n      new AssignRemoteViews(arc),\n      new CopyRemoteViews(arc),\n      new MapRemoteSlots(arc),\n      new MatchParticleByVerb(arc),\n      new NameUnnamedConnections(arc),\n      new AddUseViews(),\n      new CreateDescriptionHandle(),\n    ];\n    this.strategizer = new Strategizer(strategies, [], {\n      maxPopulation: 100,\n      generationSize: 100,\n      discardSize: 20,\n    });\n  }\n\n  async generate() {\n    let log = await this.strategizer.generate();\n    return this.strategizer.generated;\n  }\n\n  async plan(timeout, generations) {\n    let trace = Tracing.async({cat: 'planning', name: 'Planner::plan', args: {timeout}});\n    timeout = timeout || NaN;\n    let allResolved = [];\n    let now = () => (typeof performance == 'object') ? performance.now() : process.hrtime();\n    let start = now();\n    do {\n      let generated = await trace.wait(() => this.generate());\n      trace.resume({args: {\n        generated: this.strategizer.generated.length,\n      }});\n      if (generations) {\n        generations.push(generated);\n      }\n\n      let resolved = this.strategizer.generated\n          .map(individual => individual.result)\n          .filter(recipe => recipe.isResolved());\n      allResolved.push(...resolved);\n      if (now() - start > timeout) {\n        console.warn('Planner.plan timed out.');\n        break;\n      }\n    } while (this.strategizer.generated.length > 0);\n    trace.end();\n    return allResolved;\n  }\n\n  _matchesActiveRecipe(plan) {\n    let planShape = RecipeUtil.recipeToShape(plan);\n    let result = RecipeUtil.find(this._arc._activeRecipe, planShape);\n    return result.some(r => r.score == 0);\n  }\n\n  async suggest(timeout, generations) {\n    let trace = Tracing.async({cat: 'planning', name: 'Planner::suggest', args: {timeout}});\n    let plans = await trace.wait(() => this.plan(timeout, generations));\n    trace.resume();\n    let suggestions = [];\n    let speculator = new Speculator();\n    // TODO: Run some reasonable number of speculations in parallel.\n    let results = [];\n    for (let plan of plans) {\n      let hash = ((hash) => { return hash.substring(hash.length - 4);})(await plan.digest());\n\n      if (this._matchesActiveRecipe(plan)) {\n        this._updateGeneration(generations, hash, (g) => g.active = true);\n        continue;\n      }\n\n      let relevance = await trace.wait(() => speculator.speculate(this._arc, plan));\n      trace.resume();\n      if (!relevance.isRelevant(plan)) {\n        continue;\n      }\n      let rank = relevance.calcRelevanceScore();\n\n      relevance.newArc.description.relevance = relevance;\n      let description = await relevance.newArc.description.getRecipeSuggestion();\n\n      this._updateGeneration(generations, hash, (g) => g.description = description);\n\n      // TODO: Move this logic inside speculate, so that it can stop the arc\n      // before returning.\n      relevance.newArc.stop();\n\n      // Filter plans based on arc._search string.\n      if (this._arc.search) {\n        if (!plan.search) {\n          // This plan wasn't constructed based on the provided search terms.\n          if (description.toLowerCase().indexOf(arc.search) < 0) {\n            // Description must contain the full search string.\n            // TODO: this could be a strategy, if description was already available during strategies execution.\n            continue;\n          }\n        } else {\n          // This mean the plan was constructed based on provided search terms,\n          // and at least one of them were resolved (in order for the plan to be resolved).\n        }\n      }\n\n      results.push({\n        plan,\n        rank,\n        description: relevance.newArc.description,\n        descriptionText: description, // TODO(mmandlis): exclude the text description from returned results.\n        hash\n      });\n    }\n    trace.end();\n    return results;\n  }\n  _updateGeneration(generations, hash, handler) {\n    if (generations) {\n      generations.forEach(g => {\n        g.forEach(gg => {\n          if (gg.hash.endsWith(hash)) {\n            handler(gg);\n          }\n        });\n      });\n    }\n  }\n}\n\nexport default Planner;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/planner.js\n// module id = 39\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport assert from '../platform/assert-web.js';\nimport Slot from './slot.js';\nimport DomSlot from './dom-slot.js';\nimport {DomContext} from './dom-context.js';\nimport DescriptionDomFormatter from './description-dom-formatter.js';\n\nclass SlotComposer {\n  constructor(options) {\n    assert(options.affordance, 'Affordance is mandatory');\n    assert(options.rootContext, 'Root context is mandatory');\n\n    this._containerKind = options.containerKind;\n    this._affordance = options.affordance;\n    this._slotClass = this.getSlotClass();\n    assert(this._slotClass);\n\n    this._contextById = this._slotClass.findRootSlots(options.rootContext) || {};\n    if (Object.keys(this._contextById).length == 0) {\n      // fallback to single 'root' slot using the rootContext.\n      this._contextById['root'] = options.rootContext;\n    }\n\n    this._suggestionsContext = options.suggestionsContext || this._contextById['suggestions'];\n\n    this._slots = [];\n  }\n  get affordance() { return this._affordance; }\n  getSlotClass() {\n    switch (this._affordance) {\n      case 'dom':\n      case 'dom-touch':\n      case 'vr':\n        return DomSlot;\n      case 'mock':\n        return Slot;\n      default:\n        assert('unsupported affordance ', this._affordance);\n    }\n  }\n  _getSuggestionContext() {\n    switch (this._affordance) {\n      case 'dom':\n      case 'dom-touch':\n      case 'vr':\n        return DomContext;\n      default:\n        assert('unsupported affordance ', this._affordance);\n    }\n  }\n  _getDescriptionFormatter() {\n    switch (this._affordance) {\n      case 'dom':\n      case 'dom-touch':\n      case 'vr':\n        return DescriptionDomFormatter;\n      default:\n        assert('unsupported affordance ', this._affordance);\n    }\n  }\n\n  async setSuggestions(suggestions) {\n    // TODO(mmandlis): slot composer should not be familiar with suggestions concept - they should just be slots.\n    if (!this._suggestionsContext) {\n      return;\n    }\n\n    this._suggestionsContext.textContent = '';\n\n    suggestions.forEach(async suggestion => {\n      let suggestionContent =\n        await suggestion.description.getRecipeSuggestion(this._getDescriptionFormatter());\n\n      if (!suggestionContent) {\n        suggestionContent = 'No suggestion content was generated (unnamed recipe and no describable particles)';\n      }\n\n      this._getSuggestionContext().createContext(\n          this.createSuggestionElement(this._suggestionsContext, suggestion),\n          suggestionContent\n      );\n    });\n  }\n\n  createSuggestionElement(container, plan) {\n    let suggest = Object.assign(document.createElement('suggestion-element'), {plan});\n    // TODO(sjmiles): LIFO is weird, iterate top-down elsewhere?\n    container.insertBefore(suggest, container.firstElementChild);\n    return suggest;\n  }\n\n  getSlot(particle, slotName) {\n    return this._slots.find(s => s.consumeConn.particle == particle && s.consumeConn.name == slotName);\n  }\n\n  createHostedSlot(transformationParticle, transformationSlotName, hostedParticleName, hostedSlotName) {\n    let hostedSlotId = this.arc.generateID();\n\n    let transformationSlot = this.getSlot(transformationParticle, transformationSlotName);\n    assert(transformationSlot,\n           `Unexpected transformation slot particle ${transformationParticle.name}:${transformationSlotName}, hosted particle ${hostedParticleName}, slot name ${hostedSlotName}`);\n    transformationSlot.addHostedSlot(hostedSlotId, hostedParticleName, hostedSlotName);\n    return hostedSlotId;\n  }\n  _findSlotByHostedSlotId(hostedSlotId) {\n    for (let slot of this._slots) {\n      let hostedSlot = slot.getHostedSlot(hostedSlotId);\n      if (hostedSlot) {\n        return slot;\n      }\n    }\n  }\n  findHostedSlot(hostedParticle, hostedSlotName) {\n    for (let slot of this._slots) {\n      let hostedSlot = slot.findHostedSlot(hostedParticle, hostedSlotName);\n      if (hostedSlot) {\n        return hostedSlot;\n      }\n    }\n  }\n\n  initializeRecipe(recipeParticles) {\n    let newSlots = [];\n    // Create slots for each of the recipe's particles slot connections.\n    recipeParticles.forEach(p => {\n      Object.values(p.consumedSlotConnections).forEach(cs => {\n        assert(cs.targetSlot, `No target slot for particle's ${p.name} consumed slot: ${cs.name}.`);\n\n        if (this._initHostedSlot(cs.targetSlot.id, p)) {\n          // Skip slot creation for hosted slots.\n          return;\n        }\n\n        let slot = new this._slotClass(cs, this.arc, this._containerKind);\n        slot.startRenderCallback = this.arc.pec.startRender.bind(this.arc.pec);\n        slot.stopRenderCallback = this.arc.pec.stopRender.bind(this.arc.pec);\n        slot.innerSlotsUpdateCallback = this.updateInnerSlots.bind(this);\n        newSlots.push(slot);\n      });\n    });\n\n    // Attempt to set context for each of the slots.\n    newSlots.forEach(s => {\n      assert(!s.getContext(), `Unexpected context in new slot`);\n\n      let context = null;\n      let sourceConnection = s.consumeConn.targetSlot && s.consumeConn.targetSlot.sourceConnection;\n      if (sourceConnection) {\n        let sourceConnSlot = this.getSlot(sourceConnection.particle, sourceConnection.name);\n        if (sourceConnSlot) {\n          context = sourceConnSlot.getInnerContext(s.consumeConn.name);\n        }\n      } else { // External slots provided at SlotComposer ctor (eg 'root')\n        context = this._contextById[s.consumeConn.name];\n      }\n\n      this._slots.push(s);\n\n      if (context) {\n        s.updateContext(context);\n      }\n    });\n  }\n\n  _initHostedSlot(hostedSlotId, hostedParticle) {\n    let transformationSlot = this._findSlotByHostedSlotId(hostedSlotId);\n    if (!transformationSlot) {\n      return false;\n    }\n    transformationSlot.initHostedSlot(hostedSlotId, hostedParticle);\n    return true;\n  }\n\n  async renderSlot(particle, slotName, content) {\n    let slot = this.getSlot(particle, slotName);\n    if (slot) {\n      // Set the slot's new content.\n      await slot.setContent(content, eventlet => {\n        this.arc.pec.sendEvent(particle, slotName, eventlet);\n      });\n      return;\n    }\n\n    if (this._renderHostedSlot(particle, slotName, content)) {\n      return;\n    }\n\n    assert(slot, `Cannot find slot (or hosted slot) ${slotName} for particle ${particle.name}`);\n  }\n\n  _renderHostedSlot(particle, slotName, content) {\n    let hostedSlot = this.findHostedSlot(particle, slotName);\n    if (!hostedSlot) {\n      return false;\n    }\n    let transformationSlot = this._findSlotByHostedSlotId(hostedSlot.slotId);\n    assert(transformationSlot, `No transformation slot found for ${hostedSlot.slotId}`);\n\n    this.arc.pec.innerArcRender(transformationSlot.consumeConn.particle, transformationSlot.consumeConn.name, hostedSlot.slotId, content);\n\n    return true;\n  }\n\n  updateInnerSlots(slot) {\n    assert(slot, 'Cannot update inner slots of null');\n    // Update provided slot contexts.\n    Object.keys(slot.consumeConn.providedSlots).forEach(providedSlotName => {\n      let providedContext = slot.getInnerContext(providedSlotName);\n      let providedSlot = slot.consumeConn.providedSlots[providedSlotName];\n      providedSlot.consumeConnections.forEach(cc => {\n        // This will trigger 'start' or 'stop' render, if applicable.\n        this.getSlot(cc.particle, cc.name).updateContext(providedContext);\n      });\n    });\n  }\n\n  getAvailableSlots() {\n    let availableSlots = {};\n    this._slots.forEach(slot => {\n      assert(slot.consumeConn.targetSlot);\n      Object.values(slot.consumeConn.providedSlots).forEach(ps => {\n        if (!availableSlots[ps.name]) {\n          availableSlots[ps.name] = [];\n        }\n        let psId = ps.id || `slotid-${this.arc.generateID()}`;\n        ps.id = psId;\n        let providedSlotSpec = slot.consumeConn.slotSpec.providedSlots.find(psSpec => psSpec.name == ps.name);\n        availableSlots[ps.name].push({\n          id: psId,\n          count: ps.consumeConnections.length,\n          providedSlotSpec,\n          views: ps.handleConnections.map(hc => hc.view)\n        });\n      });\n    });\n\n    Object.keys(this._contextById).forEach(slotid => {\n      if (!availableSlots[slotid]) {\n        availableSlots[slotid] = [];\n      }\n      availableSlots[slotid].push({id: `rootslotid-${slotid}`, count: 0, views: [], providedSlotSpec: {isSet: false}});\n    });\n    return availableSlots;\n  }\n}\n\nexport default SlotComposer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/slot-composer.js\n// module id = 40\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport Arc from '../../../arcs/runtime/arc.js';\nimport Description from '../../../arcs/runtime/description.js';\nimport Manifest from '../../../arcs/runtime/manifest.js';\nimport Planner from '../../../arcs/runtime/planner.js';\nimport SlotComposer from '../../../arcs/runtime/slot-composer.js';\nimport Type from '../../../arcs/runtime/type.js';\nimport BrowserLoader from './browser-cdn-loader.js';\nimport Tracing from '../../../arcs/tracelib/trace.js';\nimport scheduler from '../../../arcs/runtime/scheduler.js';\n\n//Tracing.enable();\n\nwindow.Arcs = {\n  version: '0.3',\n  Arc,\n  Description,\n  Manifest,\n  Planner,\n  SlotComposer,\n  Type,\n  BrowserLoader,\n  Tracing,\n  scheduler\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./source/ArcsLib.js\n// module id = 41\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nlet supportedTypes = ['Text', 'URL', 'Number', 'Boolean'];\n\nclass JsonldToManifest {\n  static convert(jsonld, theClass) {\n    let obj = JSON.parse(jsonld);\n    let classes = {};\n    let properties = {};\n\n    if (!obj['@graph']) {\n      obj['@graph'] = [obj];\n    }\n\n    for (let item of obj['@graph']) {\n      if (item['@type'] == 'rdf:Property')\n        properties[item['@id']] = item;\n      else if (item['@type'] == 'rdfs:Class') {\n        classes[item['@id']] = item;\n        item.subclasses = [];\n        item.superclass = null;\n      }\n    }\n\n    for (let clazz of Object.values(classes)) {\n      if (clazz['rdfs:subClassOf'] !== undefined) {\n        if (clazz['rdfs:subClassOf'].length == undefined)\n          clazz['rdfs:subClassOf'] = [clazz['rdfs:subClassOf']];\n        for (let subClass of clazz['rdfs:subClassOf']) {\n          let superclass = subClass['@id'];\n          if (clazz.superclass == undefined)\n            clazz.superclass = [];\n          if (classes[superclass]) {\n            classes[superclass].subclasses.push(clazz);\n            clazz.superclass.push(classes[superclass]);\n          } else {\n            clazz.superclass.push({'@id': superclass});\n          }\n        }\n      }\n    }\n\n    for (let clazz of Object.values(classes)) {\n      if (clazz.subclasses.length == 0 && theClass == undefined) {\n        theClass = clazz;\n      }\n    }\n\n    let relevantProperties = [];\n    for (let property of Object.values(properties)) {\n      let domains = property['schema:domainIncludes'];\n      if (!domains)\n        domains = {'@id': theClass['@id']};\n      if (!domains.length)\n        domains = [domains];\n      domains = domains.map(a => a['@id']);\n      if (domains.includes(theClass['@id'])) {\n        let name = property['@id'].split(':')[1];\n        let type = property['schema:rangeIncludes'];\n        if (!type)\n          console.log(property);\n        if (!type.length)\n          type = [type];\n\n        type = type.map(a => a['@id'].split(':')[1]);\n        type = type.filter(type => supportedTypes.includes(type));\n        if (type.length > 0)\n        relevantProperties.push({name, type});\n      }\n    }\n\n    let className = theClass['@id'].split(':')[1];\n    let superNames = theClass.superclass ? theClass.superclass.map(a => a['@id'].split(':')[1]) : [];\n\n    let s = '';\n    for (let superName of superNames)\n      s += `import 'https://schema.org/${superName}'\\n\\n`;\n\n    s += `schema ${className}`;\n    if (superNames.length > 0)\n      s += ` extends ${superNames.join(', ')}`;\n\n    if (relevantProperties.length > 0) {\n      s += '\\n  optional';\n      for (let property of relevantProperties) {\n        let type;\n        if (property.type.length > 1)\n          type = '(' + property.type.join(' or ') + ')';\n        else\n          type = property.type[0];\n        s += `\\n    ${type} ${property.name}`;\n      }\n    }\n    s += '\\n';\n\n    return s;\n  }\n}\n\nexport default JsonldToManifest;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/converters/jsonldToManifest.js\n// module id = 42\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n// Debugging is initialized either by /devtools/src/run-init-debug.js, which is\n// injected by the devtools extension content script in the browser env,\n// or used directly in when debugging nodeJS.\n// This is why data needs to be referenced via a global object.\n\nlet root = typeof window === 'object' ? window : global;\n\nroot._arcDebugRegistry = root._arcDebugRegistry || {\n  arcList: [],\n  debug: false\n};\n\nlet registry = root._arcDebugRegistry;\n\nfunction initDebug() {\n  if (registry.debug) return;\n  for (let arc of registry.arcList) {\n    arc.initDebug();\n  }\n  delete registry.arcList;\n  registry.debug = true;\n}\n\nfunction registerArc(arc) {\n  if (registry.debug) {\n    arc.initDebug();\n  } else {\n    registry.arcList.push(arc);\n  }\n}\n\nexport {initDebug, registerArc};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/devtools/shared/arc-registry.js\n// module id = 43\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\n// Assume firebase has been loaded. We can't `import` it here as it does not\n// support strict mode.\nexport default window.btoa;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/platform/btoa-web.js\n// module id = 44\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport AbstractDevtoolsChannel from '../runtime/debug/abstract-devtools-channel.js';\n\nexport default class ChromeExtensionChannel extends AbstractDevtoolsChannel {\n  constructor() {\n    super();\n    this._makeReady(); // TODO: Consider readiness if connecting via extension.\n  }\n\n  _flush(messages) {\n    document.dispatchEvent(new CustomEvent('arcs-debug', {detail: messages}));\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/platform/devtools-channel-web.js\n// module id = 45\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\n// Assume firebase has been loaded. We can't `import` it here as it does not\n// support strict mode.\nexport default window.firebase;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/platform/firebase-web.js\n// module id = 46\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nexport default {};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/platform/vm-web.js\n// module id = 47\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n// TODO: Move HTMLElement to platform abstraction.\nlet HTMLElement;\nif (typeof window == 'undefined') {\n  HTMLElement = class HTMLElement {};\n} else {\n  HTMLElement = window.HTMLElement;\n}\n\nexport default class ModelSelect extends HTMLElement {\n  connectedCallback() {\n    this.style.display = 'inline-block';\n    this._requireSelect();\n  }\n  _requireSelect() {\n    return this.select = this.select || this.appendChild(document.createElement('select'));\n  }\n  set options(options) {\n    let select = this._requireSelect();\n    select.textContent = '';\n    options && options.forEach(o =>\n      select.appendChild(\n        Object.assign(document.createElement('option'), {\n          value: o.value || o,\n          text: o.text || o.value || o\n        })\n      )\n    );\n  }\n}\n\nif (typeof customElements != 'undefined') {\n  customElements.define('model-select', ModelSelect);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/browser/lib/model-select.js\n// module id = 48\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport XTemplate from './xen-template.js';\nimport XElement from './xen-element.js';\nimport XState from './xen-state.js';\n\nclass XList extends XState(XElement) {\n  static get observedAttributes() {\n    return ['items', 'template', 'handler', 'render', 'scope'];\n  }\n  _mount() {\n    this._setState({\n      container: this.querySelector('[container]') || this,\n      template: this.querySelector('template')\n    });\n    this.textContent = '';\n  }\n  _update(props, state) {\n    let template = props.template || state.template;\n    if (template) {\n      this._renderList(state.container, template, props);\n    }\n  }\n  _renderList(container, template, props) {\n    // magically plumb eventMapper from an ancestor\n    let p = this;\n    while (!props.eventMapper && p) {\n      props.eventMapper = p._eventMapper;\n      p = p.parentElement;\n    }\n    //console.log('XList::_renderList:', props);\n    let child = container.firstElementChild, next;\n    props.items && props.items.forEach((item, i)=>{\n      // use existing node if possible\n      next = child && child.nextElementSibling;\n      if (!child) {\n        let dom;\n        try {\n          // TODO(sjmiles): install event handlers explicitly now\n          dom = XTemplate.stamp(template).events(props.eventMapper);\n        } catch (x) {\n          console.warn('x-list: if `listen` is undefined, you need to provide a `handler` property for `on-*` events');\n          throw x;\n        }\n        child = dom.root.firstElementChild;\n        if (child) {\n          child._listDom = dom;\n          container.appendChild(dom.root);\n        }\n      }\n      if (child) {\n        // scope aka childProps\n        let scope = Object.create(null);\n        // accumulate scope to implement lexical binding\n        if (props.scope) {\n          Object.assign(scope, props.scope);\n          scope.scope = props;\n        }\n        // TODO(sjmiles): failure to decide if an item is an `item` or an anonymous collection of properties\n        scope.item = item;\n        if (typeof item === 'object') {\n          Object.assign(scope, item);\n        }\n        // list scope\n        scope._items = props.items;\n        scope._itemIndex = i;\n        scope._item = item;\n        // user can supply additional scope processing\n        if (props.render) {\n          Object.assign(scope, props.render(scope));\n        }\n        //console.log('_renderList.scope:', scope);\n        child._listDom.set(scope);\n        child = next;\n      }\n    });\n    // remove extra nodes\n    while (child) {\n      next = child.nextElementSibling;\n      child.remove();\n      child = next;\n    }\n  }\n}\n\nif (typeof customElements != 'undefined') {\n  customElements.define('x-list', XList);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/browser/lib/x-list.js\n// module id = 49\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nlet HTMLElement;\nif (typeof window == 'undefined') {\n  HTMLElement = class HTMLElement {};\n} else {\n  HTMLElement = window.HTMLElement;\n}\n\nexport default class XenElement extends HTMLElement {\n  constructor() {\n    super();\n    this._mounted = false;\n    this._root = this;\n    this.__configureAccessors();\n    this.__lazyAcquireProps();\n  }\n  get _class() {\n    // TODO(sjmiles): problem accessing class statics under polyfills can be fixed\n    // by attaching _class reference to element constructors (not provided)\n    return (this.constructor._class || this.constructor);\n  }\n  __lazyAcquireProps() {\n    let a = this._class.observedAttributes;\n    a && a.forEach(n=>{\n      if (n.toLowerCase() !== n) {\n        console.error('Xen: Mixed-case attributes are not yet supported, `' + this.localName + '.observedAttributes` contains `' + n + '`.');\n      }\n      if (this.hasOwnProperty(n)) {\n        let value = this[n];\n        delete this[n];\n        this[n] = value;\n      } else if (this.hasAttribute(n)) {\n        this[n] = this.getAttribute(n);\n      }\n    });\n  }\n  __configureAccessors() {\n    // only do this once per prototype\n    let p = Object.getPrototypeOf(this);\n    if (!p.hasOwnProperty('__$xenPropsConfigured')) {\n      p.__$xenPropsConfigured = true;\n      let a = this._class.observedAttributes;\n      a && a.forEach(n => {\n        Object.defineProperty(p, n, {\n          get() {\n            // abstract\n            return this._getProperty(n);\n          },\n          set(value) {\n            // abstract\n            this._setProperty(n, value);\n          }\n        });\n      });\n    }\n  }\n  connectedCallback() {\n    this._mount();\n  }\n  _mount() {\n    if (!this._mounted) {\n      this._mounted = true;\n      this._doMount();\n      this._didMount();\n    }\n  }\n  _doMount() {\n  }\n  _didMount() {\n  }\n  _fire(eventName, detail) {\n    let event = new CustomEvent(eventName, {detail: detail});\n    this.dispatchEvent(event);\n    return event.detail;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/browser/lib/xen-element.js\n// module id = 50\n// module chunks = 0","export default /*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function() {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n          literal: function(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n\n          \"class\": function(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array\n                ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n\n          any: function(expectation) {\n            return \"any character\";\n          },\n\n          end: function(expectation) {\n            return \"end of input\";\n          },\n\n          other: function(expectation) {\n            return expectation.description;\n          }\n        };\n\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g,  '\\\\\"')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function classEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\]/g, '\\\\]')\n        .replace(/\\^/g, '\\\\^')\n        .replace(/-/g,  '\\\\-')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n          i, j;\n\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n\n    var peg$FAILED = {},\n\n        peg$startRuleFunctions = { Manifest: peg$parseManifest },\n        peg$startRuleFunction  = peg$parseManifest,\n\n        peg$c0 = function(items) {\n            let result = items.map(item => {\n              let manifestItem = item[2];\n              manifestItem.annotation = optional(item[0], a => a[1], null);\n              return manifestItem;\n            });\n            checkNormal(result);\n            return result;\n          },\n        peg$c1 = \"@\",\n        peg$c2 = peg$literalExpectation(\"@\", false),\n        peg$c3 = function(annotation) { return annotation; },\n        peg$c4 = \"resource\",\n        peg$c5 = peg$literalExpectation(\"resource\", false),\n        peg$c6 = function(name, body) {\n          return {\n            kind: 'resource',\n            name,\n            data: body,\n            location: location()\n          };\n        },\n        peg$c7 = \"start\",\n        peg$c8 = peg$literalExpectation(\"start\", false),\n        peg$c9 = function() { startIndent = indent; },\n        peg$c10 = function(lines) {\n          return lines.map(line => line[0].substring(startIndent.length) + line[1]).join('');\n        },\n        peg$c11 = /^[^\\n]/,\n        peg$c12 = peg$classExpectation([\"\\n\"], true, false),\n        peg$c13 = function() { return text(); },\n        peg$c14 = \"view\",\n        peg$c15 = peg$literalExpectation(\"view\", false),\n        peg$c16 = \"store\",\n        peg$c17 = peg$literalExpectation(\"store\", false),\n        peg$c18 = \"of\",\n        peg$c19 = peg$literalExpectation(\"of\", false),\n        peg$c20 = function(name, type, id, version, tags, source, items) {\n            items = optional(items, extractIndented, []);\n            return {\n              kind: 'view',\n              location: location(),\n              name,\n              type,\n              id: optional(id, id => id[1], null),\n              version: optional(version, version => version[1], null),\n              tags: optional(tags, tags => tags[1], null),\n              source: source.source,\n              origin: source.origin,\n              description: items.length > 0 ? items[0][2] : null\n            };\n          },\n        peg$c21 = \"in\",\n        peg$c22 = peg$literalExpectation(\"in\", false),\n        peg$c23 = function(source) { return {origin: 'file', source }; },\n        peg$c24 = function(source) { return {origin: 'resource', source }; },\n        peg$c25 = \"at\",\n        peg$c26 = peg$literalExpectation(\"at\", false),\n        peg$c27 = function(source) { return {origin: 'storage', source }; },\n        peg$c28 = \"description\",\n        peg$c29 = peg$literalExpectation(\"description\", false),\n        peg$c30 = \"import\",\n        peg$c31 = peg$literalExpectation(\"import\", false),\n        peg$c32 = function(path) {\n            return {\n              kind: 'import',\n              location: location(),\n              path,\n            };\n          },\n        peg$c33 = \"shape\",\n        peg$c34 = peg$literalExpectation(\"shape\", false),\n        peg$c35 = \"<\",\n        peg$c36 = peg$literalExpectation(\"<\", false),\n        peg$c37 = \">\",\n        peg$c38 = peg$literalExpectation(\">\", false),\n        peg$c39 = function(name, typeVars, items) {\n            return {\n              kind: 'shape',\n              location: location(),\n              name,\n              interface: optional(items, extractIndented, []).find(item => item.kind == 'shape-interface'),\n              slots: optional(items, extractIndented, []).filter(item => item.kind == 'shape-slot'),\n            }\n          },\n        peg$c40 = \"(\",\n        peg$c41 = peg$literalExpectation(\"(\", false),\n        peg$c42 = \")\",\n        peg$c43 = peg$literalExpectation(\")\", false),\n        peg$c44 = function(verb, args) {\n            return {\n              kind: 'shape-interface',\n              location: location(),\n              verb,\n              args: args || []\n            };\n          },\n        peg$c45 = \",\",\n        peg$c46 = peg$literalExpectation(\",\", false),\n        peg$c47 = function(head, tail) {\n            return [head].concat(tail.map(a => a[2]));\n          },\n        peg$c48 = function(direction, type, name) {\n            if (direction == 'host') {\n              error(`Shape cannot have arguments with a 'host' direction.`);\n            }\n\n            return {\n              kind: 'shape-argument',\n              location: location(),\n              direction,\n              type,\n              name,\n            };\n          },\n        peg$c49 = \"must\",\n        peg$c50 = peg$literalExpectation(\"must\", false),\n        peg$c51 = \"consume\",\n        peg$c52 = peg$literalExpectation(\"consume\", false),\n        peg$c53 = \"provide\",\n        peg$c54 = peg$literalExpectation(\"provide\", false),\n        peg$c55 = \"set of\",\n        peg$c56 = peg$literalExpectation(\"set of\", false),\n        peg$c57 = function(isRequired, direction, isSet, name) {\n            return {\n              kind: 'shape-slot',\n              location: location(),\n              name: optional(name, isRequired => name[1], null),\n              isRequired: optional(isRequired, isRequired => isRequired[0] == 'must', false),\n              direction,\n              isSet: !!isSet,\n            }\n          },\n        peg$c58 = \"meta\",\n        peg$c59 = peg$literalExpectation(\"meta\", false),\n        peg$c60 = function(items) {\n          items = items ? extractIndented(items): [];\n          return {kind: 'meta', items: items, location: location()};\n        },\n        peg$c61 = \"name\",\n        peg$c62 = peg$literalExpectation(\"name\", false),\n        peg$c63 = \":\",\n        peg$c64 = peg$literalExpectation(\":\", false),\n        peg$c65 = function(name) { return { key: 'name', value: name, location: location(), kind: 'name' } },\n        peg$c66 = \"storageKey\",\n        peg$c67 = peg$literalExpectation(\"storageKey\", false),\n        peg$c68 = function(key) { return {key: 'storageKey', value: key}},\n        peg$c69 = \"particle\",\n        peg$c70 = peg$literalExpectation(\"particle\", false),\n        peg$c71 = function(name, implFile, items) {\n            let args = null;\n            let verbs = [];\n            let affordance = [];\n            let slots = [];\n            let description = null;\n            items = items ? extractIndented(items) : [];\n            items.forEach(item => {\n              if (item.kind == 'interface') {\n                if (/[A-Z]/.test(item.verb[0]) && item.verb != name) {\n                  error(`Verb ${item.verb} must start with a lower case character or be same as particle name.`);\n                }\n                verbs.push(item.verb);\n                args = item.args;\n              } else if (item.kind == 'particle-slot') {\n                slots.push(item);\n              } else if (item.kind == 'description') {\n                // TODO: Super hacks.\n                description = {\n                  kind: 'description?',\n                  location: 'FIXME',\n                };\n                item.description.forEach(d => { description[d.name] = d.pattern; });\n              } else if (item.affordance) {\n                affordance.push(item.affordance)\n              } else {\n                error(`Particle ${name} contains an unknown element: ${item.name}`);\n              }\n            });\n            if (affordance.length == 0) {\n              // Add default affordance\n              affordance.push('dom');\n            }\n            affordance.push('mock');\n\n            return {\n              kind: 'particle',\n              location: location(),\n              name,\n              implFile: optional(implFile, implFile => implFile[3], null),\n              verbs,\n              args,\n              affordance,\n              slots,\n              description,\n            };\n          },\n        peg$c72 = function(verb, args) {\n            return {\n              kind: 'interface',\n              location: location(),\n              verb,\n              args: args || []\n            };\n          },\n        peg$c73 = \"?\",\n        peg$c74 = peg$literalExpectation(\"?\", false),\n        peg$c75 = function(direction, type, isOptional, name) {\n            return {\n              kind: 'particle-argument',\n              location: location(),\n              direction,\n              type: type,\n              isOptional: !!isOptional,\n              name,\n            };\n          },\n        peg$c76 = \"inout\",\n        peg$c77 = peg$literalExpectation(\"inout\", false),\n        peg$c78 = \"out\",\n        peg$c79 = peg$literalExpectation(\"out\", false),\n        peg$c80 = \"host\",\n        peg$c81 = peg$literalExpectation(\"host\", false),\n        peg$c82 = function() {\n            return text();\n          },\n        peg$c83 = \"[\",\n        peg$c84 = peg$literalExpectation(\"[\", false),\n        peg$c85 = \"]\",\n        peg$c86 = peg$literalExpectation(\"]\", false),\n        peg$c87 = function(type) {\n            return {\n              kind: 'list-type',\n              location: location(),\n              type,\n            };\n          },\n        peg$c88 = \"~\",\n        peg$c89 = peg$literalExpectation(\"~\", false),\n        peg$c90 = function(name) {\n            return {\n              kind: 'variable-type',\n              location: location(),\n              name,\n            };\n          },\n        peg$c91 = function(name) {\n            return {\n              kind: 'reference-type',\n              location: location(),\n              name,\n            };\n          },\n        peg$c92 = function(head, tail) {\n            return [head, ...tail.map(a => a[2])];\n          },\n        peg$c93 = \"affordance\",\n        peg$c94 = peg$literalExpectation(\"affordance\", false),\n        peg$c95 = \"dom-touch\",\n        peg$c96 = peg$literalExpectation(\"dom-touch\", false),\n        peg$c97 = \"dom\",\n        peg$c98 = peg$literalExpectation(\"dom\", false),\n        peg$c99 = \"vr\",\n        peg$c100 = peg$literalExpectation(\"vr\", false),\n        peg$c101 = \"voice\",\n        peg$c102 = peg$literalExpectation(\"voice\", false),\n        peg$c103 = function(affordance) {\n            return {\n              kind: 'particle-affordance',\n              location: location(),\n              affordance,\n            };\n          },\n        peg$c104 = function(isRequired, isSet, name, items) {\n            let formFactor = null;\n            let providedSlots = [];\n            items = optional(items, extractIndented, []);\n            items.forEach(item => {\n              if (item.kind == 'provided-slot') {\n                providedSlots.push(item);\n              } else if (item.kind == 'form-factor') {\n                if (formFactor)\n                  error('duplicate form factor for a slot');\n                formFactor = item.formFactor;\n              } else {\n                error('Unsupported particle slot item ', item);\n              }\n            });\n            return {\n              kind: 'particle-slot',\n              location: location(),\n              name,\n              isRequired: optional(isRequired, isRequired => isRequired[0] == 'must', false),\n              isSet: !!isSet,\n              formFactor,\n              providedSlots\n            };\n          },\n        peg$c105 = \"formFactor\",\n        peg$c106 = peg$literalExpectation(\"formFactor\", false),\n        peg$c107 = \"fullscreen\",\n        peg$c108 = peg$literalExpectation(\"fullscreen\", false),\n        peg$c109 = \"big\",\n        peg$c110 = peg$literalExpectation(\"big\", false),\n        peg$c111 = \"medium\",\n        peg$c112 = peg$literalExpectation(\"medium\", false),\n        peg$c113 = \"small\",\n        peg$c114 = peg$literalExpectation(\"small\", false),\n        peg$c115 = function(formFactor) {\n            return {\n              kind: 'form-factor',\n              location: location(),\n              formFactor\n            };\n          },\n        peg$c116 = function(isSet, name, items) {\n            let formFactor = null;\n            let views = [];\n            items = items ? extractIndented(items) : [];\n            items.forEach(item => {\n              if (item.kind == 'form-factor') {\n                if (formFactor)\n                  error('duplicate form factor for a slot');\n                formFactor = item.formFactor;\n              } else {\n                views.push(item.view);\n              }\n            });\n            return {\n              kind: 'provided-slot',\n              location: location(),\n              name,\n              isSet: !!isSet,\n              formFactor,\n              views\n            };\n          },\n        peg$c117 = function(view) {\n            return {\n              kind: 'particle-provided-slot-view',\n              location: location(),\n              view,\n            };\n          },\n        peg$c118 = function(pattern, viewDescriptions) {\n            return {\n              kind: 'description',\n              location: location(),\n              description: [\n                {\n                  // TODO: this should be stored in a different field.\n                  kind: 'default-description?',\n                  location: location(),\n                  name: 'pattern',\n                  pattern: pattern,\n                },\n                ...optional(viewDescriptions, extractIndented, []),\n              ],\n            };\n          },\n        peg$c119 = function(name, pattern) {\n            return {\n              kind: 'view-description',\n              location: location(),\n              name,\n              pattern,\n            };\n          },\n        peg$c120 = \"recipe\",\n        peg$c121 = peg$literalExpectation(\"recipe\", false),\n        peg$c122 = function(name, tags, items) {\n            return {\n              kind: 'recipe',\n              location: location(),\n              name: optional(name, name => name[1], null),\n              tags: optional(tags, tags => tags[1], []),\n              items: optional(items, extractIndented, []),\n            };\n          },\n        peg$c123 = \"as\",\n        peg$c124 = peg$literalExpectation(\"as\", false),\n        peg$c125 = function(name) {\n            return name;\n          },\n        peg$c126 = function(ref, name, connections) {\n            let handleConnections = [];\n            let slotConnections = [];\n            if (connections) {\n              connections = extractIndented(connections);\n              for (let conn of connections) {\n                if (conn.kind == 'handle-connection')\n                  handleConnections.push(conn);\n                else\n                  slotConnections.push(conn)\n              }\n            }\n            return {\n              kind: 'particle',\n              location: location(),\n              name: optional(name, name => name[1], null),\n              ref,\n              connections: handleConnections,\n              slotConnections: slotConnections,\n            };\n          },\n        peg$c127 = \"*\",\n        peg$c128 = peg$literalExpectation(\"*\", false),\n        peg$c129 = function(param, dir, target) {\n            return {\n              kind: 'handle-connection',\n              location: location(),\n              param,\n              dir,\n              target: optional(target, target => target[1], null),\n            };\n          },\n        peg$c130 = function(param, name, providedSlots) {\n            return {\n              kind: 'slot-connection',\n              location: location(),\n              param,\n              name: optional(name, name=>name[1], null),\n              providedSlots: optional(providedSlots, extractIndented, [])\n            };\n          },\n        peg$c131 = function(param, name) {\n            return {\n              kind: 'provided-slot',\n              location: location(),\n              param,\n              name: optional(name, name=>name[1], null)\n            };\n          },\n        peg$c132 = function(from, dir, to) {\n            return {\n              kind: 'connection',\n              location: location(),\n              dir,\n              from,\n              to,\n            };\n          },\n        peg$c133 = \"search\",\n        peg$c134 = peg$literalExpectation(\"search\", false),\n        peg$c135 = \"tokens\",\n        peg$c136 = peg$literalExpectation(\"tokens\", false),\n        peg$c137 = function(phrase, tokens) {\n            return {\n              kind: 'search',\n              location: location(),\n              phrase,\n              tokens: optional(tokens, tokens => tokens[1][2].map(t => t[1]), null)\n            };\n          },\n        peg$c138 = \"<-\",\n        peg$c139 = peg$literalExpectation(\"<-\", false),\n        peg$c140 = \"->\",\n        peg$c141 = peg$literalExpectation(\"->\", false),\n        peg$c142 = \"=\",\n        peg$c143 = peg$literalExpectation(\"=\", false),\n        peg$c144 = \".\",\n        peg$c145 = peg$literalExpectation(\".\", false),\n        peg$c146 = function(ident, param, tags) {\n            let particle = null;\n            let name = null;\n            if (ident) {\n              if (/^[A-Z]/.test(ident)) {\n                particle = ident;\n              } else {\n                name = ident;\n              }\n            }\n\n            return {\n              kind: 'connection-target',\n              location: location(),\n              particle,\n              name,\n              param: optional(param, param => param[1], null),\n              tags: optional(tags, tags => tags[1], []),\n            }\n          },\n        peg$c147 = function(tags) {\n            return {\n              kind: 'connection-target',\n              location: location(),\n              tags,\n            };\n          },\n        peg$c148 = \"use\",\n        peg$c149 = peg$literalExpectation(\"use\", false),\n        peg$c150 = \"map\",\n        peg$c151 = peg$literalExpectation(\"map\", false),\n        peg$c152 = \"create\",\n        peg$c153 = peg$literalExpectation(\"create\", false),\n        peg$c154 = \"copy\",\n        peg$c155 = peg$literalExpectation(\"copy\", false),\n        peg$c156 = function(type, ref, name) {\n            return {\n              kind: 'view',\n              location: location(),\n              name: optional(name, name => name[1], null),\n              ref: optional(ref, ref => ref[1], null),\n              fate: type\n            }\n          },\n        peg$c157 = \"#\",\n        peg$c158 = peg$literalExpectation(\"#\", false),\n        peg$c159 = /^[a-zA-Z]/,\n        peg$c160 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false),\n        peg$c161 = /^[a-zA-Z0-9_]/,\n        peg$c162 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"_\"], false, false),\n        peg$c163 = function() {return text()},\n        peg$c164 = function(head, tail) { return [head, ...(tail && tail[1] || [])]; },\n        peg$c165 = function(tags) { return tags; },\n        peg$c166 = function(name, tags) {\n            return {\n              kind: 'particle-ref',\n              location: location(),\n              name,\n              tags: tags || [],\n              verbs: [],\n            };\n          },\n        peg$c167 = function(tags) {\n            return {\n              kind: 'particle-ref',\n              location: location(),\n              tags,\n              verbs: [],\n            };\n          },\n        peg$c168 = \"particle can\",\n        peg$c169 = peg$literalExpectation(\"particle can\", false),\n        peg$c170 = function(verb, tags) {\n            return {\n              kind: 'particle-ref',\n              location: location(),\n              verbs: [verb],\n              tags: tags || [],\n            };\n          },\n        peg$c171 = function(id, tags) {\n            return {\n              kind: 'view-ref',\n              location: location(),\n              id,\n              tags: tags || [],\n            };\n          },\n        peg$c172 = function(name, tags) {\n            return {\n              kind: 'view-ref',\n              location: location(),\n              name,\n              tags: tags || [],\n            };\n          },\n        peg$c173 = function(tags) {\n            return {\n              kind: 'view-ref',\n              location: location(),\n              tags,\n            };\n          },\n        peg$c174 = \"slot\",\n        peg$c175 = peg$literalExpectation(\"slot\", false),\n        peg$c176 = function(id, name) {\n            return {\n              kind: 'slot',\n              location: location(),\n              id: optional(id, id => id[1], null),\n              name: optional(name, name => name[1], '')\n            }\n          },\n        peg$c177 = \"extends\",\n        peg$c178 = peg$literalExpectation(\"extends\", false),\n        peg$c179 = function(first, rest) {\n          var list = [first];\n          for (let item of rest) {\n            list.push(item[3]);\n          }\n          return list;\n        },\n        peg$c180 = \"{\",\n        peg$c181 = peg$literalExpectation(\"{\", false),\n        peg$c182 = \"}\",\n        peg$c183 = peg$literalExpectation(\"}\", false),\n        peg$c184 = function(name, fields) {\n            return {\n              kind: 'schema-inline',\n              location: location(),\n              name: name == '*' ? null : name,\n              fields: fields.map(field => field[0]),\n            }\n          },\n        peg$c185 = function(type, arity, name) {\n            return {\n              kind: 'schema-inline-field',\n              location: location(),\n              name,\n              type,\n              arity,\n            };\n          },\n        peg$c186 = \"schema\",\n        peg$c187 = peg$literalExpectation(\"schema\", false),\n        peg$c188 = function(name, parent, sections) {\n            return {\n              kind: 'schema',\n              location: location(),\n              name: name,\n              parents: optional(parent, parent => parent, []),\n              sections: optional(sections, extractIndented, []),\n            };\n          },\n        peg$c189 = \"normative\",\n        peg$c190 = peg$literalExpectation(\"normative\", false),\n        peg$c191 = \"optional\",\n        peg$c192 = peg$literalExpectation(\"optional\", false),\n        peg$c193 = function(sectionType, fields) {\n            return {\n              kind: 'schema-section',\n              location: location(),\n              sectionType,\n              fields: extractIndented(fields),\n            };\n          },\n        peg$c194 = function(type, name) {\n            return {\n              kind: 'schema-field',\n              location: location(),\n              type,\n              name,\n            };\n          },\n        peg$c195 = \"Text\",\n        peg$c196 = peg$literalExpectation(\"Text\", false),\n        peg$c197 = \"URL\",\n        peg$c198 = peg$literalExpectation(\"URL\", false),\n        peg$c199 = \"Number\",\n        peg$c200 = peg$literalExpectation(\"Number\", false),\n        peg$c201 = \"Boolean\",\n        peg$c202 = peg$literalExpectation(\"Boolean\", false),\n        peg$c203 = \"Object\",\n        peg$c204 = peg$literalExpectation(\"Object\", false),\n        peg$c205 = \"or\",\n        peg$c206 = peg$literalExpectation(\"or\", false),\n        peg$c207 = function(first, rest) {\n          let typeList = [first];\n          for (let type of rest) {\n            typeList.push(type[3]);\n          }\n          return typeList;\n        },\n        peg$c208 = /^[0-9]/,\n        peg$c209 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n        peg$c210 = function(version) {\n            return Number(version.join(''));\n          },\n        peg$c211 = \" \",\n        peg$c212 = peg$literalExpectation(\" \", false),\n        peg$c213 = function(i) {\n          i = i.join('');\n          if (i.length > indent.length) {\n            indents.push(indent);\n            indent = i;\n            return true;\n          }\n        },\n        peg$c214 = function(i) {\n          i = i.join('');\n          if (i.length == indent.length) {\n            return true;\n          } else if (i.length < indent.length) {\n            indent = indents.pop();\n            return false;\n          }\n        },\n        peg$c215 = function(i) {\n          i = i.join('');\n          if (i.length >= indent.length) {\n            return true;\n          } else if (i.length < indent.length) {\n            indent = indents.pop();\n            return false;\n          }\n        },\n        peg$c216 = function() {\n            let fixed = text();\n            fixed = fixed.replace(/^(.)/, l => l.toUpperCase());\n            expected(`a top level identifier (e.g. \"${fixed}\")`);\n          },\n        peg$c217 = \"`\",\n        peg$c218 = peg$literalExpectation(\"`\", false),\n        peg$c219 = /^[^`]/,\n        peg$c220 = peg$classExpectation([\"`\"], true, false),\n        peg$c221 = function(pattern) { return pattern.join(''); },\n        peg$c222 = \"'\",\n        peg$c223 = peg$literalExpectation(\"'\", false),\n        peg$c224 = /^[^']/,\n        peg$c225 = peg$classExpectation([\"'\"], true, false),\n        peg$c226 = function(id) {return id.join('')},\n        peg$c227 = /^[A-Z]/,\n        peg$c228 = peg$classExpectation([[\"A\", \"Z\"]], false, false),\n        peg$c229 = /^[a-z0-9_]/i,\n        peg$c230 = peg$classExpectation([[\"a\", \"z\"], [\"0\", \"9\"], \"_\"], false, true),\n        peg$c231 = function(ident) {return text()},\n        peg$c232 = /^[a-z]/,\n        peg$c233 = peg$classExpectation([[\"a\", \"z\"]], false, false),\n        peg$c234 = /^[ ]/,\n        peg$c235 = peg$classExpectation([\" \"], false, false),\n        peg$c236 = peg$anyExpectation(),\n        peg$c237 = \"\\r\",\n        peg$c238 = peg$literalExpectation(\"\\r\", false),\n        peg$c239 = \"\\n\",\n        peg$c240 = peg$literalExpectation(\"\\n\", false),\n        peg$c241 = \"//\",\n        peg$c242 = peg$literalExpectation(\"//\", false),\n        peg$c243 = function(marker) {\n            if (marker === '#' && !deprecatedCommentWarningShown) {\n              console.warn(\"'#' for comments is deprecated. Please use '//' instead\");\n              deprecatedCommentWarningShown = true;\n            }\n          },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1 }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildStructuredError(\n        [peg$otherExpectation(description)],\n        input.substring(peg$savedPos, peg$currPos),\n        location\n      );\n    }\n\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildSimpleError(message, location);\n    }\n\n    function peg$literalExpectation(text, ignoreCase) {\n      return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description: description };\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos], p;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column\n        };\n\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(\n        peg$SyntaxError.buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parseManifest() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      s0 = peg$currPos;\n      s1 = peg$parseeolWhiteSpace();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseIndent();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          s6 = peg$parseSameIndent();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseAnnotation();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parseeolWhiteSpace();\n              if (s8 !== peg$FAILED) {\n                s6 = [s6, s7, s8];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 === peg$FAILED) {\n            s5 = null;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseSameIndent();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseManifestItem();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            s5 = peg$currPos;\n            s6 = peg$parseSameIndent();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseAnnotation();\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parseeolWhiteSpace();\n                if (s8 !== peg$FAILED) {\n                  s6 = [s6, s7, s8];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseSameIndent();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseManifestItem();\n                if (s7 !== peg$FAILED) {\n                  s5 = [s5, s6, s7];\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c0(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseManifestItem() {\n      var s0;\n\n      s0 = peg$parseRecipe();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseParticle();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseImport();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseSchema();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseManifestStorage();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parseShape();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parseMeta();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseResource();\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseAnnotation() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 64) {\n        s1 = peg$c1;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c2); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselowerIdent();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c3(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseResource() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 8) === peg$c4) {\n        s1 = peg$c4;\n        peg$currPos += 8;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c5); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseTopLevelIdent();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseeolWhiteSpace();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseIndent();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseSameIndent();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parseResourceStart();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parseResourceBody();\n                    if (s8 !== peg$FAILED) {\n                      s9 = peg$parseeolWhiteSpace();\n                      if (s9 === peg$FAILED) {\n                        s9 = null;\n                      }\n                      if (s9 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c6(s3, s8);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseResourceStart() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c7) {\n        s1 = peg$c7;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c8); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseeolWhiteSpace();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c9();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseResourceBody() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$parseSameOrMoreIndent();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseResourceLine();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$parseSameOrMoreIndent();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseResourceLine();\n            if (s4 !== peg$FAILED) {\n              s3 = [s3, s4];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c10(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseResourceLine() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c11.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c12); }\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c11.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c12); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseeol();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c13();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseManifestStorage() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c14) {\n        s1 = peg$c14;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c15); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c16) {\n          s1 = peg$c16;\n          peg$currPos += 5;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c17); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseTopLevelIdent();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsewhiteSpace();\n            if (s4 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c18) {\n                s5 = peg$c18;\n                peg$currPos += 2;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c19); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsewhiteSpace();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parseSchemaInline();\n                  if (s7 === peg$FAILED) {\n                    s7 = peg$parseListType();\n                    if (s7 === peg$FAILED) {\n                      s7 = peg$parseReferenceType();\n                    }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$currPos;\n                    s9 = peg$parsewhiteSpace();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parseid();\n                      if (s10 !== peg$FAILED) {\n                        s9 = [s9, s10];\n                        s8 = s9;\n                      } else {\n                        peg$currPos = s8;\n                        s8 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s8;\n                      s8 = peg$FAILED;\n                    }\n                    if (s8 === peg$FAILED) {\n                      s8 = null;\n                    }\n                    if (s8 !== peg$FAILED) {\n                      s9 = peg$currPos;\n                      s10 = peg$parsewhiteSpace();\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parseVersion();\n                        if (s11 !== peg$FAILED) {\n                          s10 = [s10, s11];\n                          s9 = s10;\n                        } else {\n                          peg$currPos = s9;\n                          s9 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s9;\n                        s9 = peg$FAILED;\n                      }\n                      if (s9 === peg$FAILED) {\n                        s9 = null;\n                      }\n                      if (s9 !== peg$FAILED) {\n                        s10 = peg$currPos;\n                        s11 = peg$parsewhiteSpace();\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parseTagList();\n                          if (s12 !== peg$FAILED) {\n                            s11 = [s11, s12];\n                            s10 = s11;\n                          } else {\n                            peg$currPos = s10;\n                            s10 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s10;\n                          s10 = peg$FAILED;\n                        }\n                        if (s10 === peg$FAILED) {\n                          s10 = null;\n                        }\n                        if (s10 !== peg$FAILED) {\n                          s11 = peg$parsewhiteSpace();\n                          if (s11 !== peg$FAILED) {\n                            s12 = peg$parseManifestStorageSource();\n                            if (s12 !== peg$FAILED) {\n                              s13 = peg$parseeolWhiteSpace();\n                              if (s13 !== peg$FAILED) {\n                                s14 = peg$currPos;\n                                s15 = peg$parseIndent();\n                                if (s15 !== peg$FAILED) {\n                                  s16 = [];\n                                  s17 = peg$currPos;\n                                  s18 = peg$parseSameIndent();\n                                  if (s18 !== peg$FAILED) {\n                                    s19 = peg$parseManifestStorageDescription();\n                                    if (s19 !== peg$FAILED) {\n                                      s18 = [s18, s19];\n                                      s17 = s18;\n                                    } else {\n                                      peg$currPos = s17;\n                                      s17 = peg$FAILED;\n                                    }\n                                  } else {\n                                    peg$currPos = s17;\n                                    s17 = peg$FAILED;\n                                  }\n                                  if (s17 !== peg$FAILED) {\n                                    while (s17 !== peg$FAILED) {\n                                      s16.push(s17);\n                                      s17 = peg$currPos;\n                                      s18 = peg$parseSameIndent();\n                                      if (s18 !== peg$FAILED) {\n                                        s19 = peg$parseManifestStorageDescription();\n                                        if (s19 !== peg$FAILED) {\n                                          s18 = [s18, s19];\n                                          s17 = s18;\n                                        } else {\n                                          peg$currPos = s17;\n                                          s17 = peg$FAILED;\n                                        }\n                                      } else {\n                                        peg$currPos = s17;\n                                        s17 = peg$FAILED;\n                                      }\n                                    }\n                                  } else {\n                                    s16 = peg$FAILED;\n                                  }\n                                  if (s16 !== peg$FAILED) {\n                                    s15 = [s15, s16];\n                                    s14 = s15;\n                                  } else {\n                                    peg$currPos = s14;\n                                    s14 = peg$FAILED;\n                                  }\n                                } else {\n                                  peg$currPos = s14;\n                                  s14 = peg$FAILED;\n                                }\n                                if (s14 === peg$FAILED) {\n                                  s14 = null;\n                                }\n                                if (s14 !== peg$FAILED) {\n                                  peg$savedPos = s0;\n                                  s1 = peg$c20(s3, s7, s8, s9, s10, s12, s14);\n                                  s0 = s1;\n                                } else {\n                                  peg$currPos = s0;\n                                  s0 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseManifestStorageSource() {\n      var s0;\n\n      s0 = peg$parseManifestStorageFileSource();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseManifestStorageResourceSource();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseManifestStorageStorageSource();\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseManifestStorageFileSource() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c21) {\n        s1 = peg$c21;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseid();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c23(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseManifestStorageResourceSource() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c21) {\n        s1 = peg$c21;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseTopLevelIdent();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c24(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseManifestStorageStorageSource() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c25) {\n        s1 = peg$c25;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c26); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseid();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c27(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseManifestStorageDescription() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 11) === peg$c28) {\n        s1 = peg$c28;\n        peg$currPos += 11;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsebackquotedString();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseeolWhiteSpace();\n            if (s4 !== peg$FAILED) {\n              s1 = [s1, s2, s3, s4];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseImport() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6) === peg$c30) {\n        s1 = peg$c30;\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c31); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseid();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseeolWhiteSpace();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c32(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseShape() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c33) {\n        s1 = peg$c33;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c34); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseTopLevelIdent();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            s5 = peg$parsewhiteSpace();\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 60) {\n                s6 = peg$c35;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c36); }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsewhiteSpace();\n                if (s7 === peg$FAILED) {\n                  s7 = null;\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseVariableTypeList();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsewhiteSpace();\n                    if (s9 === peg$FAILED) {\n                      s9 = null;\n                    }\n                    if (s9 !== peg$FAILED) {\n                      if (input.charCodeAt(peg$currPos) === 62) {\n                        s10 = peg$c37;\n                        peg$currPos++;\n                      } else {\n                        s10 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                      }\n                      if (s10 !== peg$FAILED) {\n                        s5 = [s5, s6, s7, s8, s9, s10];\n                        s4 = s5;\n                      } else {\n                        peg$currPos = s4;\n                        s4 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s4;\n                      s4 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseeolWhiteSpace();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$currPos;\n                s7 = peg$parseIndent();\n                if (s7 !== peg$FAILED) {\n                  s8 = [];\n                  s9 = peg$currPos;\n                  s10 = peg$parseSameIndent();\n                  if (s10 !== peg$FAILED) {\n                    s11 = peg$parseShapeItem();\n                    if (s11 !== peg$FAILED) {\n                      s10 = [s10, s11];\n                      s9 = s10;\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                  while (s9 !== peg$FAILED) {\n                    s8.push(s9);\n                    s9 = peg$currPos;\n                    s10 = peg$parseSameIndent();\n                    if (s10 !== peg$FAILED) {\n                      s11 = peg$parseShapeItem();\n                      if (s11 !== peg$FAILED) {\n                        s10 = [s10, s11];\n                        s9 = s10;\n                      } else {\n                        peg$currPos = s9;\n                        s9 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s7 = [s7, s8];\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 === peg$FAILED) {\n                  s6 = null;\n                }\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parseeolWhiteSpace();\n                  if (s7 === peg$FAILED) {\n                    s7 = null;\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c39(s3, s4, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseShapeItem() {\n      var s0;\n\n      s0 = peg$parseShapeInterface();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseShapeSlot();\n      }\n\n      return s0;\n    }\n\n    function peg$parseShapeInterface() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$parseupperIdent();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parselowerIdent();\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c40;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c41); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseShapeArgumentList();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s4 = peg$c42;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c43); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseeolWhiteSpace();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c44(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseShapeArgumentList() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parseShapeArgument();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s4 = peg$c45;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c46); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsewhiteSpace();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseShapeArgument();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s4 = peg$c45;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c46); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsewhiteSpace();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseShapeArgument();\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c47(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseShapeArgument() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$parseParticleArgumentDirection();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseParticleArgumentType();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsewhiteSpace();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parselowerIdent();\n              if (s5 === peg$FAILED) {\n                s5 = null;\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c48(s1, s3, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseShapeSlot() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c49) {\n        s2 = peg$c49;\n        peg$currPos += 4;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c50); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsewhiteSpace();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 7) === peg$c51) {\n          s2 = peg$c51;\n          peg$currPos += 7;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c52); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 7) === peg$c53) {\n            s2 = peg$c53;\n            peg$currPos += 7;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c54); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parsewhiteSpace();\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 6) === peg$c55) {\n              s5 = peg$c55;\n              peg$currPos += 6;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c56); }\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            s5 = peg$parsewhiteSpace();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parselowerIdent();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseeolWhiteSpace();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c57(s1, s2, s3, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseMeta() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c58) {\n        s1 = peg$c58;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c59); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseeolWhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parseIndent();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$currPos;\n            s7 = peg$parseSameIndent();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parseMetaItem();\n              if (s8 !== peg$FAILED) {\n                s7 = [s7, s8];\n                s6 = s7;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$currPos;\n              s7 = peg$parseSameIndent();\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parseMetaItem();\n                if (s8 !== peg$FAILED) {\n                  s7 = [s7, s8];\n                  s6 = s7;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseeolWhiteSpace();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c60(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseMetaItem() {\n      var s0;\n\n      s0 = peg$parseMetaStorageKey();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseMetaName();\n      }\n\n      return s0;\n    }\n\n    function peg$parseMetaName() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c61) {\n        s1 = peg$c61;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c62); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s3 = peg$c63;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c64); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsewhiteSpace();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseid();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c65(s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseMetaStorageKey() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 10) === peg$c66) {\n        s1 = peg$c66;\n        peg$currPos += 10;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c67); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s3 = peg$c63;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c64); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsewhiteSpace();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseid();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c68(s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticle() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 8) === peg$c69) {\n        s1 = peg$c69;\n        peg$currPos += 8;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseTopLevelIdent();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            s5 = peg$parsewhiteSpace();\n            if (s5 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c21) {\n                s6 = peg$c21;\n                peg$currPos += 2;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c22); }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsewhiteSpace();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseid();\n                  if (s8 !== peg$FAILED) {\n                    s5 = [s5, s6, s7, s8];\n                    s4 = s5;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseeolWhiteSpace();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$currPos;\n                s7 = peg$parseIndent();\n                if (s7 !== peg$FAILED) {\n                  s8 = [];\n                  s9 = peg$currPos;\n                  s10 = peg$parseSameIndent();\n                  if (s10 !== peg$FAILED) {\n                    s11 = peg$parseParticleItem();\n                    if (s11 !== peg$FAILED) {\n                      s10 = [s10, s11];\n                      s9 = s10;\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                  while (s9 !== peg$FAILED) {\n                    s8.push(s9);\n                    s9 = peg$currPos;\n                    s10 = peg$parseSameIndent();\n                    if (s10 !== peg$FAILED) {\n                      s11 = peg$parseParticleItem();\n                      if (s11 !== peg$FAILED) {\n                        s10 = [s10, s11];\n                        s9 = s10;\n                      } else {\n                        peg$currPos = s9;\n                        s9 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s7 = [s7, s8];\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 === peg$FAILED) {\n                  s6 = null;\n                }\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parseeolWhiteSpace();\n                  if (s7 === peg$FAILED) {\n                    s7 = null;\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c71(s3, s4, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleItem() {\n      var s0;\n\n      s0 = peg$parseParticleInterface();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseParticleAffordance();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseParticleSlot();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseParticleDescription();\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleInterface() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$parseupperIdent();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parselowerIdent();\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c40;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c41); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseParticleArgumentList();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s4 = peg$c42;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c43); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseeolWhiteSpace();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c72(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleArgumentList() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parseParticleArgument();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s4 = peg$c45;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c46); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsewhiteSpace();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseParticleArgument();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s4 = peg$c45;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c46); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsewhiteSpace();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseParticleArgument();\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c47(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleArgument() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parseParticleArgumentDirection();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseParticleArgumentType();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 63) {\n              s4 = peg$c73;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c74); }\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsewhiteSpace();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parselowerIdent();\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c75(s1, s3, s4, s6);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleArgumentDirection() {\n      var s0, s1;\n\n      if (input.substr(peg$currPos, 5) === peg$c76) {\n        s0 = peg$c76;\n        peg$currPos += 5;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c77); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c21) {\n          s0 = peg$c21;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c22); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c78) {\n            s0 = peg$c78;\n            peg$currPos += 3;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c79); }\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 4) === peg$c80) {\n              s1 = peg$c80;\n              peg$currPos += 4;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c81); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c82();\n            }\n            s0 = s1;\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleArgumentType() {\n      var s0;\n\n      s0 = peg$parseVariableType();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseSchemaInline();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseReferenceType();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseListType();\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseListType() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c83;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c84); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseParticleArgumentType();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s3 = peg$c85;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c86); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c87(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseVariableType() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 126) {\n        s1 = peg$c88;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c89); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselowerIdent();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c90(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseReferenceType() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      s1 = peg$parseupperIdent();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c91(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseVariableTypeList() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parseVariableType();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s4 = peg$c45;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c46); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsewhiteSpace();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseVariableType();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s4 = peg$c45;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c46); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsewhiteSpace();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseVariableType();\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c92(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleAffordance() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 10) === peg$c93) {\n        s1 = peg$c93;\n        peg$currPos += 10;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c94); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 9) === peg$c95) {\n            s3 = peg$c95;\n            peg$currPos += 9;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c96); }\n          }\n          if (s3 === peg$FAILED) {\n            if (input.substr(peg$currPos, 3) === peg$c97) {\n              s3 = peg$c97;\n              peg$currPos += 3;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c98); }\n            }\n            if (s3 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c99) {\n                s3 = peg$c99;\n                peg$currPos += 2;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c100); }\n              }\n              if (s3 === peg$FAILED) {\n                if (input.substr(peg$currPos, 5) === peg$c101) {\n                  s3 = peg$c101;\n                  peg$currPos += 5;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c102); }\n                }\n              }\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseeolWhiteSpace();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c103(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleSlot() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c49) {\n        s2 = peg$c49;\n        peg$currPos += 4;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c50); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsewhiteSpace();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 7) === peg$c51) {\n          s2 = peg$c51;\n          peg$currPos += 7;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c52); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsewhiteSpace();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            if (input.substr(peg$currPos, 6) === peg$c55) {\n              s5 = peg$c55;\n              peg$currPos += 6;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c56); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsewhiteSpace();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parselowerIdent();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseeolWhiteSpace();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$currPos;\n                  s8 = peg$parseIndent();\n                  if (s8 !== peg$FAILED) {\n                    s9 = [];\n                    s10 = peg$currPos;\n                    s11 = peg$parseSameIndent();\n                    if (s11 !== peg$FAILED) {\n                      s12 = peg$parseParticleSlotItem();\n                      if (s12 !== peg$FAILED) {\n                        s11 = [s11, s12];\n                        s10 = s11;\n                      } else {\n                        peg$currPos = s10;\n                        s10 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s10;\n                      s10 = peg$FAILED;\n                    }\n                    while (s10 !== peg$FAILED) {\n                      s9.push(s10);\n                      s10 = peg$currPos;\n                      s11 = peg$parseSameIndent();\n                      if (s11 !== peg$FAILED) {\n                        s12 = peg$parseParticleSlotItem();\n                        if (s12 !== peg$FAILED) {\n                          s11 = [s11, s12];\n                          s10 = s11;\n                        } else {\n                          peg$currPos = s10;\n                          s10 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s10;\n                        s10 = peg$FAILED;\n                      }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s8 = [s8, s9];\n                      s7 = s8;\n                    } else {\n                      peg$currPos = s7;\n                      s7 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                  if (s7 === peg$FAILED) {\n                    s7 = null;\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c104(s1, s4, s5, s7);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleSlotItem() {\n      var s0;\n\n      s0 = peg$parseSlotFormFactor();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseParticleProvidedSlot();\n      }\n\n      return s0;\n    }\n\n    function peg$parseSlotFormFactor() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 10) === peg$c105) {\n        s1 = peg$c105;\n        peg$currPos += 10;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c106); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 10) === peg$c107) {\n            s3 = peg$c107;\n            peg$currPos += 10;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c108); }\n          }\n          if (s3 === peg$FAILED) {\n            if (input.substr(peg$currPos, 3) === peg$c109) {\n              s3 = peg$c109;\n              peg$currPos += 3;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c110); }\n            }\n            if (s3 === peg$FAILED) {\n              if (input.substr(peg$currPos, 6) === peg$c111) {\n                s3 = peg$c111;\n                peg$currPos += 6;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c112); }\n              }\n              if (s3 === peg$FAILED) {\n                if (input.substr(peg$currPos, 5) === peg$c113) {\n                  s3 = peg$c113;\n                  peg$currPos += 5;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c114); }\n                }\n              }\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseeolWhiteSpace();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c115(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleProvidedSlot() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 7) === peg$c53) {\n        s1 = peg$c53;\n        peg$currPos += 7;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c54); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.substr(peg$currPos, 6) === peg$c55) {\n            s4 = peg$c55;\n            peg$currPos += 6;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsewhiteSpace();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parselowerIdent();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseeolWhiteSpace();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$currPos;\n                s7 = peg$parseIndent();\n                if (s7 !== peg$FAILED) {\n                  s8 = [];\n                  s9 = peg$currPos;\n                  s10 = peg$parseSameIndent();\n                  if (s10 !== peg$FAILED) {\n                    s11 = peg$parseParticleProvidedSlotItem();\n                    if (s11 !== peg$FAILED) {\n                      s10 = [s10, s11];\n                      s9 = s10;\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                  while (s9 !== peg$FAILED) {\n                    s8.push(s9);\n                    s9 = peg$currPos;\n                    s10 = peg$parseSameIndent();\n                    if (s10 !== peg$FAILED) {\n                      s11 = peg$parseParticleProvidedSlotItem();\n                      if (s11 !== peg$FAILED) {\n                        s10 = [s10, s11];\n                        s9 = s10;\n                      } else {\n                        peg$currPos = s9;\n                        s9 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s7 = [s7, s8];\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 === peg$FAILED) {\n                  s6 = null;\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c116(s3, s4, s6);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleProvidedSlotItem() {\n      var s0;\n\n      s0 = peg$parseSlotFormFactor();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseParticleProvidedSlotView();\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleProvidedSlotView() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c14) {\n        s1 = peg$c14;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c15); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parselowerIdent();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseeolWhiteSpace();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c117(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleDescription() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 11) === peg$c28) {\n        s1 = peg$c28;\n        peg$currPos += 11;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsebackquotedString();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseeolWhiteSpace();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$currPos;\n              s6 = peg$parseIndent();\n              if (s6 !== peg$FAILED) {\n                s7 = [];\n                s8 = peg$currPos;\n                s9 = peg$parseSameIndent();\n                if (s9 !== peg$FAILED) {\n                  s10 = peg$parseParticleViewDescription();\n                  if (s10 !== peg$FAILED) {\n                    s9 = [s9, s10];\n                    s8 = s9;\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n                if (s8 !== peg$FAILED) {\n                  while (s8 !== peg$FAILED) {\n                    s7.push(s8);\n                    s8 = peg$currPos;\n                    s9 = peg$parseSameIndent();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parseParticleViewDescription();\n                      if (s10 !== peg$FAILED) {\n                        s9 = [s9, s10];\n                        s8 = s9;\n                      } else {\n                        peg$currPos = s8;\n                        s8 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s8;\n                      s8 = peg$FAILED;\n                    }\n                  }\n                } else {\n                  s7 = peg$FAILED;\n                }\n                if (s7 !== peg$FAILED) {\n                  s6 = [s6, s7];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n              if (s5 === peg$FAILED) {\n                s5 = null;\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c118(s3, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleViewDescription() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$parselowerIdent();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsebackquotedString();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseeolWhiteSpace();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c119(s1, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseRecipe() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6) === peg$c120) {\n        s1 = peg$c120;\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c121); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parsewhiteSpace();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseTopLevelIdent();\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parsewhiteSpace();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseTagList();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseeolWhiteSpace();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$currPos;\n              s6 = peg$parseIndent();\n              if (s6 !== peg$FAILED) {\n                s7 = [];\n                s8 = peg$currPos;\n                s9 = peg$parseSameIndent();\n                if (s9 !== peg$FAILED) {\n                  s10 = peg$parseRecipeItem();\n                  if (s10 !== peg$FAILED) {\n                    s9 = [s9, s10];\n                    s8 = s9;\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n                while (s8 !== peg$FAILED) {\n                  s7.push(s8);\n                  s8 = peg$currPos;\n                  s9 = peg$parseSameIndent();\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$parseRecipeItem();\n                    if (s10 !== peg$FAILED) {\n                      s9 = [s9, s10];\n                      s8 = s9;\n                    } else {\n                      peg$currPos = s8;\n                      s8 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                }\n                if (s7 !== peg$FAILED) {\n                  s6 = [s6, s7];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n              if (s5 === peg$FAILED) {\n                s5 = null;\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c122(s2, s3, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseRecipeItem() {\n      var s0;\n\n      s0 = peg$parseRecipeParticle();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseRecipeView();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseRecipeSlot();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseRecipeConnection();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseRecipeSearch();\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseName() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c123) {\n        s1 = peg$c123;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c124); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parselowerIdent();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c125(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseRecipeParticle() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      s0 = peg$currPos;\n      s1 = peg$parseParticleRef();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parsewhiteSpace();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseName();\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseeolWhiteSpace();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            s5 = peg$parseIndent();\n            if (s5 !== peg$FAILED) {\n              s6 = [];\n              s7 = peg$currPos;\n              s8 = peg$parseSameIndent();\n              if (s8 !== peg$FAILED) {\n                s9 = peg$parseRecipeParticleItem();\n                if (s9 !== peg$FAILED) {\n                  s8 = [s8, s9];\n                  s7 = s8;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$currPos;\n                s8 = peg$parseSameIndent();\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parseRecipeParticleItem();\n                  if (s9 !== peg$FAILED) {\n                    s8 = [s8, s9];\n                    s7 = s8;\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              }\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c126(s1, s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseRecipeParticleItem() {\n      var s0;\n\n      s0 = peg$parseRecipeParticleConnection();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseRecipeParticleSlotConnection();\n      }\n\n      return s0;\n    }\n\n    function peg$parseRecipeParticleConnection() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parselowerIdent();\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s1 = peg$c127;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c128); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseDirection();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            s5 = peg$parsewhiteSpace();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseConnectionTarget();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseeolWhiteSpace();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c129(s1, s3, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseRecipeParticleSlotConnection() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 7) === peg$c51) {\n        s1 = peg$c51;\n        peg$currPos += 7;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parselowerIdent();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            s5 = peg$parsewhiteSpace();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseName();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseeolWhiteSpace();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$currPos;\n                s7 = peg$parseIndent();\n                if (s7 !== peg$FAILED) {\n                  s8 = [];\n                  s9 = peg$currPos;\n                  s10 = peg$parseSameIndent();\n                  if (s10 !== peg$FAILED) {\n                    s11 = peg$parseRecipeParticleProvidedSlot();\n                    if (s11 !== peg$FAILED) {\n                      s10 = [s10, s11];\n                      s9 = s10;\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                  while (s9 !== peg$FAILED) {\n                    s8.push(s9);\n                    s9 = peg$currPos;\n                    s10 = peg$parseSameIndent();\n                    if (s10 !== peg$FAILED) {\n                      s11 = peg$parseRecipeParticleProvidedSlot();\n                      if (s11 !== peg$FAILED) {\n                        s10 = [s10, s11];\n                        s9 = s10;\n                      } else {\n                        peg$currPos = s9;\n                        s9 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s7 = [s7, s8];\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 === peg$FAILED) {\n                  s6 = null;\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c130(s3, s4, s6);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseRecipeParticleProvidedSlot() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 7) === peg$c53) {\n        s1 = peg$c53;\n        peg$currPos += 7;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c54); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parselowerIdent();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            s5 = peg$parsewhiteSpace();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseName();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseeolWhiteSpace();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c131(s3, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseRecipeConnection() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parseConnectionTarget();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseDirection();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsewhiteSpace();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseConnectionTarget();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseeolWhiteSpace();\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c132(s1, s3, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseRecipeSearch() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6) === peg$c133) {\n        s1 = peg$c133;\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c134); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsebackquotedString();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseeolWhiteSpace();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$currPos;\n              s6 = peg$parseIndent();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$currPos;\n                s8 = peg$parseSameIndent();\n                if (s8 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 6) === peg$c135) {\n                    s9 = peg$c135;\n                    peg$currPos += 6;\n                  } else {\n                    s9 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c136); }\n                  }\n                  if (s9 !== peg$FAILED) {\n                    s10 = [];\n                    s11 = peg$currPos;\n                    s12 = peg$parsewhiteSpace();\n                    if (s12 !== peg$FAILED) {\n                      s13 = peg$parsebackquotedString();\n                      if (s13 !== peg$FAILED) {\n                        s12 = [s12, s13];\n                        s11 = s12;\n                      } else {\n                        peg$currPos = s11;\n                        s11 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s11;\n                      s11 = peg$FAILED;\n                    }\n                    if (s11 !== peg$FAILED) {\n                      while (s11 !== peg$FAILED) {\n                        s10.push(s11);\n                        s11 = peg$currPos;\n                        s12 = peg$parsewhiteSpace();\n                        if (s12 !== peg$FAILED) {\n                          s13 = peg$parsebackquotedString();\n                          if (s13 !== peg$FAILED) {\n                            s12 = [s12, s13];\n                            s11 = s12;\n                          } else {\n                            peg$currPos = s11;\n                            s11 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s11;\n                          s11 = peg$FAILED;\n                        }\n                      }\n                    } else {\n                      s10 = peg$FAILED;\n                    }\n                    if (s10 !== peg$FAILED) {\n                      s11 = peg$parseeolWhiteSpace();\n                      if (s11 !== peg$FAILED) {\n                        s8 = [s8, s9, s10, s11];\n                        s7 = s8;\n                      } else {\n                        peg$currPos = s7;\n                        s7 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s7;\n                      s7 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n                if (s7 !== peg$FAILED) {\n                  s6 = [s6, s7];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n              if (s5 === peg$FAILED) {\n                s5 = null;\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c137(s3, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseDirection() {\n      var s0;\n\n      if (input.substr(peg$currPos, 2) === peg$c138) {\n        s0 = peg$c138;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c139); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c140) {\n          s0 = peg$c140;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c141); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s0 = peg$c142;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c143); }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseConnectionTarget() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$parseupperIdent();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parselowerIdent();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c144;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c145); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parselowerIdent();\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parsewhiteSpace();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseTagList();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c146(s1, s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseTagList();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c147(s1);\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseRecipeView() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 63) {\n        s1 = peg$c73;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.substr(peg$currPos, 3) === peg$c148) {\n          s1 = peg$c148;\n          peg$currPos += 3;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c149); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c150) {\n            s1 = peg$c150;\n            peg$currPos += 3;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c151); }\n          }\n          if (s1 === peg$FAILED) {\n            if (input.substr(peg$currPos, 6) === peg$c152) {\n              s1 = peg$c152;\n              peg$currPos += 6;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c153); }\n            }\n            if (s1 === peg$FAILED) {\n              if (input.substr(peg$currPos, 4) === peg$c154) {\n                s1 = peg$c154;\n                peg$currPos += 4;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c155); }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parsewhiteSpace();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseViewRef();\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parsewhiteSpace();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseName();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseeolWhiteSpace();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c156(s1, s2, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseTag() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 35) {\n        s1 = peg$c157;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c158); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (peg$c159.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c160); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c161.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c162); }\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c161.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c162); }\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c163();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseTagList() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$parseTag();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parsewhiteSpace();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseTagList();\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c164(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseSpaceTagList() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parsewhiteSpace();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseTagList();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c165(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseParticleRef() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$parseupperIdent();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseSpaceTagList();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c166(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseTagList();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c167(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 12) === peg$c168) {\n            s1 = peg$c168;\n            peg$currPos += 12;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c169); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsewhiteSpace();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parselowerIdent();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parseSpaceTagList();\n                if (s4 === peg$FAILED) {\n                  s4 = null;\n                }\n                if (s4 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c170(s3, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseViewRef() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parseid();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseSpaceTagList();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c171(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseupperIdent();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseSpaceTagList();\n          if (s2 === peg$FAILED) {\n            s2 = null;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c172(s1, s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseTagList();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c173(s1);\n          }\n          s0 = s1;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseRecipeSlot() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c174) {\n        s1 = peg$c174;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c175); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parsewhiteSpace();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseid();\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parsewhiteSpace();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseName();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseeolWhiteSpace();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c176(s2, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseExtendsList() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n      s0 = peg$currPos;\n      s1 = peg$parsewhiteSpace();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 7) === peg$c177) {\n          s2 = peg$c177;\n          peg$currPos += 7;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c178); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsewhiteSpace();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseupperIdent();\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$currPos;\n              s7 = peg$parsewhiteSpace();\n              if (s7 === peg$FAILED) {\n                s7 = null;\n              }\n              if (s7 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s8 = peg$c45;\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                }\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parsewhiteSpace();\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$parseupperIdent();\n                    if (s10 !== peg$FAILED) {\n                      s7 = [s7, s8, s9, s10];\n                      s6 = s7;\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$currPos;\n                s7 = peg$parsewhiteSpace();\n                if (s7 === peg$FAILED) {\n                  s7 = null;\n                }\n                if (s7 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s8 = peg$c45;\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsewhiteSpace();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parseupperIdent();\n                      if (s10 !== peg$FAILED) {\n                        s7 = [s7, s8, s9, s10];\n                        s6 = s7;\n                      } else {\n                        peg$currPos = s6;\n                        s6 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c179(s4, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseSchemaInline() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      s0 = peg$currPos;\n      s1 = peg$parseupperIdent();\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s1 = peg$c127;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c128); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 123) {\n            s3 = peg$c180;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c181); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$currPos;\n            s6 = peg$parseSchemaInlineField();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s8 = peg$c45;\n                peg$currPos++;\n              } else {\n                s8 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c46); }\n              }\n              if (s8 !== peg$FAILED) {\n                s9 = peg$parsewhiteSpace();\n                if (s9 !== peg$FAILED) {\n                  s8 = [s8, s9];\n                  s7 = s8;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              if (s7 === peg$FAILED) {\n                s7 = null;\n              }\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                s5 = peg$currPos;\n                s6 = peg$parseSchemaInlineField();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s8 = peg$c45;\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsewhiteSpace();\n                    if (s9 !== peg$FAILED) {\n                      s8 = [s8, s9];\n                      s7 = s8;\n                    } else {\n                      peg$currPos = s7;\n                      s7 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                  if (s7 === peg$FAILED) {\n                    s7 = null;\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s6 = [s6, s7];\n                    s5 = s6;\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              }\n            } else {\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 125) {\n                s5 = peg$c182;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c183); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c184(s1, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseSchemaInlineField() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$parseSchemaType();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseSchemaArity();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsewhiteSpace();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parselowerIdent();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c185(s1, s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseSchema() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6) === peg$c186) {\n        s1 = peg$c186;\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c187); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseTopLevelIdent();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseExtendsList();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseeolWhiteSpace();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$currPos;\n                s7 = peg$parseIndent();\n                if (s7 !== peg$FAILED) {\n                  s8 = [];\n                  s9 = peg$currPos;\n                  s10 = peg$parseSameIndent();\n                  if (s10 !== peg$FAILED) {\n                    s11 = peg$parseSchemaSection();\n                    if (s11 !== peg$FAILED) {\n                      s10 = [s10, s11];\n                      s9 = s10;\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s9;\n                    s9 = peg$FAILED;\n                  }\n                  while (s9 !== peg$FAILED) {\n                    s8.push(s9);\n                    s9 = peg$currPos;\n                    s10 = peg$parseSameIndent();\n                    if (s10 !== peg$FAILED) {\n                      s11 = peg$parseSchemaSection();\n                      if (s11 !== peg$FAILED) {\n                        s10 = [s10, s11];\n                        s9 = s10;\n                      } else {\n                        peg$currPos = s9;\n                        s9 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s7 = [s7, s8];\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 === peg$FAILED) {\n                  s6 = null;\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c188(s3, s4, s6);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseSchemaSection() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 9) === peg$c189) {\n        s1 = peg$c189;\n        peg$currPos += 9;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c190); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.substr(peg$currPos, 8) === peg$c191) {\n          s1 = peg$c191;\n          peg$currPos += 8;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c192); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseeolWhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parseIndent();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$currPos;\n            s7 = peg$parseSameIndent();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parseSchemaField();\n              if (s8 !== peg$FAILED) {\n                s9 = peg$parseeolWhiteSpace();\n                if (s9 !== peg$FAILED) {\n                  s7 = [s7, s8, s9];\n                  s6 = s7;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$currPos;\n                s7 = peg$parseSameIndent();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseSchemaField();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseeolWhiteSpace();\n                    if (s9 !== peg$FAILED) {\n                      s7 = [s7, s8, s9];\n                      s6 = s7;\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              }\n            } else {\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c193(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseSchemaArity() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 63) {\n        s0 = peg$c73;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseSchemaField() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseSchemaType();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parselowerIdent();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c194(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseSchemaType() {\n      var s0;\n\n      s0 = peg$parseSchemaPrimitiveType();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseSchemaUnionType();\n      }\n\n      return s0;\n    }\n\n    function peg$parseSchemaPrimitiveType() {\n      var s0;\n\n      if (input.substr(peg$currPos, 4) === peg$c195) {\n        s0 = peg$c195;\n        peg$currPos += 4;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c196); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 3) === peg$c197) {\n          s0 = peg$c197;\n          peg$currPos += 3;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c198); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 6) === peg$c199) {\n            s0 = peg$c199;\n            peg$currPos += 6;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c200); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 7) === peg$c201) {\n              s0 = peg$c201;\n              peg$currPos += 7;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c202); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 6) === peg$c203) {\n                s0 = peg$c203;\n                peg$currPos += 6;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c204); }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseSchemaUnionType() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c40;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c41); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseSchemaPrimitiveType();\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$currPos;\n            s6 = peg$parsewhiteSpace();\n            if (s6 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c205) {\n                s7 = peg$c205;\n                peg$currPos += 2;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c206); }\n              }\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parsewhiteSpace();\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parseSchemaPrimitiveType();\n                  if (s9 !== peg$FAILED) {\n                    s6 = [s6, s7, s8, s9];\n                    s5 = s6;\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = peg$parsewhiteSpace();\n              if (s6 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 2) === peg$c205) {\n                  s7 = peg$c205;\n                  peg$currPos += 2;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c206); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsewhiteSpace();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseSchemaPrimitiveType();\n                    if (s9 !== peg$FAILED) {\n                      s6 = [s6, s7, s8, s9];\n                      s5 = s6;\n                    } else {\n                      peg$currPos = s5;\n                      s5 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsewhiteSpace();\n              if (s5 === peg$FAILED) {\n                s5 = null;\n              }\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s6 = peg$c42;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c43); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c207(s3, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseVersion() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 64) {\n        s1 = peg$c1;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c2); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c208.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c209); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c208.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c209); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c210(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseIndent() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      peg$silentFails++;\n      s1 = peg$currPos;\n      s2 = [];\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s3 = peg$c211;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c212); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s3 = peg$c211;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c212); }\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s3 = peg$c213(s2);\n        if (s3) {\n          s3 = void 0;\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s1 !== peg$FAILED) {\n        peg$currPos = s0;\n        s0 = void 0;\n      } else {\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseSameIndent() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      s2 = peg$currPos;\n      s3 = [];\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s4 = peg$c211;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c212); }\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        if (input.charCodeAt(peg$currPos) === 32) {\n          s4 = peg$c211;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c212); }\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s4 = peg$c214(s3);\n        if (s4) {\n          s4 = void 0;\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s2 !== peg$FAILED) {\n        peg$currPos = s1;\n        s1 = void 0;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (input.charCodeAt(peg$currPos) === 32) {\n          s3 = peg$c211;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c212); }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s3 = peg$c211;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c212); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseSameOrMoreIndent() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      s2 = peg$currPos;\n      s3 = [];\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s4 = peg$c211;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c212); }\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        if (input.charCodeAt(peg$currPos) === 32) {\n          s4 = peg$c211;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c212); }\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s4 = peg$c215(s3);\n        if (s4) {\n          s4 = void 0;\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s2 !== peg$FAILED) {\n        peg$currPos = s1;\n        s1 = void 0;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (input.charCodeAt(peg$currPos) === 32) {\n          s3 = peg$c211;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c212); }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s3 = peg$c211;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c212); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c13();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseTopLevelIdent() {\n      var s0, s1;\n\n      s0 = peg$parseupperIdent();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parselowerIdent();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c216();\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parsebackquotedString() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 96) {\n        s1 = peg$c217;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c218); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c219.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c220); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c219.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c220); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 96) {\n            s3 = peg$c217;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c218); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c221(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseid() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 39) {\n        s1 = peg$c222;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c223); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c224.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c225); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c224.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c225); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 39) {\n            s3 = peg$c222;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c223); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c226(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseupperIdent() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c227.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c228); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        if (peg$c229.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c230); }\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          if (peg$c229.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c230); }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c231(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parselowerIdent() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c232.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c233); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        if (peg$c229.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c230); }\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          if (peg$c229.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c230); }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c231(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsewhiteSpace() {\n      var s0, s1;\n\n      s0 = [];\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c211;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c212); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s1 = peg$c211;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c212); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseeolWhiteSpace() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c234.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c235); }\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c234.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c235); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        peg$silentFails++;\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c236); }\n        }\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = void 0;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        if (peg$c234.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c235); }\n        }\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c234.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c235); }\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseeol();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseeolWhiteSpace();\n            if (s3 === peg$FAILED) {\n              s3 = null;\n            }\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsecomment();\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseeol() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 13) {\n        s1 = peg$c237;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c238); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 10) {\n          s2 = peg$c239;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c240); }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 13) {\n            s3 = peg$c237;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c238); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parsecomment() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c234.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c235); }\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c234.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c235); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 35) {\n          s2 = peg$c157;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c158); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c241) {\n            s2 = peg$c241;\n            peg$currPos += 2;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c242); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c11.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c12); }\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c11.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c12); }\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseeolWhiteSpace();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c243(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n\n      var indent = '';\n      var startIndent = '';\n      var indents = [];\n      var deprecatedCommentWarningShown = false;\n      function extractIndented(items) {\n        return items[1].map(item => item[1]);\n      }\n      function optional(result, extract, defaultValue) {\n        if (result != null) {\n          let value = extract(result);\n          if (value != null) {\n            return value;\n          }\n        }\n        return defaultValue == null ? null : defaultValue;\n      }\n      function checkNormal(result) {\n        if (['string', 'number', 'boolean'].includes(typeof result) || result === null) {\n          return;\n        }\n        if (result === undefined) {\n          throw new Error(`result was undefined`);\n        }\n        if (Array.isArray(result)) {\n          for (let item of result) {\n            checkNormal(item);\n          }\n          return;\n        }\n        if (!result.location) {\n          throw new Error(`no 'location' in ${JSON.stringify(result)}`);\n        }\n        if (!result.kind) {\n          throw new Error(`no 'kind' in ${JSON.stringify(result)}`);\n        }\n        for (let key of Object.keys(result)) {\n          if (['location', 'kind'].includes(key)) {\n            continue;\n          }\n          checkNormal(result[key]);\n        }\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n\n      throw peg$buildStructuredError(\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n})()\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/build/manifest-parser.js\n// module id = 51\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nexport default class AbstractDevtoolsChannel {\n  constructor() {\n    this.debouncedMessages = [];\n    this.debouncing = false;\n    this.ready = new Promise((resolve, reject) => {\n      this._makeReady = resolve;\n    });\n  }\n\n  send(message) {\n    this.debouncedMessages.push(message);\n    if (!this.debouncing) {\n      this.debouncing = true;\n      setTimeout(() => {\n        this._flush(this.debouncedMessages);\n        this.debouncedMessages = [];\n        this.debouncing = false;\n      }, 100);\n    }\n  }\n\n  _flush(messages) {\n    throw 'Not implemented in an abstract class';\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/debug/abstract-devtools-channel.js\n// module id = 52\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport DevtoolsChannel from '../../platform/devtools-channel-web.js';\n\nlet instance = null;\nexport default {\n  get: () => {\n    if (!instance) instance = new DevtoolsChannel();\n    return instance;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/debug/devtools-channel-provider.js\n// module id = 53\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2018 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n 'use strict';\n\nimport devtoolsChannelProvider from './devtools-channel-provider.js';\n\nexport default class OuterPortAttachment {\n  constructor(arcId) {\n    this._arcId = arcId;\n    this._callbackRegistry = {};\n    this._particleRegistry = {};\n  }\n\n  InstantiateParticle(particle, {id, spec, handles}) {\n    this._particleRegistry[id] = spec;\n  }\n\n  SimpleCallback({callback, data}) {\n    let callbackDetails = this._callbackRegistry[callback];\n    if (callbackDetails) {\n      // Copying callback data, as the callback can be used multiple times.\n      this._sendMessage(Object.assign({}, callbackDetails), data);\n    }\n  }\n\n  onSynchronize({handle, target, callback, modelCallback, type, particleId}) {\n    this._callbackRegistry[callback] = this._describeHandleCall(\n      {operation: `on-${type}`, handle, particleId});\n    this._callbackRegistry[modelCallback] = this._describeHandleCall(\n      {operation: 'sync-model', handle, particleId});\n  }\n\n  onHandleGet({handle, callback, particleId}) {\n    this._callbackRegistry[callback] = this._describeHandleCall(\n      {operation: 'get', handle, particleId});\n  }\n\n  onHandleToList({handle, callback, particleId}) {\n    this._callbackRegistry[callback] = this._describeHandleCall(\n      {operation: 'toList', handle, particleId});\n  }\n\n  onHandleSet({handle, data, particleId}) {\n    this._logHandleCall({operation: 'set', handle, data, particleId});\n  }\n\n  onHandleStore({handle, data, particleId}) {\n    this._logHandleCall({operation: 'store', handle, data, particleId});\n  }\n\n  onHandleClear({handle, particleId}) {\n    this._logHandleCall({operation: 'clear', handle, particleId});\n  }\n\n  onHandleRemove({handle, data, particleId}) {\n    this._logHandleCall({operation: 'remove', handle, data, particleId});\n  }\n\n  _logHandleCall(args) {\n    this._sendMessage(this._describeHandleCall(args), args.data);\n  }\n\n  _sendMessage(messageBody, data) {\n    messageBody.data = JSON.stringify(data);\n    messageBody.timestamp = Date.now();\n    devtoolsChannelProvider.get().send({messageType: 'dataflow', messageBody});\n  }\n\n  _describeHandleCall({operation, handle, particleId}) {\n    return {\n      arcId: this._arcId,\n      operation,\n      particle: this._describeParticle(particleId),\n      handle: this._describeHandle(handle)\n    };\n  }\n\n  _describeParticle(id) {\n    let particleSpec = this._particleRegistry[id];\n    return {\n      id,\n      name: particleSpec && particleSpec.name\n      // TODO: Send entire spec only once and refer to it by ID in the tool.\n    };\n  }\n\n  _describeHandle(handle) {\n    return {\n      id: handle.id,\n      storageKey: handle._storageKey,\n      name: handle.name,\n      description: handle.description,\n      type: this._describeHandleType(handle._type)\n    };\n  }\n\n  // TODO: This is fragile and incomplete. Change this into sending entire\n  //       handle object once and refer back to it via its ID in the tool.\n  _describeHandleType(handleType) {\n    switch (handleType.constructor.name) {\n      case 'Type':\n        return `${handleType.tag} ${this._describeHandleType(handleType.data)}`;\n      case 'Schema':\n        return handleType.name;\n      case 'Shape':\n        return 'Shape';\n    }\n    return '';\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/debug/outer-port-attachment.js\n// module id = 54\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport assert from '../platform/assert-web.js';\nimport {DescriptionFormatter} from './description.js';\n\nexport default class DescriptionDomFormatter extends DescriptionFormatter {\n  constructor(description) {\n    super(description);\n    this._nextID = 0;\n  }\n\n  _isSelectedDescription(desc) {\n    return super._isSelectedDescription(desc) || (!!desc.template && !!desc.model);\n  }\n\n  _populateParticleDescription(particle, descriptionByName) {\n    let result = super._populateParticleDescription(particle, descriptionByName);\n\n    if (descriptionByName['_template_']) {\n      result = Object.assign(result, {\n        template: descriptionByName['_template_'],\n        model: JSON.parse(descriptionByName['_model_'])\n      });\n    }\n\n    return result;\n  }\n\n  async _combineSelectedDescriptions(selectedDescriptions) {\n    let suggestionByParticleDesc = new Map();\n    await Promise.all(selectedDescriptions.map(async (particleDesc, index) => {\n      if (this.seenParticles.has(particleDesc._particle)) {\n        return;\n      }\n\n      let {template, model} = this._retrieveTemplateAndModel(particleDesc, index);\n\n      let success = await Promise.all(Object.keys(model).map(async tokenKey => {\n        let token = this._initHandleToken(model[tokenKey], particleDesc._particle);\n        let tokenValue = await this.tokenToString(token);\n\n        if (tokenValue == undefined) {\n          return false;\n        } else if (tokenValue && tokenValue.template && tokenValue.model) {\n          // Dom token.\n          template = template.replace(`{{${tokenKey}}}`, tokenValue.template);\n          delete model[tokenKey];\n          model = Object.assign(model, tokenValue.model);\n        } else { // Text token.\n          // Replace tokenKey, in case multiple selected suggestions use the same key.\n          let newTokenKey = `${tokenKey}${++this._nextID}`;\n          template = template.replace(`{{${tokenKey}}}`, `{{${newTokenKey}}}`);\n          delete model[tokenKey];\n          model[newTokenKey] = tokenValue;\n        }\n        return true;\n      }));\n\n      if (success.every(s => !!s)) {\n        suggestionByParticleDesc.set(particleDesc, {template, model});\n      }\n    }));\n\n    // Populate suggestions list while maintaining original particles order.\n    let suggestions = [];\n    selectedDescriptions.forEach(desc => {\n      if (suggestionByParticleDesc.has(desc)) {\n        suggestions.push(suggestionByParticleDesc.get(desc));\n      }\n    });\n\n    if (suggestions.length > 0) {\n      let result = this._joinDescriptions(suggestions);\n      result.template += '.';\n      return result;\n    }\n  }\n\n  _retrieveTemplateAndModel(particleDesc, index) {\n    if (particleDesc.template && particleDesc.model) {\n      return {template: particleDesc.template, model: particleDesc.model};\n    }\n    assert(particleDesc.pattern, 'Description must contain template and model, or pattern');\n    let template = '';\n    let model = {};\n    let tokens = this._initTokens(particleDesc.pattern, particleDesc._particle);\n\n    tokens.forEach((token, i) => {\n      if (token.text) {\n        template = template.concat(`${index == 0 && i == 0 ? token.text[0].toUpperCase() + token.text.slice(1) : token.text}`);\n      } else { // view or slot handle.\n        let sanitizedFullName = token.fullName.replace(/[.{}_\\$]/g, '');\n        let attribute = '';\n        // TODO(mmandlis): capitalize the data in the model instead.\n        if (i == 0) {\n          // Capitalize the first letter in the token.\n          template = template.concat(`<style>\n            [firstletter]::first-letter { text-transform: capitalize; }\n            [firstletter] {display: inline-block}\n            </style>`);\n          attribute = ' firstletter';\n        }\n        template = template.concat(`<span${attribute}>{{${sanitizedFullName}}}</span>`);\n        model[sanitizedFullName] = token.fullName;\n      }\n    });\n\n    return {template, model};\n  }\n\n  _joinDescriptions(descs) {\n    // // If all tokens are strings, just join them.\n    if (descs.every(desc => typeof desc === 'string')) {\n      return super._joinDescriptions(descs);\n    }\n\n    let result = {template: '', model: {}};\n    let count = descs.length;\n    descs.forEach((desc, i) => {\n      if (!desc.template || !desc.model) {\n        return;\n      }\n\n      result.template += desc.template;\n      result.model = Object.assign(result.model, desc.model);\n      let delim;\n      if (i < count - 2) {\n        delim = ', ';\n      } else if (i == count - 2) {\n        delim = ['', '', ' and ', ', and '][Math.min(3, count)];\n      }\n      if (delim) {\n        result.template += delim;\n      }\n    });\n    return result;\n  }\n\n  _joinTokens(tokens) {\n    // If all tokens are strings, just join them.\n    if (tokens.every(token => typeof token === 'string')) {\n      return super._joinTokens(tokens);\n    }\n\n    tokens = tokens.map(token => {\n      if (typeof token !== 'object') {\n        return {\n          template: `<span>{{text${++this._nextID}}}</span>`,\n          model: {[`text${this._nextID}`]: token}\n        };\n      }\n      return token;\n    });\n\n    let nonEmptyTokens = tokens.filter(token => token && !!token.template && !!token.model);\n    return {\n      template: nonEmptyTokens.map(token => token.template).join(''),\n      model: nonEmptyTokens.map(token => token.model).reduce((prev, curr) => Object.assign(prev, curr), {})\n    };\n  }\n\n  _combineDescriptionAndValue(token, description, viewValue) {\n    if (!!description.template && !!description.model) {\n      return {\n        template: `${description.template} (${viewValue.template})`,\n        model: Object.assign(description.model, viewValue.model)\n      };\n    }\n    let descKey = `${token.viewName}Description${++this._nextID}`;\n    return {\n      template: `<span>{{${descKey}}}</span> (${viewValue.template})`,\n      model: Object.assign({[descKey]: description}, viewValue.model)\n    };\n  }\n\n  _formatEntityProperty(viewName, properties, value) {\n    let key = `${viewName}${properties.join('')}Value${++this._nextID}`;\n    return {\n      template: `<b>{{${key}}}</b>`,\n      model: {[`${key}`]: value}\n    };\n  }\n\n  _formatSetView(viewName, viewList) {\n    let viewKey = `${viewName}${++this._nextID}`;\n    if (viewList[0].rawData.name) {\n      if (viewList.length > 2) {\n        return {\n          template: `<b>{{${viewKey}FirstName}}</b> plus <b>{{${viewKey}OtherCount}}</b> other items`,\n          model: {[`${viewKey}FirstName`]: viewList[0].rawData.name, [`${viewKey}OtherCount`]: viewList.length - 1}\n        };\n      }\n      return {\n        template: viewList.map((v, i) => `<b>{{${viewKey}${i}}}</b>`).join(', '),\n        model: Object.assign(...viewList.map((v, i) => ({[`${viewKey}${i}`]: v.rawData.name} )))\n      };\n    }\n    return {\n      template: `<b>{{${viewKey}Length}}</b> items`,\n      model: {[`${viewKey}Length`]: viewList.length}\n    };\n  }\n  _formatSingleton(viewName, viewVar) {\n    if (viewVar.rawData.name) {\n      return {\n        template: `<b>{{${viewName}Var}}</b>`,\n        model: {[`${viewName}Var`]: viewVar.rawData.name}\n      };\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/description-dom-formatter.js\n// module id = 55\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport assert from '../platform/assert-web.js';\nimport Slot from './slot.js';\nimport {DomContext, SetDomContext} from './dom-context.js';\n\nlet templates = new Map();\n\nclass DomSlot extends Slot {\n  constructor(consumeConn, arc, containerKind) {\n    super(consumeConn, arc);\n    this._templateName = [this.consumeConn.particle.name, this.consumeConn.name].concat(\n        Object.values(this.consumeConn.particle.connections).filter(conn => conn.type.isInterface).map(conn => conn.view.id)).join('::');\n    this._model = null;\n    this._observer = this._initMutationObserver();\n    this._containerKind = containerKind;\n  }\n\n  setContext(context) {\n    let wasNull = true;\n    if (this.getContext()) {\n      this.getContext().clear();\n      wasNull = false;\n    }\n\n    if (context) {\n      if (!this.getContext()) {\n        this._context = this._createDomContext();\n      }\n      this.getContext().initContext(context);\n      if (!wasNull) {\n        this._doRender();\n      }\n    } else {\n      this._context = null;\n    }\n  }\n  _createDomContext() {\n    if (this.consumeConn.slotSpec.isSet) {\n      return new SetDomContext(this._containerKind);\n    }\n    return new DomContext(null, this._containerKind);\n  }\n  _initMutationObserver() {\n    return new MutationObserver(async () => {\n      this._observer.disconnect();\n\n      if (this.getContext()) {\n        // Update inner slots.\n        this.getContext().initInnerContexts(this.consumeConn.slotSpec);\n        this.innerSlotsUpdateCallback(this);\n\n        // Reactivate the observer.\n        this.getContext().observe(this._observer);\n      }\n    });\n  }\n  isSameContext(context) {\n    return this.getContext().isEqual(context);\n  }\n\n  getTemplate() {\n    return templates.get(this._templateName);\n  }\n\n  // TODO(sjmiles): triggered when innerPEC sends Render message to outerPEC,\n  // (usually by request of DomParticle::render())\n  // `handler` is generated by caller (slot-composer::renderSlot())\n  async setContent(content, handler) {\n    if (!content || Object.keys(content).length == 0) {\n      if (this.getContext()) {\n        this.getContext().clear();\n      }\n      this._model = null;\n      return;\n    }\n    if (!this.getContext()) {\n      return;\n    }\n    if (content.template) {\n      if (this.getTemplate()) {\n        // Template is being replaced.\n        this.getContext().clear();\n      }\n      templates.set(this._templateName, DomContext.createTemplateElement(content.template));\n    }\n    this.eventHandler = handler;\n    if (Object.keys(content).indexOf('model') >= 0) {\n      if (content.model) {\n        this._model = Object.assign(content.model, await this.populateViewDescriptions());\n      } else {\n        this._model = undefined;\n      }\n    }\n    this._doRender();\n  }\n\n  _doRender() {\n    assert(this.getContext());\n\n    this.getContext().observe(this._observer);\n\n    // Initialize template, if possible.\n    if (this.getTemplate()) {\n      this.getContext().stampTemplate(this.getTemplate(), this.eventHandler);\n    }\n    // else {\n    // TODO: should trigger request to particle, if template missing?\n    //}\n\n    if (this._model) {\n      this.getContext().updateModel(this._model);\n    }\n  }\n  getInnerContext(slotName) {\n    return this.getContext() && this.getContext().getInnerContext(slotName);\n  }\n  constructRenderRequest() {\n    let request = ['model'];\n    if (!this.getTemplate()) {\n      request.push('template');\n    }\n    return request;\n  }\n  static findRootSlots(context) {\n    return new DomContext(context, this._containerKind).findRootSlots(context);\n  }\n}\n\nexport default DomSlot;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/dom-slot.js\n// module id = 56\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\n'use strict';\n\nimport InnerPec from './inner-PEC.js';\nimport MessageChannel from './message-channel.js';\nimport Loader from './loader.js';\n\n// TODO: Make this generic so that it can also be used in-browser, or add a\n// separate in-process browser pec-factory.\nexport default function(id) {\n  let channel = new MessageChannel();\n  new InnerPec(channel.port1, `${id}:inner`, new Loader());\n  return channel.port2;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/fake-pec-factory.js\n// module id = 57\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nexport default fetch;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/fetch-web.js\n// module id = 58\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\n\nimport assert from '../platform/assert-web.js';\nimport Type from './type.js';\n\n// TODO: relation identifier should incorporate key/value identifiers\nclass Identifier {\n  constructor(view, type, key) {\n    this.view = type;\n    this.type = type;\n    this.key = key;\n  }\n  toLiteral() {\n    return [this.view, this.type.toLiteral(), this.key];\n  }\n  static fromLiteral(data) {\n    let [view, literalType, key] = data;\n    return new Identifier(view, Type.fromLiteral(literalType), key);\n  }\n}\n\nexport default Identifier;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/identifier.js\n// module id = 59\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport Type from './type.js';\nimport handle from './handle.js';\n// import {define} from './particle.js';\nimport assert from '../platform/assert-web.js';\nimport {PECInnerPort} from './api-channel.js';\nimport ParticleSpec from './particle-spec.js';\nimport Schema from './schema.js';\n\nclass StorageProxy {\n  constructor(id, type, port, pec, name, version) {\n    this._id = id;\n    this._type = type;\n    this._port = port;\n    this._pec = pec;\n    this.name = name;\n    this._version = version;\n    this.state = 'outOfDate';\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  generateIDComponents() {\n    return this._pec.generateIDComponents();\n  }\n\n  on(type, callback, target, particleId) {\n    let dataFreeCallback = (d) => callback();\n    this.synchronize(type, dataFreeCallback, dataFreeCallback, target, particleId);\n  }\n\n  synchronize(type, modelCallback, callback, target, particleId) {\n    this._port.Synchronize({handle: this, modelCallback, callback, target, type, particleId});\n  }\n\n  get(particleId) {\n    return new Promise((resolve, reject) =>\n      this._port.HandleGet({callback: r => resolve(r), handle: this, particleId}));\n  }\n\n  toList(particleId) {\n    return new Promise((resolve, reject) =>\n      this._port.HandleToList({callback: r => resolve(r), handle: this, particleId}));\n  }\n\n  set(entity, particleId) {\n    this._port.HandleSet({data: entity, handle: this, particleId});\n  }\n\n  store(entity, particleId) {\n    this._port.HandleStore({data: entity, handle: this, particleId});\n  }\n\n  remove(entityId, particleId) {\n    this._port.HandleRemove({data: entityId, handle: this, particleId});\n  }\n\n  clear(particleId) {\n    this._port.HandleClear({handle: this, particleId});\n  }\n}\n\nclass InnerPEC {\n  constructor(port, idBase, loader) {\n    this._apiPort = new PECInnerPort(port);\n    this._particles = [];\n    this._idBase = idBase;\n    this._nextLocalID = 0;\n    this._loader = loader;\n    this._pendingLoads = [];\n\n    /*\n     * This code ensures that the relevant types are known\n     * in the scope object, because otherwise we can't do\n     * particleSpec resolution, which is currently a necessary\n     * part of particle construction.\n     *\n     * Possibly we should eventually consider having particle\n     * specifications separated from particle classes - and\n     * only keeping type information on the arc side.\n     */\n    this._apiPort.onDefineHandle = ({type, identifier, name, version}) => {\n      return new StorageProxy(identifier, type, this._apiPort, this, name, version);\n    };\n\n    this._apiPort.onCreateHandleCallback = ({type, id, name, callback}) => {\n      let proxy = new StorageProxy(id, type, this._apiPort, this, name, 0);\n      Promise.resolve().then(() => callback(proxy));\n      return proxy;\n    };\n\n    this._apiPort.onMapHandleCallback = ({id, callback}) => {\n      Promise.resolve().then(() => callback(id));\n      return id;\n    };\n\n    this._apiPort.onCreateSlotCallback = ({hostedSlotId, callback}) => {\n      Promise.resolve().then(() => callback(hostedSlotId));\n      return hostedSlotId;\n    };\n\n    this._apiPort.onInnerArcRender = ({transformationParticle, transformationSlotName, hostedSlotId, content}) => {\n      transformationParticle.renderHostedSlot(transformationSlotName, hostedSlotId, content);\n    };\n\n    this._apiPort.onDefineParticle = ({particleDefinition, particleFunction}) => {\n      let particle = define(particleDefinition, eval(particleFunction));\n      this._loader.registerParticle(particle);\n    };\n\n    this._apiPort.onStop = () => {\n      if (global.close) {\n        global.close();\n      }\n    };\n\n    this._apiPort.onInstantiateParticle =\n      ({id, spec, handles}) => this._instantiateParticle(id, spec, handles);\n\n    this._apiPort.onSimpleCallback = ({callback, data}) => callback(data);\n\n    this._apiPort.onConstructArcCallback = ({callback, arc}) => callback(arc);\n\n    this._apiPort.onAwaitIdle = ({version}) =>\n      this.idle.then(a => {\n        // TODO: dom-particles update is async, this is a workaround to allow dom-particles to\n        // update relevance, after handles are updated. Needs better idle signal.\n        setTimeout(() => { this._apiPort.Idle({version, relevance: this.relevance}); }, 0);\n      });\n\n    this._apiPort.onUIEvent = ({particle, slotName, event}) => particle.fireEvent(slotName, event);\n\n    this._apiPort.onStartRender = ({particle, slotName, contentTypes}) => {\n      /** @class Slot\n       * A representation of a consumed slot. Retrieved from a particle using\n       * particle.getSlot(name)\n       */\n      class Slotlet {\n        constructor(pec, particle, slotName) {\n          this._slotName = slotName;\n          this._particle = particle;\n          this._handlers = new Map();\n          this._pec = pec;\n          this._requestedContentTypes = new Set();\n        }\n        get particle() { return this._particle; }\n        get slotName() { return this._slotName; }\n        get isRendered() { return this._isRendered; }\n        /** @method render(content)\n         * renders content to the slot.\n         */\n        render(content) {\n          this._pec._apiPort.Render({particle, slotName, content});\n\n          Object.keys(content).forEach(key => { this._requestedContentTypes.delete(key); });\n          // Slot is considered rendered, if a non-empty content was sent and all requested content types were fullfilled.\n          this._isRendered = this._requestedContentTypes.size == 0 && (Object.keys(content).length > 0);\n        }\n        /** @method registerEventHandler(name, f)\n         * registers a callback to be invoked when 'name' event happens.\n         */\n        registerEventHandler(name, f) {\n          if (!this._handlers.has(name)) {\n            this._handlers.set(name, []);\n          }\n          this._handlers.get(name).push(f);\n        }\n        clearEventHandlers(name) {\n          this._handlers.set(name, []);\n        }\n        fireEvent(event) {\n          for (let handler of this._handlers.get(event.handler) || []) {\n            handler(event);\n          }\n        }\n      }\n\n      particle._slotByName.set(slotName, new Slotlet(this, particle, slotName));\n      particle.render(slotName, contentTypes);\n    };\n\n    this._apiPort.onStopRender = ({particle, slotName}) => {\n      assert(particle._slotByName.has(slotName),\n        `Stop render called for particle ${particle.name} slot ${slotName} without start render being called.`);\n      particle._slotByName.delete(slotName);\n    };\n  }\n\n  generateIDComponents() {\n    return {base: this._idBase, component: () => this._nextLocalID++};\n  }\n\n  generateID() {\n    return `${this._idBase}:${this._nextLocalID++}`;\n  }\n\n  innerArcHandle(arcId, particleId) {\n    let pec = this;\n    return {\n      createHandle: function(type, name) {\n        return new Promise((resolve, reject) =>\n          pec._apiPort.ArcCreateHandle({arc: arcId, type, name, callback: proxy => {\n            let v = handle.handleFor(proxy, proxy.type.isSetView, particleId);\n            v.entityClass = (proxy.type.isSetView ? proxy.type.primitiveType().entitySchema : proxy.type.entitySchema).entityClass();\n            resolve(v);\n          }}));\n      },\n      mapHandle: function(handle) {\n        return new Promise((resolve, reject) =>\n          pec._apiPort.ArcMapHandle({arc: arcId, handle, callback: id => {\n            resolve(id);\n          }}));\n      },\n      createSlot: function(transformationParticle, transformationSlotName, hostedParticleName, hostedSlotName) {\n        return new Promise((resolve, reject) =>\n          pec._apiPort.ArcCreateSlot({arc: arcId, transformationParticle, transformationSlotName, hostedParticleName, hostedSlotName, callback: hostedSlotId => {\n            resolve(hostedSlotId);\n          }}));\n      },\n      loadRecipe: function(recipe) {\n        // TODO: do we want to return a promise on completion?\n        return new Promise((resolve, reject) =>\n          pec._apiPort.ArcLoadRecipe({arc: arcId, recipe, callback: a => {\n            if (a == undefined)\n              resolve();\n            else\n              reject(a);\n          }}));\n      }\n    };\n  }\n\n  defaultCapabilitySet() {\n    return {\n      constructInnerArc: particle => {\n        return new Promise((resolve, reject) =>\n          this._apiPort.ConstructInnerArc({callback: arcId => {resolve(this.innerArcHandle(arcId, particle.id));}, particle}));\n      }\n    };\n  }\n\n  async _instantiateParticle(id, spec, proxies) {\n    let name = spec.name;\n    let resolve = null;\n    let p = new Promise((res, rej) => resolve = res);\n    this._pendingLoads.push(p);\n    let clazz = await this._loader.loadParticleClass(spec);\n    let capabilities = this.defaultCapabilitySet();\n    let particle = new clazz(); // TODO: how can i add an argument to DomParticle ctor?\n    particle.id = id;\n    particle.capabilities = capabilities;\n    this._particles.push(particle);\n\n    let handleMap = new Map();\n    proxies.forEach((value, key) => {\n      handleMap.set(key, handle.handleFor(value, value.type.isSetView, id, spec.connectionMap.get(key).isInput, spec.connectionMap.get(key).isOutput));\n    });\n\n    for (let localHandle of handleMap.values()) {\n      let type = localHandle.underlyingView().type;\n      let schemaModel;\n      if (type.isSetView && type.primitiveType().isEntity) {\n        schemaModel = type.primitiveType().entitySchema;\n      } else if (type.isEntity) {\n        schemaModel = type.entitySchema;\n      }\n\n      if (schemaModel)\n        localHandle.entityClass = schemaModel.entityClass();\n    }\n\n    return [particle, async () => {\n      resolve();\n      let idx = this._pendingLoads.indexOf(p);\n      this._pendingLoads.splice(idx, 1);\n      await particle.setViews(handleMap);\n    }];\n  }\n\n  get relevance() {\n    let rMap = new Map();\n    this._particles.forEach(p => {\n      if (p.relevances.length == 0)\n        return;\n      rMap.set(p, p.relevances);\n      p.relevances = [];\n    });\n    return rMap;\n  }\n\n  get busy() {\n    if (this._pendingLoads.length > 0)\n      return true;\n    for (let particle of this._particles) {\n      if (particle.busy) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  get idle() {\n    if (!this.busy) {\n      return Promise.resolve();\n    }\n    return Promise.all(this._pendingLoads.concat(this._particles.map(particle => particle.idle))).then(() => this.idle);\n  }\n}\n\nexport default InnerPEC;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/inner-PEC.js\n// module id = 60\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n\nexport default class ManifestMeta {\n  constructor() {\n    this.storageKey = null;\n    this.name = null;\n  }\n  apply(items) {\n    items.forEach(item => { this[item.key] = item.value; });\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/manifest-meta.js\n// module id = 61\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nclass MessagePort {\n  constructor(channel, id, other) {\n    this._channel = channel;\n    this._id = id;\n    this._other = other;\n    this._onmessage = undefined;\n  }\n\n  postMessage(message) {\n    this._channel._post(this._other, message);\n  }\n\n  set onmessage(f) {\n    this._onmessage = f;\n  }\n\n  close() {\n    this.postMessage = function() {};\n  }\n}\n\nclass MessageEvent {\n  constructor(message) {\n    this.data = message;\n  }\n}\n\nclass MessageChannel {\n  constructor() {\n    this.port1 = new MessagePort(this, 0, 1);\n    this.port2 = new MessagePort(this, 1, 0);\n    this._ports = [this.port1, this.port2];\n  }\n\n  async _post(id, message) {\n    message = JSON.parse(JSON.stringify(message));\n    if (this._ports[id]._onmessage) {\n      try {\n        // Yield so that we deliver the message asynchronously.\n        await 0;\n        await this._ports[id]._onmessage(new MessageEvent(message));\n      } catch (e) {\n        console.error('Exception in particle code\\n', e);\n      }\n    }\n  }\n}\n\nexport default MessageChannel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/message-channel.js\n// module id = 62\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport PEC from './particle-execution-context.js';\nimport assert from '../platform/assert-web.js';\nimport {PECOuterPort} from './api-channel.js';\nimport Manifest from './manifest.js';\n\n// TODO: fix\nimport Loader from './loader.js';\n\nclass OuterPEC extends PEC {\n  constructor(port, slotComposer, arc) {\n    super();\n    this._particles = [];\n    this._apiPort = new PECOuterPort(port);\n    this._arc = arc;\n    this._nextIdentifier = 0;\n    this.slotComposer = slotComposer;\n\n    this._apiPort.onRender = ({particle, slotName, content}) => {\n      if (this.slotComposer) {\n        this.slotComposer.renderSlot(particle, slotName, content);\n      }\n    };\n\n    this._apiPort.onSynchronize = async ({handle, target, callback, modelCallback, type}) => {\n      let model;\n      if (handle.toList == undefined) {\n        model = await handle.get();\n      } else {\n        model = await handle.toList();\n      }\n      this._apiPort.SimpleCallback({callback: modelCallback, data: model}, target);\n      handle.on(type, data => this._apiPort.SimpleCallback({callback, data}), target);\n    };\n\n    this._apiPort.onHandleGet = async ({handle, callback}) => {\n      this._apiPort.SimpleCallback({callback, data: await handle.get()});\n    };\n\n    this._apiPort.onHandleToList = async ({handle, callback}) => {\n      this._apiPort.SimpleCallback({callback, data: await handle.toList()});\n    };\n\n    this._apiPort.onHandleSet = ({handle, data}) => {handle.set(data);};\n    this._apiPort.onHandleStore = ({handle, data}) => handle.store(data);\n    this._apiPort.onHandleClear = ({handle}) => handle.clear();\n    this._apiPort.onHandleRemove = ({handle, data}) => handle.remove(data);\n\n    this._apiPort.onIdle = ({version, relevance}) => {\n      if (version == this._idleVersion) {\n        this._idlePromise = undefined;\n        this._idleResolve(relevance);\n      }\n    };\n\n    this._apiPort.onConstructInnerArc = ({callback, particle}) => {\n      let arc = {particle};\n      this._apiPort.ConstructArcCallback({callback, arc});\n    };\n\n    this._apiPort.onArcCreateHandle = async ({callback, arc, type, name}) => {\n      let handle = await this._arc.createHandle(type, name);\n      this._apiPort.CreateHandleCallback(handle, {type, name, callback, id: handle.id});\n    };\n\n    this._apiPort.onArcMapHandle = async ({callback, arc, handle}) => {\n      assert(this._arc.findHandleById(handle.id), `Cannot map nonexistent handle ${handle.id}`);\n      // TODO: create hosted handles map with specially generated ids instead of returning the real ones?\n      this._apiPort.MapHandleCallback({}, {callback, id: handle.id});\n    };\n\n    this._apiPort.onArcCreateSlot = ({callback, arc, transformationParticle, transformationSlotName, hostedParticleName, hostedSlotName}) => {\n      let hostedSlotId;\n      if (this.slotComposer) {\n        hostedSlotId = this.slotComposer.createHostedSlot(transformationParticle, transformationSlotName, hostedParticleName, hostedSlotName);\n      }\n      this._apiPort.CreateSlotCallback({}, {callback, hostedSlotId});\n    };\n\n    this._apiPort.onArcLoadRecipe = async ({arc, recipe, callback}) => {\n      let manifest = await Manifest.parse(recipe, {loader: this._arc._loader, fileName: ''});\n      let error = undefined;\n      let recipe0 = manifest.recipes[0];\n      if (recipe0) {\n        for (let handle of recipe0.views) {\n          handle.mapToView(this._arc.findHandleById(handle.id));\n        }\n        if (recipe0.normalize()) {\n          if (recipe0.isResolved()) {\n            this._arc.instantiate(recipe0, arc);\n          } else {\n            error = `Recipe is not resolvable ${recipe0.toString({showUnresolved: true})}`;\n          }\n        } else {\n          error = 'Recipe could not be normalized';\n        }\n      } else {\n        error = 'No recipe defined';\n      }\n      this._apiPort.SimpleCallback({callback, data: error});\n    };\n  }\n\n  stop() {\n    this._apiPort.Stop();\n  }\n\n  get idle() {\n    if (this._idlePromise == undefined) {\n      this._idlePromise = new Promise((resolve, reject) => {\n        this._idleResolve = resolve;\n      });\n    }\n    this._idleVersion = this._nextIdentifier;\n    this._apiPort.AwaitIdle({version: this._nextIdentifier++});\n    return this._idlePromise;\n  }\n\n  get messageCount() {\n    return this._apiPort.messageCount;\n  }\n\n  sendEvent(particle, slotName, event) {\n    this._apiPort.UIEvent({particle, slotName, event});\n  }\n\n  instantiate(particleSpec, id, spec, handles, lastSeenVersion) {\n    handles.forEach(handle => {\n      let version = lastSeenVersion.get(handle.id) || 0;\n      this._apiPort.DefineHandle(handle, {type: handle.type, name: handle.name,\n                                       version});\n    });\n\n    // TODO: Can we just always define the particle and map a handle for use in later\n    //       calls to InstantiateParticle?\n    if (spec._model._isInline) {\n      this._apiPort.DefineParticle({\n        particleDefinition: spec._model._inlineDefinition,\n        particleFunction: spec._model._inlineUpdateFunction\n      });\n    }\n\n    // TODO: rename this concept to something like instantiatedParticle, handle or registration.\n    this._apiPort.InstantiateParticle(particleSpec, {id, spec, handles});\n    return particleSpec;\n  }\n  startRender({particle, slotName, contentTypes}) {\n    this._apiPort.StartRender({particle, slotName, contentTypes});\n  }\n  stopRender({particle, slotName}) {\n    this._apiPort.StopRender({particle, slotName});\n  }\n  innerArcRender(transformationParticle, transformationSlotName, hostedSlotId, content) {\n    this._apiPort.InnerArcRender({transformationParticle, transformationSlotName, hostedSlotId, content});\n  }\n  initDebug() {\n    this._apiPort.initDebug(this._arc.id);\n  }\n}\n\nexport default OuterPEC;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/outer-PEC.js\n// module id = 63\n// module chunks = 0","// @license\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\n\nclass ParticleExecutionContext {\n  constructor() {\n  }\n\n  // Instantiates `particle` in this context, connecting `views` to the particle's inputs and outputs.\n  // `mutateCallback` will be called each time the particle mutates a view or entity.\n  // Returns an identifier to refer to the particle (in `dispatch`).\n  instantiate(particle, views, mutateCallback) {\n    // views => {name => viewId}\n    throw 'unimplemented';\n  }\n\n  // Dispatches an event to the particle identified by `particleId` for the view or entity identified\n  // by `entityId` concerning `eventDetails. The `morePending` flag indicates whether there are any\n  // known further events to be dispatched to the same particle.\n  dispatch(particleId, entityId, eventDetails, morePending) {\n    throw 'unimplemented';\n  }\n\n  // Returns a promise which resolves when the PEC becomes idle (no known input processing).\n  get idle() {\n    throw 'unimplemented';\n  }\n\n  // Returns a promise which resolves to a map from particle identifier to a list of the relevance\n  // entries generated by that particle.\n  get relevance() {\n    throw 'unimplemented';\n  }\n}\n\nexport default ParticleExecutionContext;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/particle-execution-context.js\n// module id = 64\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport util from './util.js';\n\nclass ConnectionConstraint {\n  constructor(from, fromConnection, to, toConnection) {\n    this.fromParticle = from;\n    this.fromConnection = fromConnection;\n    this.toParticle = to;\n    this.toConnection = toConnection;\n    Object.freeze(this);\n  }\n\n  _copyInto(recipe) {\n    return recipe.newConnectionConstraint(this.fromParticle, this.fromConnection, this.toParticle, this.toConnection);\n  }\n\n  _compareTo(other) {\n    let cmp;\n    if ((cmp = util.compareStrings(this.fromParticle.name, other.fromParticle.name)) != 0) return cmp;\n    if ((cmp = util.compareStrings(this.fromConnection, other.fromConnection)) != 0) return cmp;\n    if ((cmp = util.compareStrings(this.toParticle.name, other.toParticle.name)) != 0) return cmp;\n    if ((cmp = util.compareStrings(this.toConnection, other.toConnection)) != 0) return cmp;\n    return 0;\n  }\n\n  toString() {\n    return `${this.fromParticle.name}.${this.fromConnection} -> ${this.toParticle.name}.${this.toConnection}`;\n  }\n}\n\nexport default ConnectionConstraint;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/connection-constraint.js\n// module id = 65\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nexport default async function(str) {\n  let buffer = new TextEncoder('utf-8').encode(str);\n  let digest = await crypto.subtle.digest('SHA-1', buffer);\n  return Array.from(new Uint8Array(digest)).map(x => ('00' + x.toString(16)).slice(-2)).join('');\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/digest-web.js\n// module id = 66\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport assert from '../../platform/assert-web.js';\nimport util from './util.js';\n\nclass HandleConnection {\n  constructor(name, particle) {\n    assert(particle);\n    assert(particle.recipe);\n    this._recipe = particle.recipe;\n    this._name = name;\n    this._tags = [];\n    this._type = undefined;\n    this._rawType = undefined;\n    this._direction = undefined;\n    this._particle = particle;\n    this._view = undefined;\n  }\n\n  _clone(particle, cloneMap) {\n    if (cloneMap.has(this)) {\n      return cloneMap.get(this);\n    }\n    let handleConnection = new HandleConnection(this._name, particle);\n    handleConnection._tags = [...this._tags];\n    handleConnection._type = this._type;\n    handleConnection._rawType = this._rawType;\n    handleConnection._direction = this._direction;\n    if (this._view != undefined) {\n      handleConnection._view = cloneMap.get(this._view);\n      assert(handleConnection._view !== undefined);\n      handleConnection._view.connections.push(handleConnection);\n    }\n    cloneMap.set(this, handleConnection);\n    return handleConnection;\n  }\n\n  _normalize() {\n    this._tags.sort();\n    // TODO: type?\n    Object.freeze(this);\n  }\n\n  _compareTo(other) {\n    let cmp;\n    if ((cmp = util.compareComparables(this._particle, other._particle)) != 0) return cmp;\n    if ((cmp = util.compareStrings(this._name, other._name)) != 0) return cmp;\n    if ((cmp = util.compareArrays(this._tags, other._tags, util.compareStrings)) != 0) return cmp;\n    if ((cmp = util.compareComparables(this._view, other._view)) != 0) return cmp;\n    // TODO: add type comparison\n    // if ((cmp = util.compareStrings(this._type, other._type)) != 0) return cmp;\n    if ((cmp = util.compareStrings(this._direction, other._direction)) != 0) return cmp;\n    return 0;\n  }\n\n  get recipe() { return this._recipe; }\n  get name() { return this._name; } // Parameter name?\n  get tags() { return this._tags; }\n  get type() {\n    if (this._type)\n      return this._type;\n    return this._rawType;\n  }\n  get rawType() {\n    return this._rawType;\n  }\n  get direction() { return this._direction; } // in/out\n  get isInput() {\n    return this.direction == 'in' || this.direction == 'inout';\n  }\n  get isOutput() {\n    return this.direction == 'out' || this.direction == 'inout';\n  }\n  get view() { return this._view; } // View?\n  get particle() { return this._particle; } // never null\n\n  set tags(tags) { this._tags = tags; }\n  set type(type) {\n    this._rawType = type;\n    this._type = undefined;\n    this._resetViewType();\n  }\n\n  set direction(direction) {\n    this._direction = direction;\n    this._resetViewType();\n  }\n\n  get spec() {\n    return this.particle.spec.connectionMap.get(this.name);\n  }\n\n  get isOptional() {\n    return this.spec.isOptional;\n  }\n\n  _isValid() {\n    if (this.direction && !['in', 'out', 'inout', 'host'].includes(this.direction)) {\n      return false;\n    }\n    if (this.type && this.particle && this.particle.spec) {\n      let connectionSpec = this.particle.spec.connectionMap.get(this.name);\n      if (connectionSpec) {\n        // TODO: this shouldn't be a direct equals comparison\n        if (!this.rawType.equals(connectionSpec.type)) {\n          return false;\n        }\n        if (this.direction != connectionSpec.direction) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  isResolved(options) {\n    assert(Object.isFrozen(this));\n\n    if (this.isOptional) {\n      return true;\n    }\n\n    // TODO: This should use this._type, or possibly not consider type at all.\n    if (!this.type) {\n      if (options) {\n        options.details = 'missing type';\n      }\n      return false;\n    }\n    if (!this._direction) {\n      if (options) {\n        options.details = 'missing direction';\n      }\n      return false;\n    }\n    if (!this.view) {\n      if (options) {\n        options.details = 'missing view';\n      }\n      return false;\n    }\n    return true;\n  }\n\n  _resetViewType() {\n    if (this._view)\n      this._view._type = undefined;\n  }\n\n  connectToView(view) {\n    assert(view.recipe == this.recipe);\n    this._view = view;\n    this._resetViewType();\n    this._view.connections.push(this);\n  }\n\n  toString(nameMap, options) {\n    let result = [];\n    result.push(this.name || '*');\n    // TODO: better deal with unspecified direction.\n    result.push({'in': '<-', 'out': '->', 'inout': '='}[this.direction] || this.direction || '=');\n    if (this.view) {\n      result.push(`${(nameMap && nameMap.get(this.view)) || this.view.localName}`);\n    }\n    result.push(...this.tags);\n\n    if (options && options.showUnresolved) {\n      if (!this.isResolved(options)) {\n        result.push(`// unresolved handle-connection: ${options.details}`);\n      }\n    }\n\n    return result.join(' ');\n  }\n}\n\nexport default HandleConnection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/handle-connection.js\n// module id = 67\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport assert from '../../platform/assert-web.js';\nimport util from './util.js';\nimport TypeChecker from './type-checker.js';\n\nclass Handle {\n  constructor(recipe) {\n    assert(recipe);\n    this._recipe = recipe;\n    this._id = null;\n    this._localName = undefined;\n    this._tags = [];\n    this._type = undefined;\n    this._fate = null;\n    // TODO: replace originalFate and originalId with more generic mechanism for tracking\n    // how and from what the recipe was generated.\n    this._originalFate = null;\n    this._originalId = null;\n    this._connections = [];\n    this._mappedType = undefined;\n    this._storageKey = undefined;\n  }\n\n  _copyInto(recipe) {\n    let view = undefined;\n    if (this._id !== null && ['map', 'use', 'copy'].includes(this.fate))\n      view = recipe.findView(this._id);\n\n    if (view == undefined) {\n      view = recipe.newView();\n      view._id = this._id;\n      view._tags = [...this._tags];\n      view._type = this._type;\n      view._fate = this._fate;\n      view._originalFate = this._originalFate;\n      view._originalId = this._originalId;\n      view._mappedType = this._mappedType;\n      view._storageKey = this._storageKey;\n\n      // the connections are re-established when Particles clone their\n      // attached HandleConnection objects.\n      view._connections = [];\n    }\n    return view;\n  }\n\n  _startNormalize() {\n    this._localName = null;\n    this._tags.sort();\n    // TODO: type?\n  }\n\n  _finishNormalize() {\n    for (let connection of this._connections) {\n      assert(Object.isFrozen(connection), `View connection '${connection.name}' is not frozen.`);\n    }\n    this._connections.sort(util.compareComparables);\n    Object.freeze(this);\n  }\n\n  _compareTo(other) {\n    let cmp;\n    if ((cmp = util.compareStrings(this._id, other._id)) != 0) return cmp;\n    if ((cmp = util.compareStrings(this._localName, other._localName)) != 0) return cmp;\n    if ((cmp = util.compareArrays(this._tags, other._tags, util.compareStrings)) != 0) return cmp;\n    // TODO: type?\n    if ((cmp = util.compareStrings(this.fate, other.fate)) != 0) return cmp;\n    return 0;\n  }\n\n  // a resolved View has either an id or create=true\n  get fate() { return this._fate || '?'; }\n  set fate(fate) {\n    if (this._originalFate == null) {\n      this._originalFate = this._fate;\n    }\n    this._fate = fate;\n  }\n  get originalFate() { return this._originalFate || '?'; }\n  get originalId() { return this._originalId; }\n  get recipe() { return this._recipe; }\n  get tags() { return this._tags; } // only tags owned by the view\n  set tags(tags) { this._tags = tags; }\n  get type() { return this._type; } // nullable\n  get id() { return this._id; }\n  set id(id) {\n    if (!this._originalId) {\n      this._originalId = this._id;\n    }\n    this._id = id;\n  }\n  mapToView(view) {\n    this._id = view.id;\n    this._type = undefined;\n    this._mappedType = view.type;\n    this._storageKey = view.storageKey;\n  }\n  get localName() { return this._localName; }\n  set localName(name) { this._localName = name; }\n  get connections() { return this._connections; } // HandleConnection*\n  get storageKey() { return this._storageKey; }\n  set storageKey(key) { this._storageKey = key; }\n\n  _isValid() {\n    let typeSet = [];\n    if (this._mappedType)\n      typeSet.push({type: this._mappedType});\n    let tags = new Set();\n    for (let connection of this._connections) {\n      // A remote view cannot be connected to an output param.\n      if (this.fate == 'map' && ['out', 'inout'].includes(connection.direction)) {\n        return false;\n      }\n      if (connection.type)\n        typeSet.push({type: connection.type, direction: connection.direction, connection});\n      connection.tags.forEach(tag => tags.add(tag));\n    }\n    let {type, valid} = TypeChecker.processTypeList(typeSet);\n    if (valid) {\n      this._type = type.type;\n      this._tags.forEach(tag => tags.add(tag));\n      this._tags = [...tags];\n    }\n    return valid;\n  }\n\n  isResolved(options) {\n    assert(Object.isFrozen(this));\n    if (!this._type) {\n      if (options) {\n        options.details = 'missing type';\n      }\n      return false;\n    }\n    switch (this.fate) {\n      case '?': {\n        if (options) {\n          options.details = 'missing fate';\n        }\n        return false;\n      }\n      case 'copy':\n      case 'map':\n      case 'use': {\n        if (options && this.id === null) {\n          options.details = 'missing id';\n        }\n        return this.id !== null;\n      }\n      case 'create':\n        return true;\n      default: {\n        if (options) {\n          options.details = `invalid fate ${this.fate}`;\n        }\n        assert(false, `Unexpected fate: ${this.fate}`);\n      }\n    }\n  }\n\n  toString(nameMap, options) {\n    // TODO: type? maybe output in a comment\n    let result = [];\n    result.push(this.fate);\n    if (this.id) {\n      result.push(`'${this.id}'`);\n    }\n    result.push(...this.tags);\n    result.push(`as ${(nameMap && nameMap.get(this)) || this.localName}`);\n    if (this.type) {\n      result.push('//');\n      result.push(this.type.toPrettyString());\n    }\n    if (options && options.showUnresolved) {\n      let options = {};\n      if (!this.isResolved(options)) {\n        result.push(` // unresolved view: ${options.details}`);\n      }\n    }\n\n    return result.join(' ');\n  }\n}\n\nexport default Handle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/handle.js\n// module id = 68\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport assert from '../../platform/assert-web.js';\nimport SlotConnection from './slot-connection.js';\nimport HandleConnection from './handle-connection.js';\nimport util from './util.js';\n\nclass Particle {\n  constructor(recipe, name) {\n    assert(recipe);\n    this._recipe = recipe;\n    this._id = undefined;\n    this._name = name;\n    this._localName = undefined;\n    this._spec = undefined;\n    this._tags = [];\n    this._verbs = [];\n\n    this._connections = {};\n    // TODO: replace with constraint connections on the recipe\n    this._unnamedConnections = [];\n    this._consumedSlotConnections = {}; // map of consumed Slot connections by slot name.\n  }\n\n  _copyInto(recipe, cloneMap) {\n    let particle = recipe.newParticle(this._name);\n    particle._id = this._id;\n    particle._tags = [...this._tags];\n    particle._verbs = [...this._verbs];\n    particle._spec = this._spec;\n\n    Object.keys(this._connections).forEach(key => {\n      particle._connections[key] = this._connections[key]._clone(particle, cloneMap);\n    });\n    particle._unnamedConnections = this._unnamedConnections.map(connection => connection._clone(particle, cloneMap));\n    Object.keys(this._consumedSlotConnections).forEach(key => {\n      particle._consumedSlotConnections[key] = this._consumedSlotConnections[key]._clone(particle, cloneMap);\n    });\n\n    return particle;\n  }\n\n  _startNormalize() {\n    this._localName = null;\n    this._tags.sort();\n    this._verbs.sort();\n    let normalizedConnections = {};\n    for (let key of (Object.keys(this._connections).sort())) {\n      normalizedConnections[key] = this._connections[key];\n    }\n    this._connections = normalizedConnections;\n\n    let normalizedSlotConnections = {};\n    for (let key of (Object.keys(this._consumedSlotConnections).sort())) {\n      normalizedSlotConnections[key] = this._consumedSlotConnections[key];\n    }\n    this._consumedSlotConnections = normalizedSlotConnections;\n  }\n\n  _finishNormalize() {\n    this._unnamedConnections.sort(util.compareComparables);\n    Object.freeze(this);\n  }\n\n  _compareTo(other) {\n    let cmp;\n    if ((cmp = util.compareStrings(this._id, other._id)) != 0) return cmp;\n    if ((cmp = util.compareStrings(this._name, other._name)) != 0) return cmp;\n    if ((cmp = util.compareStrings(this._localName, other._localName)) != 0) return cmp;\n    // TODO: spec?\n    if ((cmp = util.compareArrays(this._tags, other._tags, util.compareStrings)) != 0) return cmp;\n    if ((cmp = util.compareArrays(this._verbs, other._verbs, util.compareStrings)) != 0) return cmp;\n    // TODO: slots\n    return 0;\n  }\n\n  _isValid() {\n    if (!this.spec) {\n      return true;\n    }\n    if (!this.name && !this.primaryVerb) {\n      // Must have either name of a verb\n      return false;\n    }\n    // TODO: What\n    return true;\n  }\n\n  isResolved(options) {\n    assert(Object.isFrozen(this));\n    // TODO: slots\n    if (this.consumedSlotConnections.length > 0) {\n      let fulfilledSlotConnections = this.consumedSlotConnections.filter(connection => connection.targetSlot !== undefined);\n      if (fulfilledSlotConnections.length == 0) {\n        if (options && options.showUnresolved) {\n          options.details = 'unfullfilled slot connections';\n        }\n        return false;\n      }\n    }\n    if (!this.spec) {\n      if (options && options.showUnresolved) {\n        options.details = 'missing spec';\n      }\n      return false;\n    }\n    if (this.spec.connectionMap.size != Object.keys(this._connections).length) {\n      if (options && options.showUnresolved) {\n        options.details = 'unresolved connections';\n      }\n      return false;\n    }\n    if (this.unnamedConnections.length != 0) {\n      if (options && options.showUnresolved) {\n        options.details = `${this.unnamedConnections.length} unnamed connections`;\n      }\n      return false;\n    }\n    return true;\n  }\n\n  get recipe() { return this._recipe; }\n  get localName() { return this._localName; }\n  set localName(name) { this._localName = name; }\n  get id() { return this._id; } // Not resolved until we have an ID.\n  get name() { return this._name; }\n  set name(name) { this._name = name; }\n  get spec() { return this._spec; }\n  get tags() { return this._tags; }\n  set tags(tags) { this._tags = tags; }\n  get connections() { return this._connections; } // {parameter -> HandleConnection}\n  get unnamedConnections() { return this._unnamedConnections; } // HandleConnection*\n  get consumedSlotConnections() { return this._consumedSlotConnections; }\n  get primaryVerb() { if (this._verbs.length > 0) return this._verbs[0]; }\n  set verbs(verbs) { this._verbs = verbs; }\n\n  set spec(spec) {\n    this._spec = spec;\n    for (let connectionName of spec.connectionMap.keys()) {\n      let speccedConnection = spec.connectionMap.get(connectionName);\n      let connection = this.connections[connectionName];\n      if (connection == undefined) {\n        connection = this.addConnectionName(connectionName);\n      }\n      // TODO: don't just overwrite here, check that the types\n      // are compatible if one already exists.\n      connection.type = speccedConnection.type;\n      connection.direction = speccedConnection.direction;\n    }\n    spec.slots.forEach(slotSpec => {\n      if (this._consumedSlotConnections[slotSpec.name] == undefined)\n        this.addSlotConnection(slotSpec.name);\n      this._consumedSlotConnections[slotSpec.name].slotSpec = slotSpec;\n    });\n  }\n\n  addUnnamedConnection() {\n    let connection = new HandleConnection(undefined, this);\n    this._unnamedConnections.push(connection);\n    return connection;\n  }\n\n  addConnectionName(name) {\n    assert(this._connections[name] == undefined);\n    this._connections[name] = new HandleConnection(name, this);\n    return this._connections[name];\n  }\n\n  allConnections() {\n    return Object.values(this._connections).concat(this._unnamedConnections);\n  }\n\n  ensureConnectionName(name) {\n    return this._connections[name] || this.addConnectionName(name);\n  }\n\n  getConnectionByName(name) {\n    return this._connections[name];\n  }\n\n  nameConnection(connection, name) {\n    assert(!this._connections[name].view, `Connection \"${name}\" already has a view`);\n\n    let idx = this._unnamedConnections.indexOf(connection);\n    assert(idx >= 0, `Cannot name '${name}' nonexistent unnamed connection.`);\n    connection._name = name;\n\n    connection.type = this._connections[name].type;\n    if (connection.direction != this._connections[name].direction) {\n      assert(connection.direction == 'inout',\n             `Unnamed connection cannot adjust direction ${connection.direction} to ${name}'s direction ${this._connections[name].direction}`);\n      connection.direction = this._connections[name].direction;\n    }\n\n    this._connections[name] = connection;\n    this._unnamedConnections.splice(idx, 1);\n  }\n\n  addSlotConnection(name) {\n    let slotConn = new SlotConnection(name, this);\n    this._consumedSlotConnections[name] = slotConn;\n    return slotConn;\n  }\n\n  toString(nameMap, options) {\n    let result = [];\n    // TODO: we need at least name or tags\n    if (this.name) {\n      result.push(this.name);\n      result.push(...this.tags);\n\n      result.push(`as ${(nameMap && nameMap.get(this)) || this.localName}`);\n      if (this.primaryVerb && this.primaryVerb != this.name) {\n        result.push(`// verb=${this.primaryVerb}`);\n      }\n    } else { // verb must exist, if there is no name.\n      result.push(`particle can ${this.primaryVerb}`);\n    }\n    if (options && options.showUnresolved) {\n      if (!this.isResolved(options)) {\n        result.push(`// unresolved particle: ${options.details}`);\n      }\n    }\n\n    result = [result.join(' ')];\n\n    for (let connection of this.unnamedConnections) {\n      result.push(connection.toString(nameMap, options).replace(/^|(\\n)/g, '$1  '));\n    }\n    for (let connection of Object.values(this.connections)) {\n      result.push(connection.toString(nameMap, options).replace(/^|(\\n)/g, '$1  '));\n    }\n    for (let slotConnection of Object.values(this._consumedSlotConnections)) {\n      result.push(slotConnection.toString(nameMap, options).replace(/^|(\\n)/g, '$1  '));\n    }\n    return result.join('\\n');\n  }\n}\n\nexport default Particle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/particle.js\n// module id = 69\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport assert from '../../platform/assert-web.js';\nimport util from './util.js';\n\nclass SlotConnection {\n  constructor(name, particle) {\n    assert(particle);\n    assert(particle.recipe);\n    assert(name);\n\n    this._recipe = particle.recipe;\n    this._particle = particle;\n    this._name = name;\n    this._slotSpec = undefined; // isRequired + formFactor\n    this._targetSlot = undefined; // Slot?\n    this._providedSlots = {}; // Slot*\n  }\n\n  get recipe() { return this._recipe; }\n  get particle() { return this._particle; }\n  get name() { return this._name; }\n  get slotSpec() { return this._slotSpec; }\n  get targetSlot() { return this._targetSlot; }\n  get providedSlots() { return this._providedSlots; }\n\n  set slotSpec(slotSpec) {\n    assert(this.name == slotSpec.name);\n    this._slotSpec = slotSpec;\n    slotSpec.providedSlots.forEach(providedSlot => {\n      let slot = this.providedSlots[providedSlot.name];\n      if (slot == undefined) {\n        slot = this.recipe.newSlot(providedSlot.name);\n        slot._sourceConnection = this;\n        slot._name = providedSlot.name;\n        this.providedSlots[providedSlot.name] = slot;\n      }\n      assert(slot.handleConnections.length == 0, 'Handle connections must be empty');\n      providedSlot.views.forEach(handle => slot.handleConnections.push(this.particle.connections[handle]));\n      assert(slot._name == providedSlot.name);\n      assert(!slot.formFactor);\n      slot.formFactor = providedSlot.formFactor;\n    });\n  }\n\n  connectToSlot(targetSlot) {\n    assert(targetSlot);\n    assert(!this.targetSlot);\n    assert(this.recipe == targetSlot.recipe, 'Cannot connect to slot from different recipe');\n\n    this._targetSlot = targetSlot;\n    targetSlot.consumeConnections.push(this);\n  }\n\n  _clone(particle, cloneMap) {\n    if (cloneMap.has(this)) {\n      return cloneMap.get(this);\n    }\n\n    let slotConnection = particle.addSlotConnection(this.name);\n    if (this.slotSpec) {\n      slotConnection._slotSpec = particle.spec.getSlotSpec(this.name);\n    }\n\n    cloneMap.set(this, slotConnection);\n    return slotConnection;\n  }\n\n  _normalize() {\n    let normalizedSlots = {};\n    for (let key of (Object.keys(this._providedSlots).sort())) {\n      normalizedSlots[key] = this._providedSlots[key];\n    }\n    this._providedSlots = normalizedSlots;\n    Object.freeze(this);\n  }\n\n  _compareTo(other) {\n    let cmp;\n    if ((cmp = util.compareStrings(this.name, other.name)) != 0) return cmp;\n    if ((cmp = util.compareComparables(this._targetSlot, other._targetSlot)) != 0) return cmp;\n    if ((cmp = util.compareComparables(this._particle, other._particle)) != 0) return cmp;\n    return 0;\n  }\n\n  _isValid() {\n    if (this._targetSlot && this._targetSlot.sourceConnection &&\n        this._targetSlot != this._targetSlot.sourceConnection.providedSlots[this._targetSlot.name]) {\n      return false;\n    }\n\n    // TODO: add more checks.\n    return true;\n  }\n\n  isResolved(options) {\n    assert(Object.isFrozen(this));\n\n    if (!this.name) {\n      if (options) {\n        options.details = 'missing name';\n      }\n      return false;\n    }\n    if (!this.particle) {\n      if (options) {\n        options.details = 'missing particle';\n      }\n      return false;\n    }\n    if (!this.targetSlot) {\n      if (options) {\n        options.details = 'missing target-slot';\n      }\n      return false;\n    }\n    if (this.slotSpec.isRequired && this.targetSlot.sourceConnection == undefined) {\n      if (options) {\n        options.details = 'missing target-slot\\'s source-connection of required connection';\n      }\n      return false;\n    }\n    return true;\n  }\n\n  toString(nameMap, options) {\n    let consumeRes = [];\n    consumeRes.push('consume');\n    consumeRes.push(`${this.name}`);\n    if (this.targetSlot)\n      consumeRes.push(`as ${(nameMap && nameMap.get(this.targetSlot)) || this.targetSlot.localName}`);\n\n    if (options && options.showUnresolved) {\n      if (!this.isResolved(options)) {\n        consumeRes.push(`// unresolved slot-connection: ${options.details}`);\n      }\n    }\n\n    let result = [];\n    result.push(consumeRes.join(' '));\n\n    Object.keys(this.providedSlots).forEach(psName => {\n      let providedSlot = this.providedSlots[psName];\n      let provideRes = [];\n      provideRes.push('  provide');\n      let providedSlotSpec = this.slotSpec.providedSlots.find(ps => ps.name == psName);\n      assert(providedSlotSpec, `Cannot find providedSlotSpec for ${psName}`);\n      provideRes.push(`${psName} as ${(nameMap && nameMap.get(providedSlot)) || providedSlot}`);\n      result.push(provideRes.join(' '));\n    });\n    return result.join('\\n');\n  }\n}\n\nexport default SlotConnection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/slot-connection.js\n// module id = 70\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport assert from '../../platform/assert-web.js';\nimport util from './util.js';\n\nclass Slot {\n  constructor(recipe, name) {\n    assert(recipe);\n\n    this._recipe = recipe;\n    this._id = undefined; // The ID of the slot in the context\n    this._localName = undefined; // Local id within the recipe\n    this._name = name;\n\n    this._formFactor = undefined;\n    this._handleConnections = []; // HandleConnection* (can only be set if source connection is set and particle in slot connections is set)\n    this._sourceConnection = undefined; // SlotConnection\n    this._consumerConnections = []; // SlotConnection*\n  }\n\n  get recipe() { return this._recipe; }\n  get id() { return this._id; }\n  set id(id) { this._id = id; }\n  get localName() { return this._localName; }\n  set localName(localName) { this._localName = localName; }\n  get name() { return this._name; };\n  set name(name) { this._name = name; };\n  get formFactor() { return this._formFactor; }\n  set formFactor(formFactor) { this._formFactor = formFactor; }\n  get handleConnections() { return this._handleConnections; }\n  get sourceConnection() { return this._sourceConnection; }\n  set sourceConnection(sourceConnection) { this._sourceConnection = sourceConnection; }\n  get consumeConnections() { return this._consumerConnections; }\n\n  _copyInto(recipe, cloneMap) {\n    let slot = undefined;\n    if (!this.sourceConnection && this.id)\n      slot = recipe.findSlot(this.id);\n    if (slot == undefined) {\n      slot = recipe.newSlot(this.name);\n      slot._id = this.id;\n      slot._formFactor = this.formFactor;\n      slot._localName = this._localName;\n      // the connections are re-established when Particles clone their attached SlotConnection objects.\n      slot._sourceConnection = cloneMap.get(this._sourceConnection);\n      if (slot.sourceConnection)\n        slot.sourceConnection._providedSlots[slot.name] = slot;\n      this._handleConnections.forEach(connection => slot._handleConnections.push(cloneMap.get(connection)));\n    }\n    this._consumerConnections.forEach(connection => cloneMap.get(connection).connectToSlot(slot));\n    return slot;\n  }\n\n  _startNormalize() {\n    this.localName = null;\n  }\n\n  _finishNormalize() {\n    assert(Object.isFrozen(this._source));\n    this._consumerConnections.forEach(cc => assert(Object.isFrozen(cc)));\n    this._consumerConnections.sort(util.compareComparables);\n    Object.freeze(this);\n  }\n\n  _compareTo(other) {\n    let cmp;\n    if ((cmp = util.compareStrings(this.id, other.id)) != 0) return cmp;\n    if ((cmp = util.compareStrings(this.localName, other.localName)) != 0) return cmp;\n    if ((cmp = util.compareStrings(this.formFactor, other.formFactor)) != 0) return cmp;\n    return 0;\n  }\n\n  isResolved(options) {\n    assert(Object.isFrozen(this));\n\n    if (options && options.showUnresolved) {\n      options.details = [];\n      if (!this._sourceConnection) {\n        options.details.push('missing source-connection');\n      }\n      if (!this.id) {\n        options.details.push('missing id');\n      }\n      options.details = options.details.join('; ');\n    }\n\n    return this._sourceConnection || this.id;\n  }\n\n  _isValid() {\n    // TODO: implement\n    return true;\n  }\n\n  toString(nameMap, options) {\n    let result = [];\n    if (this.id) {\n      result.push(`slot '${this.id}' as ${(nameMap && nameMap.get(this)) || this.localName}`);\n      if (options && options.showUnresolved) {\n        if (!this.isResolved(options)) {\n          result.push(`// unresolved slot: ${options.details}`);\n        }\n      }\n    }\n    else if (options && options.showUnresolved && !this.isResolved(options)) {\n      result.push(`slot as ${(nameMap && nameMap.get(this)) || this.localName} // unresolved slot: ${options.details}`);\n    }\n    return result.join(' ');\n  }\n}\n\nexport default Slot;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/slot.js\n// module id = 71\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport Type from '../type.js';\nimport assert from '../../platform/assert-web.js';\n\nclass TypeChecker {\n\n  // list: [{type, direction, connection}]\n  static processTypeList(list) {\n    if (list.length == 0) {\n      return {type: {type: undefined}, valid: true};\n    }\n    let baseType = list[0];\n    let variableResolutions = [];\n    for (let i = 1; i < list.length; i++) {\n      let result = TypeChecker.compareTypes(baseType, list[i], variableResolutions);\n      baseType = result.type;\n      if (!result.valid) {\n        return {valid: false};\n      }\n    }\n\n    return {type: baseType, valid: true};\n  }\n\n  static _coerceTypes(left, right) {\n    let leftType = left.type;\n    let rightType = right.type;\n\n    while (leftType.isSetView && rightType.isSetView) {\n      leftType = leftType.primitiveType();\n      rightType = rightType.primitiveType();\n    }\n\n    leftType = leftType.resolvedType();\n    rightType = rightType.resolvedType();\n\n    if (leftType.equals(rightType))\n      return left;\n\n    // TODO: direction?\n    let type;\n    if (leftType.isVariable) {\n      leftType.variable.resolution = rightType;\n      type = right;\n    } else if (rightType.isVariable) {\n      rightType.variable.resolution = leftType;\n      type = left;\n    } else {\n      return null;\n    }\n    return type;\n  }\n\n  static isSubclass(subclass, superclass) {\n    let subtype = subclass.type;\n    let supertype = superclass.type;\n    while (subtype.isSetView && supertype.isSetView) {\n      subtype = subtype.primitiveType();\n      supertype = supertype.primitiveType();\n    }\n\n    if (!(subtype.isEntity && supertype.isEntity))\n      return false;\n\n    return subtype.entitySchema.contains(supertype.entitySchema);\n  }\n\n  // left, right: {type, direction, connection}\n  static compareTypes(left, right) {\n    if (left.type.equals(right.type)) {\n      return {type: left, valid: true};\n    }\n\n    let subclass;\n    let superclass;\n    if (TypeChecker.isSubclass(left, right)) {\n      subclass = left;\n      superclass = right;\n    } else if (TypeChecker.isSubclass(right, left)) {\n      subclass = right;\n      superclass = left;\n    }\n\n    // TODO: this arbitrarily chooses type restriction when\n    // super direction is 'in' and sub direction is 'out'. Eventually\n    // both possibilities should be encoded so we can maximise resolution\n    // opportunities\n    if (superclass) {\n      // treat view types as if they were 'inout' connections. Note that this\n      // guarantees that the view's type will be preserved, and that the fact\n      // that the type comes from a view rather than a connection will also\n      // be preserved.\n      let superDirection = superclass.connection ? superclass.connection.direction : 'inout';\n      let subDirection = subclass.connection ? subclass.connection.direction : 'inout';\n      if (superDirection == 'in') {\n        return {type: subclass, valid: true};\n      }\n      if (subDirection == 'out') {\n        return {type: superclass, valid: true};\n      }\n      return {valid: false};\n    }\n\n    let result = TypeChecker._coerceTypes(left, right);\n    if (result == null) {\n      return {valid: false};\n    }\n    // TODO: direction?\n    return {type: result, valid: true};\n  }\n\n  static substitute(type, variable, value) {\n    if (type.equals(variable))\n      return value;\n    if (type.isSetView)\n      return TypeChecker.substitute(type.primitiveType(), variable, value).setViewOf();\n    return type;\n  }\n}\n\nexport default TypeChecker;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/type-checker.js\n// module id = 72\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {Strategizer} from '../../strategizer/strategizer.js';\nimport Recipe from './recipe.js';\nimport assert from '../../platform/assert-web.js';\n\nclass WalkerBase extends Strategizer.Walker {\n  constructor(tactic) {\n    super();\n    assert(tactic);\n    this.tactic = tactic;\n  }\n\n  _runUpdateList(recipe, updateList) {\n    let newRecipes = [];\n    if (updateList.length) {\n      switch (this.tactic) {\n        case WalkerBase.Permuted:\n          let permutations = [[]];\n          updateList.forEach(({continuation, context}) => {\n            let newResults = [];\n            if (typeof continuation == 'function')\n              continuation = [continuation];\n            continuation.forEach(f => {\n              permutations.forEach(p => {\n                let newP = p.slice();\n                newP.push({f, context});\n                newResults.push(newP);\n              });\n            });\n            permutations = newResults;\n          });\n\n          for (let permutation of permutations) {\n            let cloneMap = new Map();\n            let newRecipe = recipe.clone(cloneMap);\n            let score = 0;\n            permutation = permutation.filter(p => p.f !== null);\n            if (permutation.length == 0)\n              continue;\n            permutation.forEach(({f, context}) => {\n              score += f(newRecipe, cloneMap.get(context));\n            });\n\n            newRecipes.push({recipe: newRecipe, score});\n          }\n          break;\n        case WalkerBase.Independent:\n          updateList.forEach(({continuation, context}) => {\n            if (typeof continuation == 'function')\n              continuation = [continuation];\n            continuation.forEach(f => {\n              if (f == null)\n                f = () => 0;\n              let cloneMap = new Map();\n              let newRecipe = recipe.clone(cloneMap);\n              let score = f(newRecipe, cloneMap.get(context));\n              newRecipes.push({recipe: newRecipe, score});\n            });\n          });\n          break;\n        default:\n          throw `${this.tactic} not supported`;\n      }\n    }\n\n    // commit phase - output results.\n\n    for (let newRecipe of newRecipes) {\n      let result = this.createDescendant(newRecipe.recipe, newRecipe.score);\n    }\n  }\n\n  createDescendant(recipe, score) {\n    let valid = recipe.normalize();\n    //if (!valid) debugger;\n    let hash = valid ? recipe.digest() : null;\n    super.createDescendant(recipe, score, hash, valid);\n  }\n\n  isEmptyResult(result) {\n    if (!result)\n      return true;\n\n    if (result.constructor == Array && result.length <= 0)\n      return true;\n\n      assert(typeof result == 'function' || result.length);\n\n    return false;\n  }\n}\n\nWalkerBase.Permuted = 'permuted';\nWalkerBase.Independent = 'independent';\n\nexport default WalkerBase;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/recipe/walker-base.js\n// module id = 73\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nclass Relevance {\n  constructor() {\n    this.relevanceMap = new Map();\n  }\n\n  apply(relevance) {\n    for (let key of relevance.keys()) {\n      if (this.relevanceMap.has(key))\n        this.relevanceMap.set(key, this.relevanceMap.get(key).concat(relevance.get(key)));\n      else\n        this.relevanceMap.set(key, relevance.get(key));\n    }\n  }\n\n  calcRelevanceScore() {\n    let relevance = 1;\n    let hasNegative = false;\n    for (let rList of this.relevanceMap.values()) {\n      let particleRelevance = Relevance.particleRelevance(rList);\n      if (particleRelevance < 0) {\n        hasNegative = true;\n      }\n      relevance *= Math.abs(particleRelevance);\n    }\n    return relevance * (hasNegative ? -1 : 1);\n  }\n\n  // Returns false, if at least one of the particles relevance lists ends with a negative score.\n  isRelevant(plan) {\n    let hasUi = plan.particles.some(p => Object.keys(p.consumedSlotConnections).length > 0);\n    let rendersUi = false;\n    this.relevanceMap.forEach((rList, particle) => {\n      if (rList[rList.length - 1] < 0) {\n        return false;\n      } else if (Object.keys(particle.consumedSlotConnections).length) {\n        rendersUi = true;\n      }\n    });\n    // If the recipe has UI rendering particles, at least one of the particles must render UI.\n    return hasUi == rendersUi;\n  }\n\n  static scaleRelevance(relevance) {\n    if (relevance == undefined) {\n      relevance = 5;\n    }\n    relevance = Math.max(-1, Math.min(relevance, 10));\n    // TODO: might want to make this geometric or something instead;\n    return relevance / 5;\n  }\n\n  static particleRelevance(relevanceList) {\n    let relevance = 1;\n    let hasNegative = false;\n    relevanceList.forEach(r => {\n      let scaledRelevance = Relevance.scaleRelevance(r);\n      if (scaledRelevance < 0) {\n        hasNegative = true;\n      }\n      relevance *= Math.abs(scaledRelevance);\n    });\n    return relevance * (hasNegative ? -1 : 1);\n  }\n\n  calcParticleRelevance(particle) {\n    if (this.relevanceMap.has(particle)) {\n      return Relevance.particleRelevance(this.relevanceMap.get(particle));\n    }\n    return -1;\n  }\n}\nexport default Relevance;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/relevance.js\n// module id = 74\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\n\nimport assert from '../platform/assert-web.js';\nimport tracing from '../tracelib/trace.js';\nimport Relevance from './relevance.js';\n\nclass Speculator {\n\n  async speculate(arc, plan) {\n    let trace = tracing.start({cat: 'speculator', name: 'Speculator::speculate'});\n    let newArc = await arc.cloneForSpeculativeExecution();\n    let relevance = new Relevance();\n    async function awaitCompletion() {\n      await newArc.scheduler.idle;\n      let messageCount = newArc.pec.messageCount;\n      relevance.apply(await newArc.pec.idle);\n\n      if (newArc.pec.messageCount !== messageCount + 1)\n        return awaitCompletion();\n      else {\n        relevance.newArc = newArc;\n        return relevance;\n      }\n    }\n\n    let result = newArc.instantiate(plan).then(a => awaitCompletion());\n    trace.end();\n    return result;\n  }\n}\n\nexport default Speculator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/speculator.js\n// module id = 75\n// module chunks = 0","// @\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport StorageProviderBase from './storage-provider-base.js';\nimport firebase from '../../platform/firebase-web.js';\nimport assert from '../../platform/assert-web.js';\nimport KeyBase from './key-base.js';\nimport btoa from '../../platform/btoa-web.js';\n\nclass FirebaseKey extends KeyBase {\n  constructor(key) {\n    super();\n    let parts = key.split('://');\n    this.protocol = parts[0];\n    assert(this.protocol == 'firebase');\n    if (parts[1]) {\n      parts = parts[1].split('/');\n      assert(parts[0].endsWith('.firebaseio.com'));\n      this.databaseUrl = parts[0];\n      this.projectId = this.databaseUrl.split('.')[0];\n      this.apiKey = parts[1];\n      this.location = parts.slice(2).join('/');\n    } else {\n      this.databaseUrl = undefined;\n      this.projectId = undefined;\n      this.apiKey = undefined;\n      this.location = '';\n    }\n  }\n\n  childKeyForHandle(id) {\n    let location = '';\n    if (this.location != undefined && this.location.length > 0)\n      location = this.location + '/';\n    location += `handles/${id}`;\n    return new FirebaseKey(`${this.protocol}://${this.databaseUrl}/${this.apiKey}/${location}`);\n  }\n\n  toString() {\n    if (this.databaseUrl && this.apiKey)\n      return `${this.protocol}://${this.databaseUrl}/${this.apiKey}/${this.location}`;\n    return `${this.protocol}://`;\n  }\n}\n\nasync function realTransaction(reference, transactionFunction) {\n  let realData = undefined;\n  await reference.once('value', data => {realData = data.val(); });\n  return reference.transaction(data => {\n    if (data == null)\n      data = realData;\n    return transactionFunction(data);\n  }, undefined, false);\n}\n\nlet _nextAppNameSuffix = 0;\n\nexport default class FirebaseStorage {\n  constructor(arcId) {\n    this._arcId = arcId;\n    this._apps = {};\n  }\n\n  async construct(id, type, keyFragment) {\n    return this._join(id, type, keyFragment, false);\n  }\n\n  async connect(id, type, key) {\n    return this._join(id, type, key, true);\n  }\n\n  parseStringAsKey(string) {\n    return new FirebaseKey(string);\n  }\n\n  async _join(id, type, key, shouldExist) {\n    key = new FirebaseKey(key);\n    // TODO: is it ever going to be possible to autoconstruct new firebase datastores?\n    if (key.databaseUrl == undefined || key.apiKey == undefined)\n      throw new Error('Can\\'t complete partial firebase keys');\n\n    if (this._apps[key.projectId] == undefined) {\n      for (let app of firebase.apps) {\n        if (app.options.databaseURL == key.databaseURL) {\n          this._apps[key.projectId] = app;\n          break;\n        }\n      }\n    }\n\n    if (this._apps[key.projectId] == undefined) {\n      this._apps[key.projectId] = firebase.initializeApp({\n        apiKey: key.apiKey,\n        databaseURL: key.databaseUrl\n      }, `app${_nextAppNameSuffix++}`);\n    }\n\n    let reference = firebase.database(this._apps[key.projectId]).ref(key.location);\n\n    let result = await realTransaction(reference, data => {\n      if ((data == null) == shouldExist)\n        return; // abort transaction\n      if (!shouldExist) {\n        return {version: 0};\n      }\n      return data;\n    });\n\n\n    if (!result.committed)\n      return null;\n\n    return FirebaseStorageProvider.newProvider(type, this._arcId, id, reference, key);\n  }\n}\n\nclass FirebaseStorageProvider extends StorageProviderBase {\n  constructor(type, arcId, id, reference, key) {\n    super(type, arcId, undefined, id, key.toString());\n    this.firebaseKey = key;\n    this.reference = reference;\n  }\n\n  static newProvider(type, arcId, id, reference, key) {\n    if (type.isSetView)\n      return new FirebaseCollection(type, arcId, id, reference, key);\n    return new FirebaseVariable(type, arcId, id, reference, key);\n  }\n\n  static encodeKey(key) {\n    key = btoa(key);\n    return key.replace(/\\//g, '*');\n  }\n  static decodeKey(key) {\n    key = key.replace(/\\*/g, '/');\n    return atob(key);\n  }\n}\n\nclass FirebaseVariable extends FirebaseStorageProvider {\n  constructor(type, arcId, id, reference, firebaseKey) {\n    super(type, arcId, id, reference, firebaseKey);\n    this.dataSnapshot = undefined;\n    this._pendingGets = [];\n    this.reference.on('value', dataSnapshot => {\n      this.dataSnapshot = dataSnapshot;\n      let data = dataSnapshot.val();\n      this._pendingGets.forEach(_get => _get(data));\n      this._pendingGets = [];\n      this._fire('change', {data: data.data, version: data.version});\n    });\n  }\n\n  async cloneFrom(store) {\n    let {data, version} = await store._getWithVersion();\n    await realTransaction(this.reference, data => ({data, version}));\n  }\n\n  async get() {\n    return this.dataSnapshot.val().data;\n  }\n\n  async _getWithVersion() {\n    if (this.dataSnapshot == undefined) {\n      return new Promise((resolve, reject) => {\n        this._pendingGets.push(resolve);\n      });\n    }\n    return this.dataSnapshot.val();\n  }\n\n  async set(value) {\n    return realTransaction(this.reference, data => ({data: value, version: data.version + 1}));\n  }\n\n  async clear() {\n    return this.set(null);\n  }\n}\n\nclass FirebaseCollection extends FirebaseStorageProvider {\n  constructor(type, arcId, id, reference, firebaseKey) {\n    super(type, arcId, id, reference, firebaseKey);\n    this.dataSnapshot = undefined;\n    this._pendingGets = [];\n    this.reference.on('value', dataSnapshot => {\n      this.dataSnapshot = dataSnapshot;\n      let data = dataSnapshot.val();\n      this._pendingGets.forEach(_get => _get(data));\n      this._pendingGets = [];\n      this._fire('change', {data: this._setToList(data.data), version: data.version});\n    });\n  }\n\n  async get(id) {\n    let set = this.dataSnapshot.val().data;\n    let encId = FirebaseStorageProvider.encodeKey(id);\n    if (set)\n      return set[encId];\n    return undefined;\n  }\n\n  async remove(id) {\n    return realTransaction(this.reference, data => {\n      if (!data.data)\n        data.data = {};\n      let encId = FirebaseStorageProvider.encodeKey(id);\n      data.data[encId] = null;\n      data.version += 1;\n      return data;\n    });\n  }\n\n  async store(entity) {\n    return realTransaction(this.reference, data => {\n      if (!data.data)\n        data.data = {};\n      let encId = FirebaseStorageProvider.encodeKey(entity.id);\n      data.data[encId] = entity;\n      data.version += 1;\n      return data;\n    });\n  }\n\n  async cloneFrom(store) {\n    let {list, version} = await store._toListWithVersion();\n    return realTransaction(this.reference, data => {\n      if (!data.data)\n        data.data = {};\n      list.forEach(item => {\n        let encId = FirebaseStorageProvider.encodeKey(item.id);\n        data.data[encId] = item;\n      });\n      data.version = version;\n      return data;\n    });\n  }\n\n  async toList() {\n    if (this.dataSnapshot == undefined) {\n      return new Promise((resolve, reject) => {\n        this._pendingGets.push(resolve);\n      }).then(data => this._setToList(data.data));\n    }\n    return this._setToList(this.dataSnapshot.val().data);\n  }\n\n  async _toListWithVersion() {\n    if (this.dataSnapshot == undefined) {\n      return new Promise((resolve, reject) => {\n        this._pendingGets.push(resolve);\n      }).then(data => ({list: this._setToList(data.data), version: data.version}));\n    }\n    let data = this.dataSnapshot.val();\n    return {list: this._setToList(data.data), version: data.version};\n  }\n\n  _setToList(set) {\n    let list = [];\n    if (set) {\n      for (let key in set) {\n        list.push(set[key]);\n      }\n    }\n    return list;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/storage/firebase-storage.js\n// module id = 76\n// module chunks = 0","// @\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n'use strict';\n\nimport assert from '../../platform/assert-web.js';\nimport tracing from '../../tracelib/trace.js';\nimport util from '../recipe/util.js';\nimport StorageProviderBase from './storage-provider-base.js';\nimport KeyBase from './key-base.js';\n\nclass InMemoryKey extends KeyBase {\n  constructor(key) {\n    super();\n    let parts = key.split('://');\n    this.protocol = parts[0];\n    assert(this.protocol == 'in-memory');\n    parts = parts[1] ? parts.slice(1).join('://').split('^^') : [];\n    this.arcId = parts[0];\n    this.location = parts[1];\n    assert(this.toString() == key);\n  }\n\n  childKeyForHandle(id) {\n    return new InMemoryKey('in-memory://');\n  }\n\n  toString() {\n    if (this.location !== undefined && this.arcId !== undefined)\n      return `${this.protocol}://${this.arcId}^^${this.location}`;\n    if (this.arcId !== undefined)\n      return `${this.protocol}://${this.arcId}`;\n    return `${this.protocol}`;\n  }\n}\n\nlet __storageCache = {};\n\nexport default class InMemoryStorage {\n  constructor(arcId) {\n      assert(arcId !== undefined, 'Arcs with storage must have ids');\n      this._arcId = arcId;\n      this._memoryMap = {};\n      this.localIDBase = 0;\n      // TODO(shans): re-add this assert once we have a runtime object to put it on.\n      // assert(__storageCache[this._arc.id] == undefined, `${this._arc.id} already exists in local storage cache`);\n      __storageCache[this._arcId] = this;\n  }\n\n  async construct(id, type, keyFragment) {\n    let key = new InMemoryKey(keyFragment);\n    if (key.arcId == undefined)\n      key.arcId = this._arcId;\n    if (key.location == undefined)\n      key.location = 'in-memory-' + this.localIDBase++;\n    let provider = InMemoryStorageProvider.newProvider(type, this._arcId, undefined, id, key.toString());\n    if (this._memoryMap[key.toString()] !== undefined)\n      return null;\n    this._memoryMap[key.toString()] = provider;\n    return provider;\n  }\n\n  async connect(id, type, keyString) {\n    let key = new InMemoryKey(keyString);\n    if (key.arcId !== this._arcId) {\n      if (__storageCache[key.arcId] == undefined)\n        return null;\n      return __storageCache[key.arcId].connect(id, type, keyString);\n    }\n    if (this._memoryMap[keyString] == undefined)\n      return null;\n    // TODO assert types match?\n    return this._memoryMap[keyString];\n  }\n\n  parseStringAsKey(string) {\n    return new InMemoryKey(string);\n  }\n}\n\nclass InMemoryStorageProvider extends StorageProviderBase {\n  static newProvider(type, arcId, name, id, key) {\n    if (type.isSetView)\n      return new InMemoryCollection(type, arcId, name, id, key);\n    return new InMemoryVariable(type, arcId, name, id, key);\n  }\n}\n\nclass InMemoryCollection extends InMemoryStorageProvider {\n  constructor(type, arcId, name, id, key) {\n    super(type, arcId, name, id, key);\n    this._items = new Map();\n  }\n\n  clone() {\n    let view = new InMemoryCollection(this._type, this._arcId, this.name, this.id);\n    view.cloneFrom(this);\n    return view;\n  }\n\n  async cloneFrom(handle) {\n    let {list, version} = await handle._toListWithVersion();\n    this._version = version;\n    list.forEach(item => this._items.set(item.id, item));\n  }\n\n  async get(id) {\n    return this._items.get(id);\n  }\n  traceInfo() {\n    return {items: this._items.size};\n  }\n  // HACK: replace this with some kind of iterator thing?\n  async toList() {\n    return [...this._items.values()];\n  }\n\n  async _toListWithVersion() {\n    return {list: [...this._items.values()], version: this._version};\n  }\n\n  async store(entity) {\n    let trace = tracing.start({cat: 'view', name: 'InMemoryCollection::store', args: {name: this.name}});\n    let entityWasPresent = this._items.has(entity.id);\n\n    this._items.set(entity.id, entity);\n    this._version++;\n    if (!entityWasPresent)\n      this._fire('change', {add: [entity], version: this._version});\n    trace.end({args: {entity}});\n  }\n\n  async remove(id) {\n    let trace = tracing.start({cat: 'view', name: 'InMemoryCollection::remove', args: {name: this.name}});\n    if (!this._items.has(id)) {\n      return;\n    }\n    let entity = this._items.get(id);\n    assert(this._items.delete(id));\n    this._version++;\n    this._fire('change', {remove: [entity], version: this._version});\n    trace.end({args: {entity}});\n  }\n\n  // TODO: Something about iterators??\n  // TODO: Something about changing order?\n\n  extractEntities(set) {\n    this._items.forEach(a => set.add(a));\n  }\n\n  serialize(list) {\n    list.push({\n      id: this.id,\n      sort: 'view',\n      type: this.type.toLiteral(),\n      name: this.name,\n      values: this.toList().map(a => a.id),\n      version: this._version\n    });\n  }\n\n  serializeMappingRecord(list) {\n    list.push({\n      id: this.id,\n      sort: 'view',\n      type: this.type.toLiteral(),\n      name: this.name,\n      version: this._version,\n      arc: this._arcId\n    });\n  }\n}\n\nclass InMemoryVariable extends InMemoryStorageProvider {\n  constructor(type, arcId, name, id, key) {\n    super(type, arcId, name, id, key);\n    this._stored = null;\n  }\n\n  clone() {\n    let variable = new InMemoryVariable(this._type, this._arcId, this.name, this.id);\n    variable.cloneFrom(this);\n    return variable;\n  }\n\n  async cloneFrom(handle) {\n    let {data, version} = await handle._getWithVersion();\n    this._stored = data;\n    this._version = version;\n  }\n\n  traceInfo() {\n    return {stored: this._stored !== null};\n  }\n\n  async get() {\n    return this._stored;\n  }\n\n  async _getWithVersion() {\n    return {data: this._stored, version: this._version};\n  }\n\n  async set(entity) {\n    this._stored = entity;\n    this._version++;\n    this._fire('change', {data: this._stored, version: this._version});\n  }\n\n  async clear() {\n    this.set(undefined);\n  }\n\n  extractEntities(set) {\n    if (!this._stored) {\n      return;\n    }\n    set.add(this._stored);\n  }\n\n  serialize(list) {\n    if (this._stored == undefined)\n      return;\n    list.push({\n      id: this.id,\n      sort: 'variable',\n      type: this.type.toLiteral(),\n      name: this.name,\n      value: this._stored.id,\n      version: this._version\n    });\n  }\n\n  serializeMappingRecord(list) {\n    list.push({\n      id: this.id,\n      sort: 'variable',\n      type: this.type.toLiteral(),\n      name: this.name,\n      version: this._version,\n      arc: this._arcId\n    });\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/storage/in-memory-storage.js\n// module id = 77\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeWalker from '../recipe/walker.js';\n\nexport default class AddUseViews extends Strategy {\n  // TODO: move generation to use an async generator.\n  async generate(strategizer) {\n    let results = Recipe.over(this.getResults(strategizer), new class extends RecipeWalker {\n      onRecipe(recipe) {\n        // Don't add use views while there are outstanding constraints\n        if (recipe.connectionConstraints.length > 0)\n          return;\n        // Don't add use views to a recipe with free views\n        let freeViews = recipe.views.filter(view => view.connections.length == 0);\n        if (freeViews.length > 0)\n          return;\n\n        // TODO: \"description\" handles are always created, and in the future they need to be \"optional\" (blocked by optional handles\n        // not being properly supported in arc instantiation). For now just hardcode skiping them.\n        let disconnectedConnections = recipe.handleConnections.filter(hc => hc.view == null && !hc.isOptional && hc.name != 'descriptions');\n\n        return recipe => {\n          disconnectedConnections.forEach(hc => {\n            let clonedHC = recipe.updateToClone({hc}).hc;\n            let view = recipe.newView();\n            view.fate = 'use';\n            clonedHC.connectToView(view);\n          });\n          return 0;\n        };\n      }\n    }(RecipeWalker.Permuted), this);\n\n    return {results, generate: null};\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/add-use-views.js\n// module id = 78\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport RecipeWalker from '../recipe/walker.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeUtil from '../recipe/recipe-util.js';\nimport ViewMapperBase from './view-mapper-base.js';\nimport Schema from '../schema.js';\n\nimport assert from '../../platform/assert-web.js';\n\nexport default class AssignRemoteViews extends ViewMapperBase {\n  constructor(arc) {\n    super();\n    this._arc = arc;\n    this.fate = 'map';\n  }\n\n  getMappableViews(type, tags=[]) {\n    return this._arc.context.findHandlesByType(type, {tags, subtype: true});\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/assign-remote-views.js\n// module id = 79\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport RecipeWalker from '../recipe/walker.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeUtil from '../recipe/recipe-util.js';\nimport ViewMapperBase from './view-mapper-base.js';\n\nimport assert from '../../platform/assert-web.js';\n\nexport default class AssignViewsByTagAndType extends ViewMapperBase {\n  constructor(arc) {\n    super();\n    this.arc = arc;\n    this.fate = 'use';\n  }\n\n  getMappableViews(type, tags, counts) {\n    // We can use a handle that has a subtype only when all of the connections\n    // are inputs.\n    let subtype = counts.out == 0;\n    if (tags.length > 0) {\n      return this.arc.findHandlesByType(type, {tags, subtype});\n    } else {\n      return this.arc.findHandlesByType(type);\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/assign-views-by-tag-and-type.js\n// module id = 80\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport assert from '../../platform/assert-web.js';\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeWalker from '../recipe/walker.js';\n\nexport default class CombinedStrategy extends Strategy {\n  constructor(strategies) {\n    super();\n    assert(strategies.length > 1, 'Strategies must contain at least 2 elements.');\n    this._strategies = strategies;\n    this._strategies.forEach(strategy => assert(strategy.walker));\n    assert(this._strategies[0].getResults);\n  }\n  _getLeaves(results) {\n    // Only use leaf recipes.\n    let recipeByParent = new Map();\n    let resultsList = [...results.values()];\n    resultsList.forEach(r => {\n      r.derivation.forEach(d => {\n        if (d.parent) {\n          recipeByParent.set(d.parent, r);\n        }\n      });\n    });\n    return resultsList.filter(r => !recipeByParent.has(r));\n  }\n  async generate(strategizer) {\n    let results = this._strategies[0].getResults(strategizer);\n    let totalResults = new Map();\n    for (let strategy of this._strategies) {\n      results = Recipe.over(results, strategy.walker, strategy);\n      results = await Promise.all(results.map(async result => {\n        if (result.hash) {\n          result.hash = await result.hash;\n        }\n        if (!totalResults.has(result.hash)) {\n          // TODO: deduping of results is already done in strategizer.\n          // It should dedup the intermeditate derivations as well.\n          totalResults.set(result.hash, result);\n        }\n        return result;\n      }));\n      results = this._getLeaves(totalResults);\n    }\n\n    return {results, generate: null};\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/combined-strategy.js\n// module id = 81\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeWalker from '../recipe/walker.js';\nimport RecipeUtil from '../recipe/recipe-util.js';\n\nexport default class ConvertConstraintsToConnections extends Strategy {\n  constructor(arc) {\n    super();\n    this.affordance = arc.pec.slotComposer ? arc.pec.slotComposer.affordance : null;\n  }\n  async generate(strategizer) {\n    let affordance = this.affordance;\n    let results = Recipe.over(this.getResults(strategizer), new class extends RecipeWalker {\n      onRecipe(recipe) {\n        let particles = new Set();\n        let views = new Set();\n        let map = {};\n        let particlesByName = {};\n        let viewCount = 0;\n        for (let constraint of recipe.connectionConstraints) {\n          if (affordance && (!constraint.fromParticle.matchAffordance(affordance) || !constraint.toParticle.matchAffordance(affordance))) {\n            return;\n          }\n          particles.add(constraint.fromParticle.name);\n          if (map[constraint.fromParticle.name] == undefined) {\n            map[constraint.fromParticle.name] = {};\n            particlesByName[constraint.fromParticle.name] = constraint.fromParticle;\n          }\n          particles.add(constraint.toParticle.name);\n          if (map[constraint.toParticle.name] == undefined) {\n            map[constraint.toParticle.name] = {};\n            particlesByName[constraint.toParticle.name] = constraint.toParticle;\n          }\n          let view = map[constraint.fromParticle.name][constraint.fromConnection];\n          if (view == undefined) {\n            view = 'v' + viewCount++;\n            map[constraint.fromParticle.name][constraint.fromConnection] = view;\n            views.add(view);\n          }\n          map[constraint.toParticle.name][constraint.toConnection] = view;\n        }\n        let shape = RecipeUtil.makeShape([...particles.values()], [...views.values()], map);\n        let results = RecipeUtil.find(recipe, shape);\n\n        return results.map(match => {\n          return (recipe) => {\n            let score = recipe.connectionConstraints.length + match.score;\n            let recipeMap = recipe.updateToClone(match.match);\n            for (let particle in map) {\n              for (let connection in map[particle]) {\n                let view = map[particle][connection];\n                let recipeParticle = recipeMap[particle];\n                if (recipeParticle == null) {\n                  recipeParticle = recipe.newParticle(particle);\n                  recipeParticle.spec = particlesByName[particle];\n                  recipeMap[particle] = recipeParticle;\n                }\n                let recipeHandleConnection = recipeParticle.connections[connection];\n                if (recipeHandleConnection == undefined)\n                  recipeHandleConnection = recipeParticle.addConnectionName(connection);\n                let recipeView = recipeMap[view];\n                if (recipeView == null) {\n                  recipeView = recipe.newView();\n                  recipeView.fate = 'create';\n                  recipeMap[view] = recipeView;\n                }\n                if (recipeHandleConnection.view == null)\n                  recipeHandleConnection.connectToView(recipeView);\n              }\n            }\n            recipe.clearConnectionConstraints();\n            return score;\n          };\n        });\n      }\n    }(RecipeWalker.Independent), this);\n\n    return {results, generate: null};\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/convert-constraints-to-connections.js\n// module id = 82\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport RecipeWalker from '../recipe/walker.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeUtil from '../recipe/recipe-util.js';\nimport ViewMapperBase from './view-mapper-base.js';\nimport Schema from '../schema.js';\n\nimport assert from '../../platform/assert-web.js';\n\nexport default class CopyRemoteViews extends ViewMapperBase {\n  constructor(arc) {\n    super();\n    this._arc = arc;\n    this.fate = 'copy';\n  }\n\n  getMappableViews(type, tags=[]) {\n    return this._arc.context.findHandlesByType(type, {tags, subtype: true});\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/copy-remote-views.js\n// module id = 83\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport assert from '../../platform/assert-web.js';\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeWalker from '../recipe/walker.js';\n\nexport default class CreateDescriptionHandle extends Strategy {\n  async generate(strategizer) {\n    let results = Recipe.over(this.getResults(strategizer), new class extends RecipeWalker {\n      onHandleConnection(recipe, handleConnection) {\n        if (handleConnection.view)\n          return;\n        if (handleConnection.name != 'descriptions')\n          return;\n\n        return (recipe, handleConnection) => {\n          let view = recipe.newView();\n          view.fate = 'create';\n          handleConnection.connectToView(view);\n          return 1;\n        };\n      }\n    }(RecipeWalker.Permuted), this);\n\n    return {results, generate: null};\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/create-description-handle.js\n// module id = 84\n// module chunks = 0","\n// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport assert from '../../platform/assert-web.js';\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeWalker from '../recipe/walker.js';\n\nexport default class FallbackFate extends Strategy {\n  async generate(strategizer) {\n    assert(strategizer);\n    let generated = strategizer.generated.filter(result => !result.result.isResolved());\n    let terminal = strategizer.terminal;\n    let results = Recipe.over([...generated, ...terminal], new class extends RecipeWalker {\n      onView(recipe, view) {\n        // Only apply this strategy only to user query based recipes with resolved tokens.\n        if (!recipe.search || (recipe.search.resolvedTokens.length == 0)) {\n          return;\n        }\n\n        // Only apply to views whose fate is set, but wasn't explicitly defined in the recipe.\n        if (view.isResolved() || view.fate == '?' || view.originalFate != '?') {\n          return;\n        }\n\n        let hasOutConns = view.connections.some(hc => hc.isOutput);\n        let newFate = hasOutConns ? 'copy' : 'map';\n        if (view.fate == newFate) {\n          return;\n        }\n\n        return (recipe, clonedView) => {\n          clonedView.fate = newFate;\n          return 0;\n        };\n      }\n    }(RecipeWalker.Permuted), this);\n\n    return {results, generate: null};\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/fallback-fate.js\n// module id = 85\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport assert from '../../platform/assert-web.js';\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeWalker from '../recipe/walker.js';\n\nexport default class GroupHandleConnections extends Strategy {\n  constructor() {\n    super();\n\n    this._walker = new class extends RecipeWalker {\n      onRecipe(recipe) {\n        // Only apply this strategy if ALL handle connections are named and have types.\n        if (recipe.handleConnections.find(hc => !hc.type || !hc.name || hc.isOptional)) {\n          return;\n        }\n        // Find all unique types used in the recipe that have unbound handle connections.\n        let types = new Set();\n        recipe.handleConnections.forEach(hc => {\n          if (!hc.isOptional && !hc.view && !Array.from(types).find(t => t.equals(hc.type))) {\n            types.add(hc.type);\n          }\n        });\n\n        let groupsByType = new Map();\n        types.forEach(type => {\n          // Find the particle with the largest number of unbound connections of the same type.\n          let countConnectionsByType = (connections) => Object.values(connections).filter(conn => {\n            return !conn.isOptional && !conn.view && type.equals(conn.type);\n          }).length;\n          let sortedParticles = [...recipe.particles].sort((p1, p2) => {\n            return countConnectionsByType(p2.connections) - countConnectionsByType(p1.connections);\n          }).filter(p => countConnectionsByType(p.connections) > 0);\n          assert(sortedParticles.length > 0);\n\n          // View connections of the same particle cannot be bound to the same view. Iterate on view connections of the particle\n          // with the most connections of the given type, and group each of them with same typed view connections of other particles.\n          let particleWithMostConnectionsOfType = sortedParticles[0];\n          let groups = new Map();\n          groupsByType.set(type, groups);\n          let allTypeHandleConnections = recipe.handleConnections.filter(c => {\n            return !c.isOptional && !c.view && type.equals(c.type) && (c.particle != particleWithMostConnectionsOfType);\n          });\n\n          let iteration = 0;\n          while (allTypeHandleConnections.length > 0) {\n            Object.values(particleWithMostConnectionsOfType.connections).forEach(handleConnection => {\n              if (!type.equals(handleConnection.type)) {\n                return;\n              }\n              if (!groups.has(handleConnection)) {\n                groups.set(handleConnection, []);\n              }\n              let group = groups.get(handleConnection);\n\n              // filter all connections where this particle is already in a group.\n              let possibleConnections = allTypeHandleConnections.filter(c => !group.find(gc => gc.particle == c.particle));\n              let selectedConn = possibleConnections.find(c => handleConnection.isInput != c.isInput || handleConnection.isOutput != c.isOutput);\n              // TODO: consider tags.\n              // TODO: Slots view restrictions should also be accounted for when grouping.\n              if (!selectedConn) {\n                if (possibleConnections.length == 0 || iteration == 0) {\n                  // During first iteration only bind opposite direction connections (\"in\" with \"out\" and vice versa)\n                  // to ensure each group has both direction connections as much as possible.\n                  return;\n                }\n                selectedConn = possibleConnections[0];\n              }\n              group.push(selectedConn);\n              allTypeHandleConnections = allTypeHandleConnections.filter(c => c != selectedConn);\n            });\n            iteration++;\n          }\n          // Remove groups where no connections were bound together.\n          groups.forEach((otherConns, conn) => {\n            if (otherConns.length == 0) {\n              groups.delete(conn);\n            } else {\n              otherConns.push(conn);\n            }\n          });\n        });\n\n        return recipe => {\n          groupsByType.forEach((groups, type) => {\n            groups.forEach(group => {\n              let recipeView = recipe.newView();\n              group.forEach(conn => {\n                let cloneConn = recipe.updateToClone({conn}).conn;\n                cloneConn.connectToView(recipeView);\n              });\n            });\n          });\n          // TODO: score!\n        };\n      }\n    }(RecipeWalker.Permuted);\n  }\n  get walker() {\n    return this._walker;\n  }\n  async generate(strategizer) {\n    return {\n      results: Recipe.over(this.getResults(strategizer), this.walker, this),\n      generate: null,\n    };\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/group-handle-connections.js\n// module id = 86\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {Strategy} from '../../strategizer/strategizer.js';\n\nexport default class InitPopulation extends Strategy {\n  constructor(arc) {\n    super();\n    this._recipes = [];\n    for (let recipe of (arc.context.recipes || [])) {\n      // Filter out recipes containing particles that don't support the current affordance.\n      if (arc.pec.slotComposer) {\n        if (recipe.particles.find(p => p.spec && !p.spec.matchAffordance(arc.pec.slotComposer.affordance)) !== undefined) {\n          continue;\n        }\n      }\n      recipe = recipe.clone();\n      if (!recipe.normalize()) {\n        console.warn('could not normalize a context recipe');\n      } else {\n        this._recipes.push(recipe);\n      }\n    }\n    this._loadedParticles = new Set(arc.loadedParticles().map(spec => spec.implFile));\n  }\n  async generate(strategizer) {\n    if (strategizer.generation != 0) {\n      return {results: [], generate: null};\n    }\n    let results = this._recipes.map(recipe => ({\n      result: recipe,\n      score: 1 - recipe.particles.filter(particle => particle.spec && this._loadedParticles.has(particle.spec.implFile)).length,\n      derivation: [{strategy: this, parent: undefined}],\n      hash: recipe.digest(),\n      valid: Object.isFrozen(recipe),\n    }));\n\n    return {\n      results: results,\n      generate: null,\n    };\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/init-population.js\n// module id = 87\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport Recipe from '../recipe/recipe.js';\nimport assert from '../../platform/assert-web.js';\n\nexport default class InitSearch extends Strategy {\n  constructor(arc) {\n    super();\n    // TODO: Figure out where this should really come from.\n    this._search = arc.search;\n  }\n  async generate(strategizer) {\n    if (this._search == null || strategizer.generation != 0) {\n      return {\n        results: [],\n        generate: null,\n      };\n    }\n\n    let recipe = new Recipe();\n    recipe.setSearchPhrase(this._search);\n    assert(recipe.normalize());\n    assert(!recipe.isResolved());\n\n    return {\n      results: [{\n        result: recipe,\n        score: 0,\n        derivation: [{strategy: this, parent: undefined}],\n        hash: recipe.digest(),\n      }],\n      generate: null,\n    };\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/init-search.js\n// module id = 88\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeWalker from '../recipe/walker.js';\nimport RecipeUtil from '../recipe/recipe-util.js';\n\nexport default class MapConsumedSlots extends Strategy {\n  async generate(strategizer) {\n    let results = Recipe.over(this.getResults(strategizer), new class extends RecipeWalker {\n      onSlotConnection(recipe, slotConnection) {\n        if (slotConnection.targetSlot)\n          return;\n        let potentialSlots = recipe.slots.filter(slot => {\n          if (slotConnection.name != slot.name)\n            return false;\n\n          if (!slot.sourceConnection) {\n            return;\n          }\n\n          let providedSlotSpec =\n              slot.sourceConnection.slotSpec.providedSlots.find(ps => ps.name == slotConnection.name);\n          if (slotConnection.slotSpec.isSet != providedSlotSpec.isSet)\n            return;\n\n          // Verify view connections match.\n          let views = slot.handleConnections.map(connection => connection.view);\n          if (views.length == 0) {\n            return true;\n          }\n          let particle = slotConnection.particle;\n          for (let name in particle.connections) {\n            let connection = particle.connections[name];\n            if (views.includes(connection.view))\n              return true;\n          }\n          return false;\n        });\n        return potentialSlots.map(slot => {\n          return (recipe, slotConnection) => {\n            let clonedSlot = recipe.updateToClone({slot});\n            slotConnection.connectToSlot(clonedSlot.slot);\n            return 1;\n          };\n        });\n      }\n    }(RecipeWalker.Permuted), this);\n\n    return {results, generate: null};\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/map-consumed-slots.js\n// module id = 89\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeWalker from '../recipe/walker.js';\nimport RecipeUtil from '../recipe/recipe-util.js';\n\nexport default class MapRemoteSlots extends Strategy {\n  constructor(arc) {\n    super();\n    this.remoteSlots = arc.pec.slotComposer ? arc.pec.slotComposer.getAvailableSlots() : {};\n  }\n  async generate(strategizer) {\n    let remoteSlots = this.remoteSlots;\n    let results = Recipe.over(this.getResults(strategizer), new class extends RecipeWalker {\n      onSlotConnection(recipe, slotConnection) {\n        if (slotConnection.targetSlot && slotConnection.targetSlot.id)\n          return;\n        if (remoteSlots[slotConnection.name] == undefined)\n          return;\n\n        let matchingSlots = remoteSlots[slotConnection.name].filter(remoteSlot => {\n          if (slotConnection.slotSpec.isSet != remoteSlot.providedSlotSpec.isSet) {\n            return false;\n          }\n\n          let views = remoteSlot.views;\n          let viewsMatch = false;\n          if (views.length == 0) {\n            return true;\n          } else {\n            let particle = slotConnection.particle;\n            for (let name in particle.connections) {\n              let connection = particle.connections[name];\n              if (!connection.view)\n                continue;\n              if (views.find(v => v.id == connection.view.id)) {\n                return true;\n              }\n            }\n          }\n          return false;\n        });\n        if (matchingSlots.length == 0) {\n          return;\n        }\n        matchingSlots.sort((s1, s2) => {\n          let score1 = 1 - s1.count;\n          let score2 = 1 - s2.count;\n          return score2 - score1;\n        });\n        let remoteSlotId = matchingSlots[0].id;\n        let score = 1 - matchingSlots[0].count;\n\n        return (recipe, slotConnection) => {\n          if (!slotConnection.targetSlot) {\n            let slot = recipe.slots.find(slot => {\n              return (slot.id == remoteSlotId) || (!slot.id && (slot.name == slotConnection.name));\n            });\n            if (!slot) {\n              slot = recipe.newSlot(slotConnection.name);\n            }\n            slotConnection.connectToSlot(slot);\n          }\n          slotConnection.targetSlot.id = remoteSlotId;\n          return score;\n        };\n      }\n    }(RecipeWalker.Permuted), this);\n\n    return {results, generate: null};\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/map-remote-slots.js\n// module id = 90\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeWalker from '../recipe/walker.js';\n\nexport default class MatchParticleByVerb extends Strategy {\n  constructor(arc) {\n    super();\n    this._arc = arc;\n  }\n\n  async generate(strategizer) {\n    let arc = this._arc;\n    let results = Recipe.over(this.getResults(strategizer), new class extends RecipeWalker {\n      onParticle(recipe, particle) {\n        if (particle.name) {\n          // Particle already has explicit name.\n          return;\n        }\n\n        let particleSpecs = arc.context.findParticlesByVerb(particle.primaryVerb)\n            .filter(spec => !arc.pec.slotComposer || spec.matchAffordance(arc.pec.slotComposer.affordance));\n\n        return particleSpecs.map(spec => {\n          return (recipe, particle) => {\n            let score = 1;\n\n            particle.name = spec.name;\n            particle.spec = spec;\n\n            return score;\n          };\n        });\n      }\n    }(RecipeWalker.Permuted), this);\n\n    return {results, generate: null};\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/match-particle-by-verb.js\n// module id = 91\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeWalker from '../recipe/walker.js';\n\nexport default class NameUnnamedConnections extends Strategy {\n  async generate(strategizer) {\n    let results = Recipe.over(this.getResults(strategizer), new class extends RecipeWalker {\n      onHandleConnection(recipe, handleConnection) {\n        if (handleConnection.name)\n          return; // it is already named.\n\n        if (!handleConnection.particle.spec)\n          return; // the particle doesn't have spec yet.\n\n        let possibleSpecConns = handleConnection.particle.spec.connections.filter(specConn => {\n          // filter specs with matching types that don't have views bound to the corresponding view connection.\n          return !specConn.isOptional &&\n                 handleConnection.view.type.equals(specConn.type) &&\n                 !handleConnection.particle.getConnectionByName(specConn.name).view;\n        });\n\n        return possibleSpecConns.map(specConn => {\n          return (recipe, handleConnection) => {\n            handleConnection.particle.nameConnection(handleConnection, specConn.name);\n            return 1;\n          };\n        });\n      }\n    }(RecipeWalker.Permuted), this);\n\n    return {results, generate: null};\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/name-unnamed-connections.js\n// module id = 92\n// module chunks = 0","// Copyright (c) 2017 Google Inc. All rights reserved.\n// This code may only be used under the BSD style license found at\n// http://polymer.github.io/LICENSE.txt\n// Code distributed by Google as part of this project is also\n// subject to an additional IP rights grant found at\n// http://polymer.github.io/PATENTS.txt\n\nimport assert from '../../platform/assert-web.js';\nimport {Strategy} from '../../strategizer/strategizer.js';\nimport Recipe from '../recipe/recipe.js';\nimport RecipeWalker from '../recipe/walker.js';\n\nexport default class SearchTokensToParticles extends Strategy {\n  constructor(arc) {\n    super();\n    // TODO: Recipes. Views?\n    this._byToken = {};\n    for (let particle of arc.context.particles) {\n      let name = particle.name.toLowerCase();\n      this._addParticle(name, particle);\n\n      let verb = particle.primaryVerb;\n      if (verb != name) {\n        this._addParticle(verb, particle);\n      }\n    }\n\n    let findParticles = token => this._byToken[token] || [];\n    class Walker extends RecipeWalker {\n      onRecipe(recipe) {\n        if (!recipe.search || !recipe.search.unresolvedTokens.length) {\n          return;\n        }\n\n        let specsByToken = {};\n        for (let token of recipe.search.unresolvedTokens) {\n          for (let spec of findParticles(token)) {\n            // TODO: Skip particles that are already in the active recipe?\n            specsByToken[token] = specsByToken[token] || [];\n            specsByToken[token].push(spec);\n          }\n        }\n        let resolvedTokens = Object.keys(specsByToken);\n        if (resolvedTokens.length == 0) {\n          return;\n        }\n\n        const flatten = (arr) => [].concat(...arr);\n        const product = (...sets) =>\n          sets.reduce((acc, set) =>\n            flatten(acc.map(x => set.map(y => [...x, y]))),\n            [[]]);\n        let possibleCombinations = product(...Object.values(specsByToken).map(v => flatten(v)));\n\n        return possibleCombinations.map(combination => {\n          return recipe => {\n            resolvedTokens.forEach(token => recipe.search.resolveToken(token));\n            combination.forEach(spec => {\n              let particle = recipe.newParticle(spec.name);\n              particle.spec = spec;\n            });\n            return resolvedTokens.size;\n          };\n        });\n      }\n    };\n    this._walker = new Walker(RecipeWalker.Permuted);\n  }\n\n  get walker() {\n    return this._walker;\n  }\n\n  getResults(strategizer) {\n    assert(strategizer);\n    let generated = super.getResults(strategizer).filter(result => !result.result.isResolved());\n    let terminal = strategizer.terminal;\n    return [...generated, ...terminal];\n  }\n\n  _addParticle(token, particle) {\n    this._byToken[token] = this._byToken[token] || [];\n    this._byToken[token].push(particle);\n  }\n  async generate(strategizer) {\n    return {\n      results: Recipe.over(this.getResults(strategizer), this.walker, this),\n      generate: null,\n    };\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/strategies/search-tokens-to-particles.js\n// module id = 93\n// module chunks = 0","/**\n * @license\n * Copyright (c) 2017 Google Inc. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * Code distributed by Google as part of this project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport assert from '../platform/assert-web.js';\n\nexport default class TupleFields {\n  constructor(fieldList) {\n    this.fieldList = fieldList;\n  }\n\n  static fromLiteral(literal) {\n    return new TupleFields(literal.map(a => Type.fromLiteral(a)));\n  }\n\n  toLiteral() {\n    return this.fieldList.map(a => a.toLiteral());\n  }\n\n  clone() {\n    return new TupleFields(this.fieldList.map(a => a.clone()));\n  }\n\n  equals(other) {\n    if (this.fieldList.length !== other.fieldList.length)\n      return false;\n    for (let i = 0; i < this.fieldList.length; i++) {\n      if (!this.fieldList[i].equals(other.fieldList[i]))\n        return false;\n    }\n    return true;\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/sjmiles/Sites/projects/arcs/arcs/runtime/tuple-fields.js\n// module id = 94\n// module chunks = 0"],"sourceRoot":""}