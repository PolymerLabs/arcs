<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<!doctype html>
<html>
<head>
  <link rel="shortcut icon" href="../apps/common/logo_64.png">
  <title>ArcsLib API Docs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Google+Sans:400,500">
  <style>
    html, body {
      font-family: 'Google Sans';
      margin: 0;
      display: flex;
      width: 100%;
      height: 100%;
      font-size: 16px;
      line-height: 24px;
      color: rgba(0,0,0,.87);
      -webkit-font-smoothing: subpixel-antialiased;
    }
    [toc] {
      background: #222;
      width: 208px;
      padding: 12px 16px;
      color: white;
    }
    [toc] [list] {
      margin: 10px 0;
      color: white;
    }
    [toc] a {
      color: #fff;
      text-decoration: none;
    }
    [docs] {
      overflow-y: scroll;
      flex: 1;
      padding-top: 12px;
    }
    [docs] [dclass] > [name] {
      font-size: 14px;
    }
    [dclass] {
      margin: 0 0 0 24px;
    }

    [dclass] > [desc] {
      margin: 0.6em 0 1.2em;
    }
    [method] {
      margin-bottom: 24px;
    }
    [method] > [name] {
      /* color: #1A73E8; */
      font-weight: 500;
    }
    [method] > [desc] {
      margin: 0.4em 0 1em;
    }
    [chapter] {
      margin-bottom: 20px;
    }
    [chapter] > [name] {
      border-bottom: 1px solid #fff;
      display: block;
      line-height: 32px;
      margin-bottom: 16px;
    }
    [end] {
      margin-bottom: 2em;
    }
    [pre] {
      white-space: pre-wrap;
    }
    pre {
      padding: 16px;
      background-color: #f6f8fa;
    }
    code {
      font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
      background-color: #f6f8fa;
    }
    h1, h2, h3, h4, h5, strong, b {
      font-weight: 500;
    }
    h1 {
      margin: 0 0 20px 0;
      color: #222;
    }
    h2 {
      color: #222;
      padding-top: 20px;
      /* border-top: 1px solid rgba(0,0,0,.5); */
      margin: 12px 0 12px 0;
    }
    h2 img {
      margin-top: -4px;
      margin-left: 4px;
      vertical-align: middle;
      height: 20px;
    }
    p {
      max-width: 800px;
      margin: 12px 0 20px 0;
    }
    p > img {
      width: 800px;
    }
  </style>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/remarkable/1.7.1/remarkable.js"></script>
  <script src="./doc-urls.js"></script>

  <link rel="import" href="../components/doc-scraper.html">


</head>
<body>

  <div toc></div>
  <div docs></div>

  <script>
    let toc = document.querySelector(`[toc]`);
    let doc = document.querySelector(`[docs]`);

    let strcmp = (a,b)=>(a<b)?-1:((a>b)?1:0);

    var buildMdRenderer = (file) => {
      let md = new Remarkable({
        highlight: function (str, lang) {
          if (lang && hljs.getLanguage(lang)) {
            try {
              return hljs.highlight(lang, str).value;
            } catch (err) {}
          }
          return ''; // use external default escaping
        }
      });
      let pathPrefix = file.replace(/(.*\/)[^/]+/, "$1");
      let imgRule = md.renderer.rules.image;
      md.renderer.rules.image = (tokens, idx, options) => {
        tokens[idx].src = pathPrefix + tokens[idx].src;
        return imgRule(tokens, idx, options);
      };
      return md;
    };

    // Convert this-type-of_variables ToCamelNotation.
    let toCamel = fn => {
      return fn.replace(/.*\/([^/.]+)\.\w+/, "$1").replace(/^[a-z]|(-[a-z])|(_[a-z])/g, v => {
        return v.length < 2 ? v.toUpperCase() : v[1].toUpperCase();
      })
    };

    let scrape = async urls => {
      let ismd = url => url.toLowerCase().endsWith('.md');
      let mds = urls.filter(f => ismd(f));
      let others = urls.filter(f => !ismd(f));
      let classes = await new DocScraper().addUrls(others);
      let values = await Promise.all(mds.map(async f => {
        let response = await fetch(f);
        let text = await response.text();
        let name = toCamel(f);
        return {
          name,
          chapter: f.startsWith('docs') ? 'Background' : 'Reference',
          description: buildMdRenderer(f).render(text)
        };
      }));
      return classes.concat(values);
    };

    let renderTopic = topic => {
      let html = [];
      html.push(`
        <div dclass>
          <div name>${topic.name}</div>
          <div desc>${topic.description}</div>
      `.trim());
      topic.methods && topic.methods.forEach(m => {
        html.push(`
          <div method>
            <div name>${m.name}</div>
            <div desc>${m.description}</div>
          </div>
        `.trim());
      });
      html.push(`</div>`);
      html.push(`<div end></div>`)
      return html.join('');
    }

    let renderDocs = docs => {
      let html = [];
      if (docs.classes) {
        docs.classes.sort((a,b) => strcmp(a.name, b.name));
        html = docs.classes.map(renderTopic);
      }
      doc.innerHTML = html.join(` `);
    }

    let renderToc = data => {
      // TODO: add @chapter pragma to the source code.
      let chapter = cls => cls.chapter || 'Reference';
      let html = []
      new Set(data.classes.map(cls => chapter(cls))).forEach(c => {
        let topics = data.classes.filter(cls => chapter(cls) == c).map(c => c.name);
        html.push(`<div chapter><div name>${c}</div>`);
        Array.prototype.push.apply(html, topics.map(t => `<div list><a href="#${t}" title="${t}">${t}</a></div>`));
        html.push('</div>');
      });
      toc.innerHTML = html.join('');
    };

    let corpus;

    scrape(window.docUrls).then(classes => {
      console.log(classes);
      corpus = {classes};
      renderToc(corpus);
      updateTopic();
    });

    let updateTopic = () => {
      let name = location.hash.slice(1) || `Manifest`;
      // debugger;
      let topic = corpus.classes.find(c => c.name === name);
      doc.innerHTML = topic ? renderTopic(topic) : 'n/a';
    };

    window.onhashchange = e => {
      updateTopic();
    };
  </script>

</body>
</html>
