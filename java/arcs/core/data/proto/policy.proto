syntax = "proto3";

package arcs;

option java_package = "arcs.core.data.proto";
option java_multiple_files = true;

// Defines a data usage policy.
message PolicyProto {
  // Policy name.
  string name = 1;

  // Targets governed by the policy.
  repeated PolicyTargetProto targets = 2;

  // Additional config metadata for the policy.
  repeated PolicyConfigProto configs = 3;

  // Human readable description for the policy.
  string description = 4;

  enum EgressType {
    EGRESS_TYPE_UNSPECIFIED = 0;
    LOGGING = 1;
    FEDERATED_ANALYTICS = 2;
  }
  // Egress type permitted by the policy.
  EgressType egress_type = 5;

  // Whether user consent is required before using the policy.
  bool user_consent_required = 6;

  enum ApprovalCondition {
    APPROVAL_CONDITION_UNSPECIFIED = 0;
    PRE_APPROVED = 1;
    APPROVAL_REQUIRED = 2;
  }
  // Approval condition for the policy.
  ApprovalCondition approval_condition = 7;
}

message PolicyTargetProto {
  // ID of the store targeted by the policy.
  string store_id = 1;

  // Valid retention options for storing the target data.
  repeated PolicyRetentionProto retentions = 2;

  // Allowed usages for all fields in this target type.
  repeated PolicyFieldProto fields = 3;
}

message PolicyFieldProto {
  // Field name.
  string name = 1;

  enum UsageType {
    USAGE_TYPE_UNSPECIFIED = 0;
    // Can be used for anything.
    ANY = 1;
    // Can be egressed.
    EGRESS = 2;
    // Can be used in joins, but not read.
    JOIN = 3;
  }

  message AllowedUsages {
    // Indicates all types of usages that are permitted. An empty list indicates
    // no usages are permitted.
    repeated UsageType usages = 1;
  }

  // Specifies the allowed usages of raw data.
  AllowedUsages raw_usages = 2;

  // Specifies the allowed usages given that certain redactions have been
  // performed first. Maps from redaction label to AllowedUsages.
  map<string, AllowedUsages> redacted_usages = 3;

  // Specified usages for subfields nested inside this field.
  repeated PolicyFieldProto subfields = 4;
}

// Storage retention options for a policy target.
message PolicyRetentionProto {
  enum Medium {
    MEDIUM_UNSPECIFIED = 0;
    RAM = 1;
    DISK = 2;
  }
  // Allowed retention medium.
  Medium medium = 1;

  // Whether encryption is required when using this medium.
  bool encryption_required = 2;
}

// Encode additional metadata for a policy.
message PolicyConfigProto {
  // Name for the config.
  string name = 1;

  // Data contained in the config. This encodes arbitrary metadata as string
  // key-value pairs. The keys should all have a known meaning given the config
  // name.
  map<string, string> metadata = 2;
}
