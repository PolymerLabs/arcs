/*
 * Copyright 2019 Google LLC.
 *
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 *
 * Code distributed by Google as part of this project is also subject to an additional IP rights
 * grant found at
 * http://polymer.github.io/PATENTS.txt
 */

package arcs.core.storage

import arcs.core.crdt.CrdtData
import arcs.core.crdt.CrdtOperation
import arcs.core.storage.util.RandomProxyCallbackManager
import arcs.core.type.Type
import arcs.core.util.LruCacheMap
import arcs.core.util.Random
import arcs.core.util.TaggedLog
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock

/**
 * An collection of [DirectStore]s that allows multiple CRDT models to be stored as sub-keys
 * of a single [StorageKey] location.
 *
 * This is what *backs* Entities.
 */
class DirectStoreMuxer<Data : CrdtData, Op : CrdtOperation, T>(
    val storageKey: StorageKey,
    val backingType: Type,
    private val options: StoreOptions? = null
) {
    private val stateMutex = Mutex()
    private val log = TaggedLog { "DirectStoreMuxer" }
    private val proxyManager = RandomProxyCallbackManager<Data, Op, T>(
        "backing",
        Random
    )

    // TODO(b/158262634): Make this CacheMap Weak.
    /* internal */ val stores = LruCacheMap<String, StoreRecord<Data, Op, T>>(
        50,
        livenessPredicate = { _, sr -> !sr.store.closed }
    ) { muxId, sr -> closeStore(muxId, sr) }

    // Keeps track of all the stores a callbackId is registered to. Used when removing an
    // observer (off method), as that requires unregistering to each store it is registered with.
    private val callbackIdToMuxIdMap = mutableMapOf<Int, MutableSet<String>>()

    fun on(callback: ProxyCallback<Data, Op, T>, callbackToken: Int? = null): Int  = runBlocking {
        // Direct Store Muxer must generate the callback token to ensure no duplicates.
        check(callbackToken == null) { "token must be generated by Direct Store Muxer" }
        stateMutex.withLock {
            val callbackId = proxyManager.register(callback, callbackToken)
            callbackIdToMuxIdMap[callbackId] = mutableSetOf()
            callbackId
        }
    }

    fun off(callbackToken: Int) = runBlocking {
        stateMutex.withLock {
            for (muxId in callbackIdToMuxIdMap.getOrElse(callbackToken, { mutableSetOf() })) {
                val (idSet, store) = checkNotNull(stores[muxId]) { "store not found" }
                store.off(callbackToken)
                idSet.remove(callbackToken)
            }
            callbackIdToMuxIdMap.remove(callbackToken)
            proxyManager.unregister(callbackToken)
        }
    }

    /**
     * Safely closes a [DirectStore] and cleans up its resources.
     *
     * closeStore mutates state and therefore must only be called by a function that holds the
     * stateMutex.
     */
    private fun closeStore(muxId: String, storeRecord: StoreRecord<*, *, *>) {
        if (!storeRecord.store.closed) {
            log.debug { "close the store($muxId)" }

            try {
                for (id in storeRecord.idSet) {
                    callbackIdToMuxIdMap[id]?.remove(muxId)
                }
                storeRecord.store.close()
            } catch (e: Exception) {
                // TODO(b/160251910): Make logging detail more cleanly conditional.
                log.debug(e) { "failed to close the store($muxId)" }
                log.info { "failed to close the store" }
            }
        }
    }

    /**
     * Gets data from the store corresponding to the given [muxId].
     */
    suspend fun getLocalData(muxId: String, id: Int): Data {
        // registerToStore will only register to the store if the id is not already registered
        val (_, store) = getStore(muxId, id)

        return store.getLocalData()
    }
    /** Removes [DirectStore] caches and closes those that can be closed safely. */
    suspend fun clearStoresCache() = stateMutex.withLock {
        for ((muxId, storeRecord) in stores) {
            if (!storeRecord.store.closed) closeStore(muxId, storeRecord)
        }
        stores.clear()
    }

    /** Calls [idle] on all existing contained stores and waits for their completion. */
    suspend fun idle() = stateMutex.withLock {
        stores.values.toList()
    }.map {
        /**
         * If the overhead/wall-time of [DirectStore.idle] is longer than an
         * [CoroutineScope.launch] i.e. more than 5ms debounce time, launching
         * [DirectStore.idle]s in parallel can further help performance,
         */
        it.store.idle()
    }

    /**
     * Sends the provided [ProxyMessage] to the store backing the provided [muxId].
     *
     * A new store will be created for the [muxId], if necessary.
     */
    suspend fun onProxyMessage(
        message: ProxyMessage<Data, Op, T>
    ): Boolean {
        val muxId = requireNotNull(message.muxId) {
            "messages sent to Direct Store Muxer must have a muxId"
        }
        val (_, store) = getStore(muxId, message.id!!)
        return store.onProxyMessage(message)
    }

    /* internal */ suspend fun setupStore(muxId: String): StoreRecord<Data, Op, T> {
        val store = DirectStore.create<Data, Op, T>(
            StoreOptions(
                storageKey = storageKey.childKeyWithComponent(muxId),
                type = backingType,
                coroutineScope = options?.coroutineScope
            )
        )

        // Return a new Record with initially empty idSet
        return StoreRecord(mutableSetOf<Int>(), store)
    }

    /**
     * Return the [StoreRecord] for a given muxId.
     *
     * If an id is provided, ensures that the id is registered to the [Store] of the [StoreRecord]
     */
    suspend fun getStore(muxId: String, id: Int? = null): StoreRecord<Data, Op, T> {
        stateMutex.withLock {
            val storeRecord = stores.getOrPut(muxId) {
                setupStore(muxId)
            }

            // Register `id` with store if it is not already registered. It is necessary to register
            // a callback per id because when the Direct Store Muxer receives a message from the
            // Direct Store, it utilizes the message id to determine which observer to redirect
            // the message to.
            if (id != null) {
                // Ensure 'id' has already registered with proxyManager
                check(proxyManager.callbacks.containsKey(id)) {
                    "Callback token is not registered to the Direct Store Muxer."
                }

                if (!storeRecord.idSet.contains(id)) {
                    storeRecord.store.on(
                        ProxyCallback { message ->
                            stateMutex.withLock { proxyManager.getCallback(id)?.invoke(message.withMuxId(muxId)) }
                        },
                        id
                    )
                    storeRecord.idSet.add(id)
                    callbackIdToMuxIdMap.getOrPut(id, { mutableSetOf() }).add(muxId)
                }
            }

            return storeRecord
        }
    }

    suspend fun consistentState(): Boolean = stateMutex.withLock {
        // check stores is consistent with proxyManager and callbackIdToMuxIdMap
        for ((muxId, sr) in stores) {
            if (!proxyManager.callbacks.keys.containsAll(sr.idSet)) return false

            for (id in sr.idSet) {
                if (!callbackIdToMuxIdMap.containsKey(id)) return false
                if (!callbackIdToMuxIdMap[id]!!.contains(muxId)) return false
            }
        }

        // check callbackIdToMuxIdMap is consistent with proxyManager and stores
        if (!proxyManager.callbacks.keys.containsAll(callbackIdToMuxIdMap.keys)) return false
        for ((id, muxIdSet) in callbackIdToMuxIdMap) {
            for (muxId in muxIdSet) {
                if (!stores.containsKey(muxId)) return false
                if (!stores[muxId]!!.idSet.contains(id)) return false
            }
        }
        return true
    }

    data class StoreRecord<Data : CrdtData, Op : CrdtOperation, T>(
        val idSet: MutableSet<Int>,
        val store: DirectStore<Data, Op, T>
    )
}
