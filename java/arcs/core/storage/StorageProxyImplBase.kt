/*
 * Copyright 2020 Google LLC.
 *
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 *
 * Code distributed by Google as part of this project is also subject to an additional IP rights
 * grant found at
 * http://polymer.github.io/PATENTS.txt
 */
package arcs.core.storage

import arcs.core.crdt.CrdtData
import arcs.core.crdt.CrdtOperation
import arcs.core.util.ArcsStrictMode
import arcs.core.util.Scheduler
import arcs.core.util.TaggedLog
import kotlinx.atomicfu.atomic
import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.TimeoutCancellationException
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.channels.ConflatedBroadcastChannel
import kotlinx.coroutines.flow.asFlow
import kotlinx.coroutines.flow.buffer
import kotlinx.coroutines.flow.consumeAsFlow
import kotlinx.coroutines.flow.debounce
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onCompletion
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import kotlinx.coroutines.withTimeout
import kotlinx.coroutines.withTimeoutOrNull

private const val CLOSE_TIMEOUT = 15000L

/** Base class for [StorageProxy] implementations that provides standard message queue operations. */
abstract class StorageProxyImplBase<Data : CrdtData, Op : CrdtOperation, T>(
  private val scheduler: Scheduler
) {
  val dispatcher: CoroutineDispatcher
    get() = scheduler.asCoroutineDispatcher()

  // This will be initialized by the [create] method below.
  protected lateinit var store: StorageEndpoint<Data, Op, T>
  protected val outgoingMessagesChannel =
    Channel<Pair<ProxyMessage<Data, Op, T>, CompletableDeferred<Boolean>>>(Channel.UNLIMITED)
  private val outgoingMessagesInFlight = atomic(0)
  private val busySendingMessagesChannel = ConflatedBroadcastChannel(false)
  private val log = TaggedLog { "StorageProxyBaseImpl" }

  // Send messages generated by applyOp to the Store in the order in which they were received
  // by:
  //
  // 1. Calling store.onProxyMessage() with the message for each message.
  // 2. Buffering those calls so they happen in parallel/pipelined-with calling store.idle()
  // 3. Once the store is self-identifying as idle, complete the deferred which was generated
  //    at the same time as the message (and was returned to the caller)
  protected val outgoingMessagesJob = outgoingMessagesChannel.consumeAsFlow()
    .map { (message, deferredToComplete) ->
      log.verbose { "Sending operations to store" }
      store.onProxyMessage(message)
      log.verbose { "Operations sent to store" }
      deferredToComplete
    }
    .buffer(Channel.UNLIMITED)
    .onEach {
      // TODO(jasonwyatt): Make the deferred lazy, so that we only idle when the client
      //  requests it, we could probably just use the busySendingMessagesChannel thinger.

      val success = withTimeoutOrNull(5000) { store.idle() }
      if (success == null) {
        log.info {
          "Timeout exceeded (5 seconds) while waiting for store to become idle."
        }
      }
      it.complete(true)

      val queueLength = outgoingMessagesInFlight.getAndDecrement()
      log.debug { "Store went idle with outgoing queue length: $queueLength" }
      if (queueLength == 1) {
        busySendingMessagesChannel.send(false)
      }
    }
    .onCompletion {
      busySendingMessagesChannel.send(false)
      closeInternal()
    }
    .launchIn(scheduler.scope)

  /** Implements additional implementation specific cleanup logic. */
  protected abstract fun closeInternal()

  suspend fun awaitOutgoingMessageQueueDrain() {
    busySendingMessagesChannel.asFlow().debounce(50).filter { !it }.first()
  }

  suspend fun waitForIdle() {
    scheduler.waitForIdle()
    awaitOutgoingMessageQueueDrain()
  }

  suspend fun isIdle(): Boolean {
    return scheduler.isIdle() && !busySendingMessagesChannel.asFlow().first()
  }

  /** Returns true when the proxy has successfully closed. */
  abstract fun isClosed(): Boolean

  suspend fun close() {
    if (isClosed()) return

    scheduler.waitForIdle()

    // First, shut down the outgoing messages channel and give it a chance to drain.
    // If it takes to long, cancel the job.
    try {
      withTimeout(CLOSE_TIMEOUT) {
        outgoingMessagesChannel.close()
        outgoingMessagesJob.join()
      }
    } catch (e: TimeoutCancellationException) {
      log.warning { "outgoingMessagesChannel drain timeout" }
      if (outgoingMessagesJob.isActive) {
        outgoingMessagesJob.cancel()
      }
    }

    // Now, close the store backing this proxy.
    // Again, if it takes too long, cancel the job.
    val storeCloseJob = scheduler.scope.launch {
      store.close()
    }

    try {
      withTimeout(CLOSE_TIMEOUT) {
        storeCloseJob.join()
      }
    } catch (e: TimeoutCancellationException) {
      log.warning { "store close timeout" }
      if (storeCloseJob.isActive) {
        storeCloseJob.cancel()
      }
    }
  }

  fun sendMessageToStore(
    message: ProxyMessage<Data, Op, T>,
    deferred: CompletableDeferred<Boolean> = CompletableDeferred()
  ) {
    val queueNum = outgoingMessagesInFlight.getAndIncrement()
    if (queueNum == 0) {
      busySendingMessagesChannel.offer(true)
    }
    do {
      val sent = outgoingMessagesChannel.offer(message to deferred)
    } while (!sent)
    log.verbose {
      "Queueing successful for message (pos: $queueNum) for sending to the store: $message"
    }
  }

  protected fun checkInDispatcher() = check(
    !ArcsStrictMode.strictHandles || scheduler.isCurrentDispatcher()
  ) {
    "Operations can only be performed using the Scheduler's Dispatcher"
  }
}
