load(":run_in_repo.bzl", "EXECUTION_REQUIREMENTS_TAGS", "run_in_repo", "run_in_repo_test")

def sigh_command(
        name,
        srcs,
        sigh_cmd,
        progress_message = "",
        outs = [],
        deps = [],
        execute = True,
        quiet = True,
        flaky = False,
        visibility = []):
    """Runs the tool/sigh command from bazel with the given sign_cmd arguments.

    Note: Any files (e.g. additional src, build outputs, etc) needed to be seen
    by the sigh tool should be added in the deps attribute.

    Args:
      name: name of the target to create
      srcs: list of source files to include
      sigh_cmd: the sigh subcommand to run, with args
      progress_message: message to display when this rule is running
      outs: list of output files generated by the rule
      deps: list of dependencies
      execute: boolean indicating whether this sigh command is executable,
        e.g. tests
      quiet: boolean indicating whether to suppress sigh output
      flaky: boolean indicating whether the test is flaky and should be re-run
        on failure.
      visibility: list of visibilities
    """

    # The default bazel working directory for all actions is
    # WORKDIR: ~/.cache/bazel/_bazel_$USER/<project_path_hash>/execroot/__main__
    # All directories under the WORKDIR are symbolic links to the directories
    # at the source project tree.
    # The executed sigh commands would generate outputs against the WORKDIR ends
    # up the webpacking/building/etc processes cannot resolve the correct paths
    # under the <project_source_root>/**.
    # The trick 'cd -P tools/..' switches the symlink paths to the corresponding
    # physical directories at the <project_source_root> to ensure the anticipated
    # webpacking/building/etc results. If the 'tools' folder does not exist or
    # we are already at the physical directory, it does nothing.
    cmd = "cd -P tools/..; $(location //tools:sigh_bin) "
    if quiet:
        cmd += "--quiet "
    cmd += sigh_cmd

    _run_macro(
        name = name,
        srcs = srcs,
        outs = outs,
        cmd = cmd,
        execute = execute,
        progress_message = progress_message,
        tags = EXECUTION_REQUIREMENTS_TAGS,
        flaky = flaky,
        deps = [
            "//:all_srcs",
            "//:concrete_storage_node_modules",
            "//:node_modules",
            "//tools:sigh_bin",
            "//tools:tools_srcs",
            "//:tsconfig",
        ] + deps,
        visibility = visibility,
    )

def _run_macro(execute, **kwargs):
    if execute:
        kwargs.pop("flaky")
        run_in_repo(**kwargs)
    else:
        run_in_repo_test(**kwargs)
