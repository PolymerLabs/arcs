"""Arcs manifest bundling rules."""

load(":tools.oss.bzl", "arcs_tool_manifest2proto", "arcs_tool_recipe2plan")
load(":util.bzl", "replace_arcs_suffix")

def arcs_manifest(name, srcs, deps = [], visibility = None):
    """Bundles .arcs manifest files with their particle implementations.

    Generates a filegroup that can be included in e.g. an Android assets folder.

    Args:
      name: the name of the target to create
      srcs: list of Arcs manifest files to include
      deps: list of dependencies (other arcs_manifest targets)
      visibility: list of visibilities
    """
    for src in srcs:
        if not src.endswith(".arcs"):
            fail("src must be an .arcs manifest file, found %s" % src)

    # All the files that need to go in the filegroup.
    all_files = srcs + deps

    native.filegroup(
        name = name,
        srcs = all_files,
        visibility = visibility,
    )

def arcs_manifest_proto(name, src, deps = [], out = None, visibility = None):
    """Serialize a manifest file.

    This converts a '.arcs' file into a protobuf representation, using manifest2proto.

    Args:
      name: the name of the target to create
      src: an Arcs manifest file to serialize
      deps: list of dependencies (other manifests)
      out: the name of the output artifact (a proto file).
      visibility: list of visibilities
    """
    outs = [out] if out != None else [replace_arcs_suffix(name, ".pb.bin")]

    arcs_tool_manifest2proto(
        name = name,
        srcs = [src],
        outs = outs,
        deps = deps,
    )

def arcs_proto_plan(name, src, recipe = None, deps = []):
    """Converts recipes from a manifest into plans encoded as a protobuf.

    Example:

      ```
          arcs_proto_plan(
            name = "foo_proto_plan",
            src = "Foo.arcs",
            recipe = "MyRecipe", # Optional
            deps = [
              "Other.arcs",
              "Imported.arcs",
              "Stuff.arcs",
            ]
          )
      ```

    Args:
      name: the name of the target to create
      src: an Arcs manifest file to source recipes from
      recipe: an optional name of the recipe to filter output plans by name
      deps: list of dependencies - other manifests that are imported by src manifest
    """
    arcs_tool_recipe2plan(
        name = name,
        srcs = [src],
        outs = [name + ".pb.bin"],
        recipe = recipe,
        generate_proto = True,
        deps = deps,
    )

def _generate_root_manifest_content(label, input_files):
    """Generates the contents for a root manifest for a manifest bundle.

    Args:
      label: the BUILD rule that generated the bundle, e.g. //a/b:c
      input_files: File objects for all the input files in the bundle.
    """

    content = ["// Root manifest generated by %s." % label]
    for input_file in input_files:
        if input_file.basename.endswith(".arcs"):
            content.append("import '%s'" % input_file.short_path)
    return "\n".join(content)

def _arcs_manifest_bundle(ctx):
    input_files = list(ctx.files.deps)
    folder = ctx.attr.folder

    # Make sure folder ends with a slash
    if folder:
        folder += "/"

    # Generate root manifest.
    root_manifest_filename = folder + "Root.arcs"
    root_manifest_file = ctx.actions.declare_file(root_manifest_filename)
    ctx.actions.write(
        output = root_manifest_file,
        content = _generate_root_manifest_content(ctx.label, input_files),
    )

    output_files = [root_manifest_file]

    # Make a copy of all of the input files included in deps, preserving their
    # entire relative path within the repo. That is, if this rule is being
    # invoked from //a/b:c, and has dep //d/e:f, then the dep will be copied to
    # bazel-out/.../bin/a/b/d/e/f. This ensures that when something this
    # manifest bundle is included in an Android assets folder, all the relative
    # paths will be preserved inside the assets folder (i.e. assets/d/e/f).
    for input_file in input_files:
        output_relative_path = folder + input_file.short_path
        output_file = ctx.actions.declare_file(output_relative_path)
        ctx.actions.run_shell(
            outputs = [output_file],
            inputs = [input_file],
            command = "cp $1 $2",
            arguments = [
                input_file.path,
                output_file.path,
            ],
        )
        output_files.append(output_file)

    # TODO: Perform dataflow analysis on the resulting root manifest.

    return [DefaultInfo(files = depset(output_files))]

arcs_manifest_bundle = rule(
    implementation = _arcs_manifest_bundle,
    attrs = {
        "deps": attr.label_list(allow_files = True),
        "folder": attr.string(
            default = "arcs",
            doc = """Optional folder/path under which to nest the bundled
            manifest files. Can be empty""",
        ),
    },
    doc = """Bundles up a number of arcs_manifest rules into a single filegroup.

    This lets you include multiple different manifests in, e.g., your Android
    assets folder. Also generates a root manifest which imports all the other
    manifests.
    """,
)
