package arcs.core.host

import arcs.core.entity.Entity
import arcs.core.entity.EntitySpec
import arcs.core.host.api.HandleHolder
import arcs.core.host.api.Particle
import arcs.core.storage.testutil.testStorageEndpointManager
import arcs.core.testutil.FuzzingRandom
import arcs.core.testutil.Generator
import arcs.core.testutil.Transformer
import arcs.jvm.host.ExplicitHostRegistry
import arcs.sdk.HandleHolderBase
import kotlin.coroutines.EmptyCoroutineContext
import kotlinx.coroutines.runBlocking

/**
 * Generators for arcs.core.host classes.
 */

/**
 * Generate a [ParticleRegistration] given a name and connection map. The name and connection map
 * are required because [ParticleRegstration] includes [ParticleConstructor], which needs to
 * return a particle which will allow valid handleConnections to be connected.
 */
class ParticleRegistrationGenerator(
  val s: FuzzingRandom,
  val name: Generator<String>,
  val connections: Generator<Map<String, Set<EntitySpec<out Entity>>>>
) : Generator<ParticleRegistration> {
  override operator fun invoke(): ParticleRegistration {
    class SpecialParticle(override val handles: HandleHolder) : Particle
    val theName = name()
    val theConnections = connections()
    val particle = SpecialParticle(HandleHolderBase(theName, theConnections))
    // by default, location would just be the className. However, this results in all particles
    // generated by this class sharing a key, which means that the Allocator aliases them 
    // together.
    val location = "${SpecialParticle::class.className()}${s.nextInt()}"
    val registrationFunction: ParticleConstructor = { particle }
    return ParticleIdentifier.from(location) to registrationFunction
  }
}

/**
 * Given a list of [ParticleRegistration]s, generate a [HostRegistry] with all particles
 * registered by an [ArcHost]. This implementation ensures that every [ParticleRegistration]
 * is mapped to exactly one [ArcHost]; and that there are not more [ArcHost]s than
 * [Particles]. This implementation does not guarantee that every [ArcHost] will map a
 * [Particle] - some [ArcHost]s may end up empty.
 */
class HostRegistryFromParticles(
  val s: FuzzingRandom
) : Transformer<List<ParticleRegistration>, HostRegistry>() {
  override operator fun invoke(i: List<ParticleRegistration>): HostRegistry {
    assert(i.size > 0)
    val numHosts = this.s.nextInRange(1, i.size)
    val particleMappings = (1..numHosts).map { mutableListOf<ParticleRegistration>() }
    i.forEach { particleMappings[this.s.nextLessThan(numHosts)].add(it) }
    val registry = ExplicitHostRegistry()
    particleMappings.map {
      TestingHost(
        SimpleSchedulerProvider(EmptyCoroutineContext),
        testStorageEndpointManager(),
        *(it.toTypedArray())
      )
    }.forEach { runBlocking { registry.registerHost(it) } }
    return registry
  }
}
